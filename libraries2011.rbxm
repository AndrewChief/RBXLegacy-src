<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Script" referent="RBX0">
		<Properties>
			<bool name="Disabled">false</bool>
			<Content name="LinkedSource"><null></null></Content>
			<string name="Name">Sorter</string>
			<ProtectedString name="Source">print(&quot;Special thanks to Bitl, Carrot, iago, winsupermario1234, Khangaroo, drslicendice, coke, TheLivingBee, Raymonf, and a bunch of play - testers for help making 2011 fully stable and work. 8)&quot;)
script.Playerlist:clone().Parent = game.StarterGui
script.Dialogs:clone().Parent = game.StarterGui
script.Health:clone().Parent = game.StarterGui
script.ReenableDialogScript:clone().Parent = game.Lighting
script.TimeoutScript:clone().Parent = game.Lighting
script.ResetCommand:clone().Parent = game.Workspace
script:remove()</ProtectedString>
		</Properties>
		<Item class="Script" referent="RBX1">
			<Properties>
				<bool name="Disabled">true</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">ReenableDialogScript</string>
				<ProtectedString name="Source">wait(5)
local dialog = script.Parent
if dialog:IsA(&quot;Dialog&quot;) then
&#9;dialog.InUse = false
end&#9;
script:Remove()
</ProtectedString>
			</Properties>
		</Item>
		<Item class="Script" referent="RBX2">
			<Properties>
				<bool name="Disabled">true</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">TimeoutScript</string>
				<ProtectedString name="Source">wait(5)
local dialog = script.Parent
if dialog:IsA(&quot;Dialog&quot;) then
&#9;dialog.InUse = false
end&#9;
script:Remove()
</ProtectedString>
			</Properties>
		</Item>
		<Item class="Script" referent="RBX3">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">ResetCommand</string>
				<ProtectedString name="Source">function onChatted(msg, speaker)
    
    source = string.lower(speaker.Name)
    msg = string.lower(msg)
    -- Note: This one is NOT caps sensitive

    if msg == &quot;!!!reset&quot; then
        speaker.Character.Humanoid.Health = 0
    end
end

function onPlayerEntered(newPlayer)
        newPlayer.Chatted:connect(function(msg) onChatted(msg, newPlayer) end) 
end
 
game.Players.ChildAdded:connect(onPlayerEntered)</ProtectedString>
			</Properties>
		</Item>
		<Item class="GuiMain" referent="RBX4">
			<Properties>
				<string name="Name">Health</string>
			</Properties>
			<Item class="Frame" referent="RBX5">
				<Properties>
					<bool name="Active">false</bool>
					<Color3 name="BackgroundColor3">4285215356</Color3>
					<float name="BackgroundTransparency">1</float>
					<Color3 name="BorderColor3">4279970357</Color3>
					<int name="BorderSizePixel">1</int>
					<bool name="ClipsDescendants">false</bool>
					<bool name="Draggable">false</bool>
					<string name="Name">tray</string>
					<UDim2 name="Position">
						<XS>0.5</XS>
						<XO>-44</XO>
						<YS>1</YS>
						<YO>-26</YO>
					</UDim2>
					<UDim2 name="Size">
						<XS>0</XS>
						<XO>170</XO>
						<YS>0</YS>
						<YO>18</YO>
					</UDim2>
					<token name="SizeConstraint">2</token>
					<token name="Style">0</token>
					<bool name="Visible">true</bool>
					<int name="ZIndex">1</int>
				</Properties>
				<Item class="ImageLabel" referent="RBX6">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4294967295</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<Content name="Image"><url>rbxasset://textures/healthgui/bkg.png</url></Content>
						<string name="Name">bkg</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>1</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
				</Item>
				<Item class="ImageLabel" referent="RBX7">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4294967295</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<Content name="Image"><url>rbxasset://textures/healthgui/BarRed.png</url></Content>
						<string name="Name">barRed</string>
						<UDim2 name="Position">
							<XS>0.0189999994</XS>
							<XO>0</XO>
							<YS>0.100000001</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
				</Item>
				<Item class="Frame" referent="RBX8">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4294967295</Color3>
						<float name="BackgroundTransparency">1.00000012</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<string name="Name">bar2</string>
						<UDim2 name="Position">
							<XS>0.0189999994</XS>
							<XO>0</XO>
							<YS>0.100000001</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0.192000002</XS>
							<XO>0</XO>
							<YS>0.829999983</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
					<Item class="LocalScript" referent="RBX9">
						<Properties>
							<bool name="Disabled">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Init</string>
							<ProtectedString name="Source">h = game.Players.LocalPlayer.Character.Humanoid
tray = script.Parent.Parent
base = tray.Parent
local lastHealth = 100
local lastHealth2 = 100
local maxWidth = 0.96

function UpdateGUI(health)
&#9;local width = (health / h.MaxHealth) * maxWidth
&#9;local height = 0.83
&#9;local lastX = tray.bar.Position.X.Scale
&#9;local x = 0.019 + (maxWidth - width)
&#9;local y = 0.1
&#9;
&#9;tray.bar.Position = UDim2.new(x,0,y, 0) 
&#9;tray.bar.Size = UDim2.new(width, 0, height, 0)
&#9;-- If more than 1/4 health, bar = green.  Else, bar = red.
&#9;if( (health / h.MaxHealth) &gt; 0.25 ) then
&#9;&#9;tray.barRed.Size = UDim2.new(0, 0, 0, 0)
&#9;else
&#9;&#9;tray.barRed.Position = tray.bar.Position
&#9;&#9;tray.barRed.Size = tray.bar.Size
&#9;&#9;tray.bar.Size = UDim2.new(0, 0, 0, 0)
&#9;end
&#9;
&#9;if ( (lastHealth - health) &gt; (h.MaxHealth / 10) ) then
&#9;&#9;lastHealth = health

&#9;&#9;if h.Health ~= h.MaxHealth then
&#9;&#9;&#9;delay(0,function()
&#9;&#9;&#9;&#9;AnimateHurtOverlay()
&#9;&#9;&#9;end)
&#9;&#9;&#9;delay(0,function()
&#9;&#9;&#9;&#9;AnimateBars(x, y, lastX, height)
&#9;&#9;&#9;end)
&#9;&#9;end
&#9;else
&#9;&#9;lastHealth = health
&#9;end
end

function AnimateBars(x, y, lastX, height)
&#9;local width = math.abs(x - lastX)
&#9;if( x &gt; lastX ) then
&#9;&#9;x = lastX
&#9;end
&#9;tray.bar2.Position = UDim2.new(x,0, y, 0)
&#9;tray.bar2.Size = UDim2.new(width, 0, height, 0)
&#9;tray.bar2.BackgroundTransparency = 0
&#9;local GBchannels = 1
&#9;local j = 0.2

&#9;local i_total = 30
&#9;for i=1,i_total do
&#9;&#9;-- Increment Values
&#9;&#9;if (GBchannels &lt; 0.2) then
&#9;&#9;&#9;j = -j
&#9;&#9;end
&#9;&#9;GBchannels = GBchannels + j
&#9;&#9;if (i &gt; (i_total - 10)) then
&#9;&#9;&#9;tray.bar2.BackgroundTransparency = tray.bar2.BackgroundTransparency + 0.1
&#9;&#9;end
&#9;&#9;tray.bar2.BackgroundColor3 = Color3.new(1, GBchannels, GBchannels)
&#9;&#9;
&#9;&#9;wait(0.02)
&#9;end
end

function AnimateHurtOverlay()
&#9;-- Start:
&#9;-- overlay.Position = UDim2.new(0, 0, 0, -22)
&#9;-- overlay.Size = UDim2.new(1, 0, 1.15, 30)
&#9;
&#9;-- Finish:
&#9;-- overlay.Position = UDim2.new(-2, 0, -2, -22)
&#9;-- overlay.Size = UDim2.new(4.5, 0, 4.65, 30)
&#9;
&#9;overlay = base.hurtOverlay
&#9;overlay.Visible = true
&#9;overlay.Position = UDim2.new(-2, 0, -2, -22)
&#9;overlay.Size = UDim2.new(4.5, 0, 4.65, 30)
&#9;-- Animate In, fast
&#9;local i_total = 2
&#9;local wiggle_total = 0
&#9;local wiggle_i = 0.02
&#9;for i=1,i_total do
&#9;&#9;overlay.Position = UDim2.new( (-2 + (2 * (i/i_total)) + wiggle_total/2), 0, (-2 + (2 * (i/i_total)) + wiggle_total/2), -22 )
&#9;&#9;overlay.Size = UDim2.new( (4.5 - (3.5 * (i/i_total)) + wiggle_total), 0, (4.65 - (3.5 * (i/i_total)) + wiggle_total), 30 )
&#9;&#9;wait(0.01)
&#9;end
&#9;
&#9;i_total = 30
&#9;
&#9;wait(0.03)
&#9;
&#9;-- Animate Out, slow
&#9;for i=1,i_total do
&#9;&#9;if( math.abs(wiggle_total) &gt; (wiggle_i * 3) ) then
&#9;&#9;&#9;wiggle_i = -wiggle_i
&#9;&#9;end
&#9;&#9;wiggle_total = wiggle_total + wiggle_i
&#9;&#9;overlay.Position = UDim2.new( (0 - (2 * (i/i_total)) + wiggle_total/2), 0, (0 - (2 * (i/i_total)) + wiggle_total/2), -22 )
&#9;&#9;overlay.Size = UDim2.new( (1 + (3.5 * (i/i_total)) + wiggle_total), 0, (1.15 + (3.5 * (i/i_total)) + wiggle_total), 30 )
&#9;&#9;wait(0.01)
&#9;end
&#9;
&#9;-- Hide after we&apos;re done
&#9;overlay.Position = UDim2.new(10, 0, 0, 0)
&#9;overlay.Visible = false
end

h.Changed:connect(function()
&#9;UpdateGUI(h.Health)
&#9;if ( (lastHealth2 - h.Health) &gt; (h.MaxHealth / 10) ) then
&#9;&#9;lastHealth2 = h.Health
&#9;else
&#9;&#9;lastHealth2 = h.Health
&#9;end end)</ProtectedString>
						</Properties>
					</Item>
				</Item>
				<Item class="ImageLabel" referent="RBX10">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4294967295</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<Content name="Image"><url>rbxasset://textures/healthgui/Bar.png</url></Content>
						<string name="Name">bar</string>
						<UDim2 name="Position">
							<XS>0.0189999994</XS>
							<XO>0</XO>
							<YS>0.100000001</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0.959999979</XS>
							<XO>0</XO>
							<YS>0.829999983</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
				</Item>
				<Item class="ImageLabel" referent="RBX11">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4294967295</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<Content name="Image"><url>rbxasset://textures/healthgui/label.png</url></Content>
						<string name="Name">label</string>
						<UDim2 name="Position">
							<XS>0.680000007</XS>
							<XO>0</XO>
							<YS>0.300000012</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0.25</XS>
							<XO>0</XO>
							<YS>0.349999994</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
				</Item>
			</Item>
			<Item class="ImageLabel" referent="RBX12">
				<Properties>
					<bool name="Active">false</bool>
					<Color3 name="BackgroundColor3">4290164919</Color3>
					<float name="BackgroundTransparency">1</float>
					<Color3 name="BorderColor3">4279970357</Color3>
					<int name="BorderSizePixel">1</int>
					<bool name="ClipsDescendants">false</bool>
					<bool name="Draggable">false</bool>
					<Content name="Image"><url>rbxasset://textures/healthgui/HurtOverlay.png</url></Content>
					<string name="Name">hurtOverlay</string>
					<UDim2 name="Position">
						<XS>2</XS>
						<XO>0</XO>
						<YS>0</YS>
						<YO>-22</YO>
					</UDim2>
					<UDim2 name="Size">
						<XS>1</XS>
						<XO>0</XO>
						<YS>1.1500001</YS>
						<YO>30</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<bool name="Visible">false</bool>
					<int name="ZIndex">1</int>
				</Properties>
			</Item>
			<Item class="LocalScript" referent="RBX13">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Hide</string>
					<ProtectedString name="Source">while true do
&#9;game.Players.LocalPlayer.PlayerGui.HealthGUI.tray.Visible = false
&#9;game.Players.LocalPlayer.PlayerGui.HealthGUI.hurtOverlay.Visible = false
end</ProtectedString>
				</Properties>
			</Item>
		</Item>
		<Item class="ScreenGui" referent="RBX14">
			<Properties>
				<string name="Name">Dialogs</string>
			</Properties>
			<Item class="Frame" referent="RBX15">
				<Properties>
					<bool name="Active">false</bool>
					<Color3 name="BackgroundColor3">4288914085</Color3>
					<float name="BackgroundTransparency">1</float>
					<Color3 name="BorderColor3">4279970357</Color3>
					<int name="BorderSizePixel">1</int>
					<bool name="ClipsDescendants">false</bool>
					<bool name="Draggable">false</bool>
					<string name="Name">ControlFrame</string>
					<UDim2 name="Position">
						<XS>0</XS>
						<XO>0</XO>
						<YS>0</YS>
						<YO>0</YO>
					</UDim2>
					<UDim2 name="Size">
						<XS>1</XS>
						<XO>0</XO>
						<YS>1</YS>
						<YO>0</YO>
					</UDim2>
					<token name="SizeConstraint">0</token>
					<token name="Style">0</token>
					<bool name="Visible">true</bool>
					<int name="ZIndex">1</int>
				</Properties>
				<Item class="Frame" referent="RBX16">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<string name="Name">BottomLeftControl</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>1</YS>
							<YO>-46</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>130</XO>
							<YS>0</YS>
							<YO>46</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
				</Item>
				<Item class="NotificationBox" referent="RBX17">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<string name="Name">NotificationBox</string>
						<UDim2 name="Position">
							<XS>1</XS>
							<XO>-200</XO>
							<YS>0.5</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>200</XO>
							<YS>0.419999987</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
				</Item>
			</Item>
			<Item class="LocalScript" referent="RBX18">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Init</string>
					<ProtectedString name="Source">--rbxsig%XeVmMtUuu+dXh8pEbcaTkr2m9RJZXY42LaACJ12YYcuPtOUxy4Azi8uMDGU8ZTh7cvZC9BlOWgqmZHKjESSdfOZl0/cgd2JKHPZ2UqiqA1slJa7R5GtCcGXlNPHW8KDYgJGRuwe8h5CSiMDOl6QLTSEegTOG7fzHk/n1AFcRN8I=%
--rbxassetid%39250920%
--fixed by Carrot#0559

function waitForProperty(instance, name)
&#9;while not instance[name] do
&#9;&#9;instance.Changed:wait()
&#9;end
end

local beter = game.Lighting

function waitForDialogChildrenMyLord(beter, name)
&#9;&#9;while not beter:FindFirstChild(name) do
&#9;&#9;&#9;beter.ChildAdded:wait()
&#9;&#9;end
end

local bois = game.Players.LocalPlayer.PlayerGui

function waitForFaker(bois, name)
&#9;&#9;while not bois:FindFirstChild(name) do
&#9;&#9;&#9;bois.ChildAdded:wait()
&#9;&#9;end
end


local mainFrame
local choices = {}
local lastChoice
local choiceMap = {}
local currentConversationDialog
local currentConversationPartner
local currentAbortDialogScript

local tooFarAwayMessage =           &quot;You are too far away to chat!&quot;
local tooFarAwaySize = 300
local characterWanderedOffMessage = &quot;Chat ended because you walked away&quot;
local characterWanderedOffSize = 350
local conversationTimedOut =        &quot;Chat ended because you didn&apos;t reply&quot;
local conversationTimedOutSize = 350

local player
local screenGui
local chatNotificationGui
local messageDialog
local timeoutScript = game.Lighting.ReenableDialogScript
local reenableDialogScript = game.Lighting.TimeoutScript
local dialogMap = {}
local dialogConnections = {}

local gui = nil
--waitForDialogChildrenMyLord(game,&quot;CoreGui&quot;)
--waitForDialogChildrenMyLord(game.CoreGui,&quot;RobloxGui&quot;)
--if game.CoreGui.RobloxGui:FindFirstChild(&quot;ControlFrame&quot;) then
--&#9;gui = game.CoreGui.RobloxGui.ControlFrame
--else
--&#9;gui = game.CoreGui.RobloxGui
--end

function currentTone()
&#9;if currentConversationDialog then
&#9;&#9;return currentConversationDialog.Tone
&#9;else
&#9;&#9;return Enum.DialogTone.Neutral
&#9;end
end
&#9;

function createChatNotificationGui()
&#9;chatNotificationGui = Instance.new(&quot;BillboardGui&quot;)
&#9;chatNotificationGui.Name = &quot;ChatNotificationGui&quot;
&#9;chatNotificationGui.ExtentsOffset = Vector3.new(0,1,0)
&#9;chatNotificationGui.Size = UDim2.new(4, 0, 5.42857122, 0)
&#9;chatNotificationGui.SizeOffset = Vector2.new(0,0)
&#9;chatNotificationGui.StudsOffset = Vector3.new(0.4, 4.3, 0)
&#9;chatNotificationGui.Enabled = true
&#9;chatNotificationGui.Active = true

&#9;local image = Instance.new(&quot;ImageLabel&quot;)
&#9;image.Name = &quot;Image&quot;
&#9;image.Active = false
&#9;image.BackgroundTransparency = 1
&#9;image.Position = UDim2.new(0,0,0,0)
&#9;image.Size = UDim2.new(1.0,0,1.0,0)
&#9;image.Image = &quot;&quot;
&#9;image.Parent = chatNotificationGui
   

&#9;local button = Instance.new(&quot;ImageButton&quot;)
&#9;button.Name = &quot;Button&quot;
&#9;button.AutoButtonColor = false
&#9;button.Position = UDim2.new(0.0879999995, 0, 0.0529999994, 0)
&#9;button.Size = UDim2.new(0.829999983, 0, 0.460000008, 0)
&#9;button.Image = &quot;&quot;
&#9;button.BackgroundTransparency = 1
&#9;button.Parent = image
end

function getChatColor(tone)
&#9;if tone == Enum.DialogTone.Neutral then
&#9;&#9;return Enum.ChatColor.Blue
&#9;elseif tone == Enum.DialogTone.Friendly then
&#9;&#9;return Enum.ChatColor.Green
&#9;elseif tone == Enum.DialogTone.Enemy then
&#9;&#9;return Enum.ChatColor.Red
&#9;end
end

function styleChoices(tone)
&#9;for i, obj in pairs(choices) do
&#9;&#9;resetColor(obj, tone)
&#9;end
&#9;resetColor(lastChoice, tone)
end

function styleMainFrame(tone)
&#9;if tone == Enum.DialogTone.Neutral then
&#9;&#9;mainFrame.Style = Enum.FrameStyle.ChatBlue
&#9;&#9;mainFrame.Tail.Image = &quot;rbxasset://textures/chatBubble_botBlue_tailRight.png&quot;
&#9;elseif tone == Enum.DialogTone.Friendly then
&#9;&#9;mainFrame.Style = Enum.FrameStyle.ChatGreen
&#9;&#9;mainFrame.Tail.Image = &quot;rbxasset://textures/chatBubble_botGreen_tailRight.png&quot;
&#9;elseif tone == Enum.DialogTone.Enemy then
&#9;&#9;mainFrame.Style = Enum.FrameStyle.ChatRed
&#9;&#9;mainFrame.Tail.Image = &quot;rbxasset://textures/chatBubble_botRed_tailRight.png&quot;
&#9;end
&#9;
&#9;styleChoices(tone)
end
function setChatNotificationTone(gui, purpose, tone)
&#9;if tone == Enum.DialogTone.Neutral then
&#9;&#9;gui.Image.Image = &quot;rbxasset://textures/chatBubble_botBlue_notify_bkg.png&quot;
&#9;elseif tone == Enum.DialogTone.Friendly then
&#9;&#9;gui.Image.Image = &quot;rbxasset://textures/chatBubble_botGreen_notify_bkg.png&quot;
&#9;elseif tone == Enum.DialogTone.Enemy then
&#9;&#9;gui.Image.Image = &quot;rbxasset://textures/chatBubble_botRed_notify_bkg.png&quot;
&#9;end
&#9;if purpose == Enum.DialogPurpose.Quest then
&#9;&#9;gui.Image.Button.Image = &quot;rbxasset://textures/chatBubble_bot_notify_bang.png&quot;
&#9;elseif purpose == Enum.DialogPurpose.Help then
&#9;&#9;gui.Image.Button.Image = &quot;rbxasset://textures/chatBubble_bot_notify_question.png&quot;
&#9;elseif purpose == Enum.DialogPurpose.Shop then
&#9;&#9;gui.Image.Button.Image = &quot;rbxasset://textures/chatBubble_bot_notify_money.png&quot;
&#9;end
end

function createMessageDialog()
&#9;messageDialog = Instance.new(&quot;Frame&quot;);
&#9;messageDialog.Name = &quot;DialogScriptMessage&quot;
&#9;messageDialog.Style = Enum.FrameStyle.RobloxRound
&#9;messageDialog.Visible = false

&#9;local text = Instance.new(&quot;TextLabel&quot;)
&#9;text.Name = &quot;Text&quot;
&#9;text.Position = UDim2.new(0,0,0,-1)
&#9;text.Size = UDim2.new(1,0,1,0)
&#9;text.FontSize = Enum.FontSize.Size14
&#9;text.BackgroundTransparency = 1
&#9;text.TextColor3 = Color3.new(1,1,1)
&#9;text.Parent = messageDialog
end

function showMessage(msg, size)
&#9;messageDialog.Text.Text = msg
&#9;messageDialog.Size = UDim2.new(0,size,0,40)
&#9;messageDialog.Position = UDim2.new(0.5, -size/2, 0.5, -40)
&#9;messageDialog.Visible = true
&#9;wait(2)
&#9;messageDialog.Visible = false
end

function variableDelay(str)
&#9;local length = math.min(string.len(str), 100)
&#9;wait(0.75 + ((length/75) * 1.5))
end

function resetColor(frame, tone)
&#9;if tone == Enum.DialogTone.Neutral then
&#9;&#9;frame.BackgroundColor3 = Color3.new(0/255, 0/255,   179/255) 
&#9;&#9;frame.Number.TextColor3 = Color3.new(45/255, 142/255, 245/255) 
&#9;elseif tone == Enum.DialogTone.Friendly then
&#9;&#9;frame.BackgroundColor3 = Color3.new(0/255, 77/255,   0/255) 
&#9;&#9;frame.Number.TextColor3 = Color3.new(0/255, 190/255, 0/255) 
&#9;elseif tone == Enum.DialogTone.Enemy then
&#9;&#9;frame.BackgroundColor3 = Color3.new(140/255, 0/255, 0/255) 
&#9;&#9;frame.Number.TextColor3 = Color3.new(255/255,88/255, 79/255) 
&#9;end
end

function highlightColor(frame, tone)
&#9;if tone == Enum.DialogTone.Neutral then
&#9;&#9;frame.BackgroundColor3 = Color3.new(2/255, 108/255,   255/255) 
&#9;&#9;frame.Number.TextColor3 = Color3.new(1, 1, 1) 
&#9;elseif tone == Enum.DialogTone.Friendly then
&#9;&#9;frame.BackgroundColor3 = Color3.new(0/255, 128/255,   0/255) 
&#9;&#9;frame.Number.TextColor3 = Color3.new(1, 1, 1) 
&#9;elseif tone == Enum.DialogTone.Enemy then
&#9;&#9;frame.BackgroundColor3 = Color3.new(204/255, 0/255, 0/255) 
&#9;&#9;frame.Number.TextColor3 = Color3.new(1, 1, 1) 
&#9;end
end

function wanderDialog()
&#9;print(&quot;Wander&quot;)
&#9;mainFrame.Visible = false
&#9;endDialog()
&#9;showMessage(characterWanderedOffMessage, characterWanderedOffSize)
end

function timeoutDialog()
&#9;print(&quot;Timeout&quot;)
&#9;mainFrame.Visible = false
&#9;endDialog()
&#9;showMessage(conversationTimedOut, conversationTimedOutSize)
end
function normalEndDialog()
&#9;print(&quot;Done&quot;)
&#9;endDialog()
end

function endDialog()
   if currentAbortDialogScript then
&#9;&#9;currentAbortDialogScript:Remove()
&#9;&#9;currentAbortDialogScript = nil
&#9;end

&#9;local dialog = currentConversationDialog 
&#9;currentConversationDialog = nil
&#9;if dialog and dialog.InUse then
&#9;&#9;local reenableScript = reenableDialogScript:Clone()
&#9;&#9;reenableScript.archivable = false
&#9;&#9;reenableScript.Disabled = false
&#9;&#9;reenableScript.Parent = dialog
&#9;end

&#9;for dialog, gui in pairs(dialogMap) do
&#9;&#9;if dialog and gui then
&#9;&#9;&#9;gui.Enabled = not dialog.InUse
&#9;&#9;end
&#9;end

&#9;currentConversationPartner = nil
end

function sanitizeMessage(msg)
  if string.len(msg) == 0 then
     return &quot;...&quot;
  else
     return msg
  end
end

function selectChoice(choice)
&#9;renewKillswitch(currentConversationDialog)

&#9;--First hide the Gui
&#9;mainFrame.Visible = false
&#9;if choice == lastChoice then
&#9;&#9;game.Chat:Chat(game.Players.LocalPlayer.Character, &quot;Goodbye!&quot;, getChatColor(currentTone()))
&#9;&#9;
&#9;&#9;normalEndDialog()
&#9;else 
&#9;&#9;local dialogChoice = choiceMap[choice]

&#9;&#9;game.Chat:Chat(game.Players.LocalPlayer.Character, sanitizeMessage(dialogChoice.UserDialog), getChatColor(currentTone()))
&#9;&#9;wait(1)
&#9;&#9;--currentConversationDialog:SignalDialogChoiceSelected(player, dialogChoice)
&#9;&#9;game.Chat:Chat(currentConversationPartner, sanitizeMessage(dialogChoice.ResponseDialog), getChatColor(currentTone()))
&#9;
&#9;&#9;variableDelay(dialogChoice.ResponseDialog)
&#9;&#9;presentDialogChoices(currentConversationPartner, dialogChoice:GetChildren())
&#9;end 
end

function newChoice(numberText)
&#9;local frame = Instance.new(&quot;TextButton&quot;)
&#9;frame.BackgroundColor3 = Color3.new(0/255, 0/255, 179/255)
&#9;frame.AutoButtonColor = false
&#9;frame.BorderSizePixel = 0
&#9;frame.Text = &quot;&quot;
&#9;frame.MouseEnter:connect(function() highlightColor(frame, currentTone()) end)
&#9;frame.MouseLeave:connect(function() resetColor(frame, currentTone()) end)
&#9;frame.MouseButton1Click:connect(function() selectChoice(frame) end)

&#9;local number = Instance.new(&quot;TextLabel&quot;)
&#9;number.Name = &quot;Number&quot;
&#9;number.TextColor3 = Color3.new(127/255, 212/255, 255/255)
&#9;number.Text = numberText
&#9;number.FontSize = Enum.FontSize.Size14
&#9;number.BackgroundTransparency = 1
&#9;number.Position = UDim2.new(0,4,0,2)
&#9;number.Size = UDim2.new(0,20,0,24)
&#9;number.TextXAlignment = Enum.TextXAlignment.Left
&#9;number.TextYAlignment = Enum.TextYAlignment.Top
&#9;number.Parent = frame

&#9;local prompt = Instance.new(&quot;TextLabel&quot;)
&#9;prompt.Name = &quot;UserPrompt&quot;
&#9;prompt.BackgroundTransparency = 1
&#9;prompt.TextColor3 = Color3.new(1,1,1)
&#9;prompt.FontSize = Enum.FontSize.Size14
&#9;prompt.Position = UDim2.new(0,28, 0, 2)
&#9;prompt.Size = UDim2.new(1,-32, 1, -4)
&#9;prompt.TextXAlignment = Enum.TextXAlignment.Left
&#9;prompt.TextYAlignment = Enum.TextYAlignment.Top
&#9;prompt.TextWrap = true
&#9;prompt.Parent = frame

&#9;return frame
end
function initialize(parent)
&#9;choices[1] = newChoice(&quot;1)&quot;)
&#9;choices[2] = newChoice(&quot;2)&quot;)
&#9;choices[3] = newChoice(&quot;3)&quot;)
&#9;choices[4] = newChoice(&quot;4)&quot;)

&#9;lastChoice = newChoice(&quot;5)&quot;)
&#9;lastChoice.UserPrompt.Text = &quot;Goodbye!&quot;
&#9;lastChoice.Size = UDim2.new(1,0,0,28)

&#9;mainFrame = Instance.new(&quot;Frame&quot;)
&#9;mainFrame.Name = &quot;UserDialogArea&quot;
&#9;mainFrame.Size = UDim2.new(0, 350, 0, 200)
&#9;mainFrame.Style = Enum.FrameStyle.ChatBlue
&#9;mainFrame.Visible = false
&#9;
&#9;local imageLabel = Instance.new(&quot;ImageLabel&quot;)
&#9;imageLabel.Name = &quot;Tail&quot;
&#9;imageLabel.Size = UDim2.new(0,62,0,53)
&#9;imageLabel.Position = UDim2.new(1,8,0.25)
&#9;imageLabel.Image = &quot;rbxasset://textures/chatBubble_botBlue_tailRight.png&quot;
&#9;imageLabel.BackgroundTransparency = 1
&#9;imageLabel.Parent = mainFrame
&#9;&#9;
&#9;for n, obj in pairs(choices) do
&#9;&#9;obj.Parent = mainFrame
&#9;end
&#9;lastChoice.Parent = mainFrame

&#9;mainFrame.Parent = parent
end

function presentDialogChoices(talkingPart, dialogChoices)
&#9;if not currentConversationDialog then 
&#9;&#9;return 
&#9;end

&#9;currentConversationPartner = talkingPart
&#9;local sortedDialogChoices = {}
&#9;for n, obj in pairs(dialogChoices) do
&#9;&#9;if obj:IsA(&quot;DialogChoice&quot;) then
&#9;&#9;&#9;table.insert(sortedDialogChoices, obj)
&#9;&#9;end
&#9;end
&#9;table.sort(sortedDialogChoices, function(a,b) return a.Name &lt; b.Name end)

&#9;if #sortedDialogChoices == 0 then
&#9;&#9;normalEndDialog()
&#9;&#9;return
&#9;end

&#9;local pos = 1
   local yPosition = 0
&#9;choiceMap = {}
&#9;for n, obj in pairs(choices) do
&#9;&#9;obj.Visible = false
&#9;end

&#9;for n, obj in pairs(sortedDialogChoices) do
&#9;&#9;if pos &lt;= #choices then
&#9;&#9;&#9;--3 lines is the maximum, set it to that temporarily
&#9;&#9;&#9;choices[pos].Size = UDim2.new(1, 0, 0, 24*3)
&#9;&#9;&#9;choices[pos].UserPrompt.Text = obj.UserDialog
&#9;&#9;&#9;local height = math.ceil(choices[pos].UserPrompt.TextBounds.Y/24)*24

&#9;&#9;&#9;choices[pos].Position = UDim2.new(0, 0, 0, yPosition)
&#9;&#9;&#9;choices[pos].Size = UDim2.new(1, 0, 0, height)
&#9;&#9;&#9;choices[pos].Visible = true
&#9;&#9;
&#9;&#9;&#9;choiceMap[choices[pos]] = obj

&#9;&#9;&#9;yPosition = yPosition + height
&#9;&#9;&#9;pos = pos + 1
&#9;&#9;end
&#9;end

&#9;lastChoice.Position = UDim2.new(0,0,0,yPosition)&#9;
&#9;lastChoice.Number.Text = pos .. &quot;)&quot;

&#9;mainFrame.Size = UDim2.new(0, 350, 0, yPosition+24+32)
&#9;mainFrame.Position = UDim2.new(0,20,0.0, -mainFrame.Size.Y.Offset-20)
&#9;styleMainFrame(currentTone())
&#9;mainFrame.Visible = true
end

function doDialog(dialog)
&#9;while not Instance.Lock(dialog, player) do
&#9;&#9;wait()
&#9;end

&#9;if dialog.InUse then
&#9;&#9;Instance.Unlock(dialog)
&#9;&#9;return &#9;&#9;&#9;
&#9;else
&#9;&#9;dialog.InUse = true
&#9;&#9;Instance.Unlock(dialog)
&#9;end

&#9;currentConversationDialog = dialog
&#9;game.Chat:Chat(dialog.Parent, dialog.InitialPrompt, getChatColor(dialog.Tone))
&#9;variableDelay(dialog.InitialPrompt)

&#9;presentDialogChoices(dialog.Parent, dialog:GetChildren())
end

function renewKillswitch(dialog)
&#9;if currentAbortDialogScript then
&#9;&#9;currentAbortDialogScript:Remove()
&#9;&#9;currentAbortDialogScript = nil
&#9;end

&#9;currentAbortDialogScript = timeoutScript:Clone()
&#9;currentAbortDialogScript.archivable = false
&#9;currentAbortDialogScript.Disabled = false
&#9;currentAbortDialogScript.Parent = dialog
end

function checkForLeaveArea()
&#9;while currentConversationDialog do
&#9;&#9;if currentConversationDialog.Parent and (player:DistanceFromCharacter(currentConversationDialog.Parent.Position) &gt;= currentConversationDialog.ConversationDistance) then
&#9;&#9;&#9;wanderDialog()
&#9;&#9;end
&#9;&#9;wait(1)&#9;&#9;
&#9;end
end

function startDialog(dialog)
&#9;if dialog.Parent and dialog.Parent:IsA(&quot;BasePart&quot;) then
&#9;&#9;if player:DistanceFromCharacter(dialog.Parent.Position) &gt;= dialog.ConversationDistance then
&#9;&#9;&#9;showMessage(tooFarAwayMessage, tooFarAwaySize)
&#9;&#9;&#9;return
&#9;&#9;end&#9;
&#9;&#9;
&#9;&#9;for dialog, gui in pairs(dialogMap) do
&#9;&#9;&#9;if dialog and gui then
&#9;&#9;&#9;&#9;gui.Enabled = false
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;renewKillswitch(dialog)

&#9;&#9;delay(1, checkForLeaveArea)
&#9;&#9;doDialog(dialog)
&#9;end
end

function removeDialog(dialog)
   if dialogMap[dialog] then
      dialogMap[dialog]:Remove()
      dialogMap[dialog] = nil
   end
&#9;if dialogConnections[dialog] then
&#9;&#9;dialogConnections[dialog]:disconnect()
&#9;&#9;dialogConnections[dialog] = nil
&#9;end
end&#9;

function addDialog(dialog)
&#9;if dialog.Parent then
&#9;&#9;if dialog.Parent:IsA(&quot;BasePart&quot;) then
&#9;&#9;&#9;local chatGui = chatNotificationGui:clone()
&#9;&#9;&#9;chatGui.Enabled = not dialog.InUse&#9;&#9;
&#9;&#9;&#9;chatGui.Adornee = dialog.Parent
&#9;&#9;&#9;chatGui.Parent = game.Players.LocalPlayer.PlayerGui
&#9;&#9;&#9;chatGui.Image.Button.MouseButton1Click:connect(function() startDialog(dialog) end)
&#9;&#9;&#9;setChatNotificationTone(chatGui, dialog.Purpose, dialog.Tone)
&#9;&#9;&#9;
&#9;&#9;&#9;dialogMap[dialog] = chatGui

&#9;&#9;&#9;dialogConnections[dialog] = dialog.Changed:connect(function(prop)
&#9;&#9;&#9;&#9;if prop == &quot;Parent&quot; and dialog.Parent then 
&#9;&#9;&#9;&#9;&#9;--This handles the reparenting case, seperate from removal case
&#9;&#9;&#9;&#9;&#9;removeDialog(dialog) 
&#9;&#9;&#9;&#9;&#9;addDialog(dialog) 
&#9;&#9;&#9;&#9;elseif prop == &quot;InUse&quot; then
&#9;&#9;&#9;&#9;&#9;chatGui.Enabled = not currentConversationDialog and not dialog.InUse
&#9;&#9;&#9;&#9;&#9;if dialog == currentConversationDialog then
&#9;&#9;&#9;&#9;&#9;&#9;timeoutDialog()
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;elseif prop == &quot;Tone&quot; or prop == &quot;Purpose&quot; then
&#9;&#9;&#9;&#9;&#9;setChatNotificationTone(chatGui, dialog.Purpose, dialog.Tone)
&#9;&#9;&#9;&#9;end 
&#9;&#9;&#9;end)
&#9;&#9;else -- still need to listen to parent changes even if current parent is not a BasePart
&#9;&#9;&#9;dialogConnections[dialog] = dialog.Changed:connect(function(prop)
&#9;&#9;&#9;&#9;if prop == &quot;Parent&quot; and dialog.Parent then 
&#9;&#9;&#9;&#9;&#9;--This handles the reparenting case, seperate from removal case
&#9;&#9;&#9;&#9;&#9;removeDialog(dialog) 
&#9;&#9;&#9;&#9;&#9;addDialog(dialog) 
&#9;&#9;&#9;&#9;end 
&#9;&#9;&#9;end)
&#9;&#9;end
&#9;end
end


--[[function fetchScripts()
&#9;local model = game:GetService(&quot;InsertService&quot;):LoadAsset(39226062)
    if type(model) == &quot;string&quot; then -- load failed, lets try again
&#9;&#9;wait(0.1)
&#9;&#9;model = game:GetService(&quot;InsertService&quot;):LoadAsset(39226062)
&#9;end
&#9;if type(model) == &quot;string&quot; then -- not going to work, lets bail
&#9;&#9;return
&#9;end
&#9;
&#9;waitForDialogChildrenMyLord(model,&quot;TimeoutScript&quot;)
&#9;timeoutScript = model.TimeoutScript
&#9;waitForDialogChildrenMyLord(model,&quot;ReenableDialogScript&quot;)
&#9;reenableDialogScript = model.ReenableDialogScript
end
]]--

function onLoad()
  waitForProperty(game.Players, &quot;LocalPlayer&quot;)
  player = game.Players.LocalPlayer
  waitForProperty(player, &quot;Character&quot;)

  --print(&quot;Fetching Scripts&quot;)
  --fetchScripts()

  --print(&quot;Creating Guis&quot;)
  createChatNotificationGui()

  waitForFaker(bois,&quot;Dialogs&quot;)
  --print(&quot;Creating MessageDialog&quot;)
  createMessageDialog()
  messageDialog.Parent = game.Players.LocalPlayer.PlayerGui.Dialogs
  
  
  --print(&quot;Initializing Frame&quot;)
  local frame = Instance.new(&quot;Frame&quot;)
  frame.Name = &quot;DialogFrame&quot;
  frame.Position = UDim2.new(0,0,0,0)
  frame.Size = UDim2.new(0,0,0,0)
  frame.BackgroundTransparency = 1
  frame.Parent = game.Players.LocalPlayer.PlayerGui.Dialogs.ControlFrame.BottomLeftControl
  initialize(frame)

  --print(&quot;Adding Dialogs&quot;)
  game.CollectionService.ItemAdded:connect(function(obj) if obj:IsA(&quot;Dialog&quot;) then addDialog(obj) end end)
  game.CollectionService.ItemRemoved:connect(function(obj) if obj:IsA(&quot;Dialog&quot;) then removeDialog(obj) end end)
  for i, obj in pairs(game.CollectionService:GetCollection(&quot;Dialog&quot;)) do
    if obj:IsA(&quot;Dialog&quot;) then
       addDialog(obj)
    end
  end
end

onLoad()</ProtectedString>
				</Properties>
			</Item>
		</Item>
		<Item class="ScreenGui" referent="RBX19">
			<Properties>
				<string name="Name">Playerlist</string>
			</Properties>
			<Item class="LocalScript" referent="RBX20">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Init</string>
					<ProtectedString name="Source">--fixed by Carrot#0559
--for non corescript use
local t = {}

local function ScopedConnect(parentInstance, instance, event, signalFunc, syncFunc, removeFunc)
&#9;local eventConnection = nil

&#9;--Connection on parentInstance is scoped by parentInstance (when destroyed, it goes away)
&#9;local tryConnect = function()
&#9;&#9;if game:IsAncestorOf(parentInstance) then
&#9;&#9;&#9;--Entering the world, make sure we are connected/synced
&#9;&#9;&#9;if not eventConnection then
&#9;&#9;&#9;&#9;eventConnection = instance[event]:connect(signalFunc)
&#9;&#9;&#9;&#9;if syncFunc then syncFunc() end
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;--Probably leaving the world, so disconnect for now
&#9;&#9;&#9;if eventConnection then
&#9;&#9;&#9;&#9;eventConnection:disconnect()
&#9;&#9;&#9;&#9;if removeFunc then removeFunc() end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;--Hook it up to ancestryChanged signal
&#9;local connection = parentInstance.AncestryChanged:connect(tryConnect)
&#9;
&#9;--Now connect us if we&apos;re already in the world
&#9;tryConnect()
&#9;
&#9;return connection
end

local function getScreenGuiAncestor(instance)
&#9;local localInstance = instance
&#9;while localInstance and not localInstance:IsA(&quot;ScreenGui&quot;) do
&#9;&#9;localInstance = localInstance.Parent
&#9;end
&#9;return localInstance
end

local function CreateButtons(frame, buttons, yPos, ySize)
&#9;local buttonNum = 1
&#9;local buttonObjs = {}
&#9;for i, obj in ipairs(buttons) do 
&#9;&#9;local button = Instance.new(&quot;TextButton&quot;)
&#9;&#9;button.Name = &quot;Button&quot; .. buttonNum
&#9;&#9;button.Font = Enum.Font.Arial
&#9;&#9;button.FontSize = Enum.FontSize.Size18
&#9;&#9;button.AutoButtonColor = true
&#9;&#9;button.Modal = true
&#9;&#9;if obj[&quot;Style&quot;] then
&#9;&#9;&#9;button.Style = obj.Style
&#9;&#9;else
&#9;&#9;&#9;button.Style = Enum.ButtonStyle.RobloxButton
&#9;&#9;end
&#9;&#9;if obj[&quot;ZIndex&quot;] then
&#9;&#9;&#9;button.ZIndex = obj.ZIndex
&#9;&#9;end
&#9;&#9;button.Text = obj.Text
&#9;&#9;button.TextColor3 = Color3.new(1,1,1)
&#9;&#9;button.MouseButton1Click:connect(obj.Function)
&#9;&#9;button.Parent = frame
&#9;&#9;buttonObjs[buttonNum] = button

&#9;&#9;buttonNum = buttonNum + 1
&#9;end
&#9;local numButtons = buttonNum-1

&#9;if numButtons == 1 then
&#9;&#9;frame.Button1.Position = UDim2.new(0.35, 0, yPos.Scale, yPos.Offset)
&#9;&#9;frame.Button1.Size = UDim2.new(.4,0,ySize.Scale, ySize.Offset)
&#9;elseif numButtons == 2 then
&#9;&#9;frame.Button1.Position = UDim2.new(0.1, 0, yPos.Scale, yPos.Offset)
&#9;&#9;frame.Button1.Size = UDim2.new(.8/3,0, ySize.Scale, ySize.Offset)

&#9;&#9;frame.Button2.Position = UDim2.new(0.55, 0, yPos.Scale, yPos.Offset)
&#9;&#9;frame.Button2.Size = UDim2.new(.35,0, ySize.Scale, ySize.Offset)
&#9;elseif numButtons &gt;= 3 then
&#9;&#9;local spacing = .1 / numButtons
&#9;&#9;local buttonSize = .9 / numButtons

&#9;&#9;buttonNum = 1
&#9;&#9;while buttonNum &lt;= numButtons do
&#9;&#9;&#9;buttonObjs[buttonNum].Position = UDim2.new(spacing*buttonNum + (buttonNum-1) * buttonSize, 0, yPos.Scale, yPos.Offset)
&#9;&#9;&#9;buttonObjs[buttonNum].Size = UDim2.new(buttonSize, 0, ySize.Scale, ySize.Offset)
&#9;&#9;&#9;buttonNum = buttonNum + 1
&#9;&#9;end
&#9;end
end

local function setSliderPos(newAbsPosX,slider,sliderPosition,bar,steps)

&#9;local newStep = steps - 1 --otherwise we really get one more step than we want
&#9;local relativePosX = math.min(1, math.max(0, (newAbsPosX - bar.AbsolutePosition.X) / bar.AbsoluteSize.X ))
&#9;local wholeNum, remainder = math.modf(relativePosX * newStep)
&#9;if remainder &gt; 0.5 then
&#9;&#9;wholeNum = wholeNum + 1
&#9;end
&#9;relativePosX = wholeNum/newStep

&#9;local result = math.ceil(relativePosX * newStep)
&#9;if sliderPosition.Value ~= (result + 1) then --only update if we moved a step
&#9;&#9;sliderPosition.Value = result + 1
&#9;&#9;slider.Position = UDim2.new(relativePosX,-slider.AbsoluteSize.X/2,slider.Position.Y.Scale,slider.Position.Y.Offset)
&#9;end
&#9;
end

local function cancelSlide(areaSoak)
&#9;areaSoak.Visible = false
&#9;if areaSoakMouseMoveCon then areaSoakMouseMoveCon:disconnect() end
end

t.CreateStyledMessageDialog = function(title, message, style, buttons)
&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;frame.Size = UDim2.new(0.5, 0, 0, 165)
&#9;frame.Position = UDim2.new(0.25, 0, 0.5, -72.5)
&#9;frame.Name = &quot;MessageDialog&quot;
&#9;frame.Active = true
&#9;frame.Style = Enum.FrameStyle.RobloxRound&#9;
&#9;
&#9;local styleImage = Instance.new(&quot;ImageLabel&quot;)
&#9;styleImage.Name = &quot;StyleImage&quot;
&#9;styleImage.BackgroundTransparency = 1
&#9;styleImage.Position = UDim2.new(0,5,0,15)
&#9;if style == &quot;error&quot; or style == &quot;Error&quot; then
&#9;&#9;styleImage.Size = UDim2.new(0, 71, 0, 71)
&#9;&#9;styleImage.Image = &quot;http://www.roblox.com/asset/?id=42565285&quot;
&#9;elseif style == &quot;notify&quot; or style == &quot;Notify&quot; then
&#9;&#9;styleImage.Size = UDim2.new(0, 71, 0, 71)
&#9;&#9;styleImage.Image = &quot;http://www.roblox.com/asset/?id=42604978&quot;
&#9;elseif style == &quot;confirm&quot; or style == &quot;Confirm&quot; then
&#9;&#9;styleImage.Size = UDim2.new(0, 74, 0, 76)
&#9;&#9;styleImage.Image = &quot;http://www.roblox.com/asset/?id=42557901&quot;
&#9;else
&#9;&#9;return t.CreateMessageDialog(title,message,buttons)
&#9;end
&#9;styleImage.Parent = frame
&#9;
&#9;local titleLabel = Instance.new(&quot;TextLabel&quot;)
&#9;titleLabel.Name = &quot;Title&quot;
&#9;titleLabel.Text = title
&#9;titleLabel.TextStrokeTransparency = 0
&#9;titleLabel.BackgroundTransparency = 1
&#9;titleLabel.TextColor3 = Color3.new(221/255,221/255,221/255)
&#9;titleLabel.Position = UDim2.new(0, 80, 0, 0)
&#9;titleLabel.Size = UDim2.new(1, -80, 0, 40)
&#9;titleLabel.Font = Enum.Font.ArialBold
&#9;titleLabel.FontSize = Enum.FontSize.Size36
&#9;titleLabel.TextXAlignment = Enum.TextXAlignment.Center
&#9;titleLabel.TextYAlignment = Enum.TextYAlignment.Center
&#9;titleLabel.Parent = frame

&#9;local messageLabel = Instance.new(&quot;TextLabel&quot;)
&#9;messageLabel.Name = &quot;Message&quot;
&#9;messageLabel.Text = message
&#9;messageLabel.TextStrokeTransparency = 0
&#9;messageLabel.TextColor3 = Color3.new(221/255,221/255,221/255)
&#9;messageLabel.Position = UDim2.new(0.025, 80, 0, 45)
&#9;messageLabel.Size = UDim2.new(0.95, -80, 0, 55)
&#9;messageLabel.BackgroundTransparency = 1
&#9;messageLabel.Font = Enum.Font.Arial
&#9;messageLabel.FontSize = Enum.FontSize.Size18
&#9;messageLabel.TextWrap = true
&#9;messageLabel.TextXAlignment = Enum.TextXAlignment.Left
&#9;messageLabel.TextYAlignment = Enum.TextYAlignment.Top
&#9;messageLabel.Parent = frame

&#9;CreateButtons(frame, buttons, UDim.new(0, 105), UDim.new(0, 40) )

&#9;return frame
end

t.CreateMessageDialog = function(title, message, buttons)
&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;frame.Size = UDim2.new(0.5, 0, 0.5, 0)
&#9;frame.Position = UDim2.new(0.25, 0, 0.25, 0)
&#9;frame.Name = &quot;MessageDialog&quot;
&#9;frame.Active = true
&#9;frame.Style = Enum.FrameStyle.RobloxRound

&#9;local titleLabel = Instance.new(&quot;TextLabel&quot;)
&#9;titleLabel.Name = &quot;Title&quot;
&#9;titleLabel.Text = title
&#9;titleLabel.BackgroundTransparency = 1
&#9;titleLabel.TextColor3 = Color3.new(221/255,221/255,221/255)
&#9;titleLabel.Position = UDim2.new(0, 0, 0, 0)
&#9;titleLabel.Size = UDim2.new(1, 0, 0.15, 0)
&#9;titleLabel.Font = Enum.Font.ArialBold
&#9;titleLabel.FontSize = Enum.FontSize.Size36
&#9;titleLabel.TextXAlignment = Enum.TextXAlignment.Center
&#9;titleLabel.TextYAlignment = Enum.TextYAlignment.Center
&#9;titleLabel.Parent = frame

&#9;local messageLabel = Instance.new(&quot;TextLabel&quot;)
&#9;messageLabel.Name = &quot;Message&quot;
&#9;messageLabel.Text = message
&#9;messageLabel.TextColor3 = Color3.new(221/255,221/255,221/255)
&#9;messageLabel.Position = UDim2.new(0.025, 0, 0.175, 0)
&#9;messageLabel.Size = UDim2.new(0.95, 0, .55, 0)
&#9;messageLabel.BackgroundTransparency = 1
&#9;messageLabel.Font = Enum.Font.Arial
&#9;messageLabel.FontSize = Enum.FontSize.Size18
&#9;messageLabel.TextWrap = true
&#9;messageLabel.TextXAlignment = Enum.TextXAlignment.Left
&#9;messageLabel.TextYAlignment = Enum.TextYAlignment.Top
&#9;messageLabel.Parent = frame

&#9;CreateButtons(frame, buttons, UDim.new(0.8,0), UDim.new(0.15, 0))

&#9;return frame
end

t.CreateDropDownMenu = function(items, onSelect, forRoblox, whiteSkin, baseZ)
&#9;local baseZIndex = 0
&#9;if (type(baseZ) == &quot;number&quot;) then
&#9;&#9;baseZIndex = baseZ
&#9;end
&#9;local width = UDim.new(0, 100)
&#9;local height = UDim.new(0, 32)

&#9;local xPos = 0.055
&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;local textColor = Color3.new(1,1,1)
&#9;if (whiteSkin) then
&#9;&#9;textColor = Color3.new(0.5, 0.5, 0.5)
&#9;end
&#9;frame.Name = &quot;DropDownMenu&quot;
&#9;frame.BackgroundTransparency = 1
&#9;frame.Size = UDim2.new(width, height)

&#9;local dropDownMenu = Instance.new(&quot;TextButton&quot;)
&#9;dropDownMenu.Name = &quot;DropDownMenuButton&quot;
&#9;dropDownMenu.TextWrap = true
&#9;dropDownMenu.TextColor3 = textColor
&#9;dropDownMenu.Text = &quot;Choose One&quot;
&#9;dropDownMenu.Font = Enum.Font.ArialBold
&#9;dropDownMenu.FontSize = Enum.FontSize.Size18
&#9;dropDownMenu.TextXAlignment = Enum.TextXAlignment.Left
&#9;dropDownMenu.TextYAlignment = Enum.TextYAlignment.Center
&#9;dropDownMenu.BackgroundTransparency = 1
&#9;dropDownMenu.AutoButtonColor = true
&#9;if (whiteSkin) then
&#9;&#9;dropDownMenu.Style = Enum.ButtonStyle.RobloxRoundDropdownButton
&#9;else
&#9;&#9;dropDownMenu.Style = Enum.ButtonStyle.RobloxButton
&#9;end
&#9;dropDownMenu.Size = UDim2.new(1,0,1,0)
&#9;dropDownMenu.Parent = frame
&#9;dropDownMenu.ZIndex = 2 + baseZIndex

&#9;local dropDownIcon = Instance.new(&quot;ImageLabel&quot;)
&#9;dropDownIcon.Name = &quot;Icon&quot;
&#9;dropDownIcon.Active = false
&#9;if (whiteSkin) then
&#9;&#9;dropDownIcon.Image = &quot;rbxasset://textures/ui/dropdown_arrow.png&quot;
&#9;&#9;dropDownIcon.Size = UDim2.new(0,16,0,12)
&#9;&#9;dropDownIcon.Position = UDim2.new(1,-17,0.5, -6)
&#9;else
&#9;&#9;dropDownIcon.Image = &quot;http://www.roblox.com/asset/?id=45732894&quot;
&#9;&#9;dropDownIcon.Size = UDim2.new(0,11,0,6)
&#9;&#9;dropDownIcon.Position = UDim2.new(1,-11,0.5, -2)
&#9;end
&#9;dropDownIcon.BackgroundTransparency = 1
&#9;dropDownIcon.Parent = dropDownMenu
&#9;dropDownIcon.ZIndex = 2 + baseZIndex
&#9;
&#9;local itemCount = #items
&#9;local dropDownItemCount = #items
&#9;local useScrollButtons = false
&#9;if dropDownItemCount &gt; 6 then
&#9;&#9;useScrollButtons = true
&#9;&#9;dropDownItemCount = 6
&#9;end
&#9;
&#9;local droppedDownMenu = Instance.new(&quot;TextButton&quot;)
&#9;droppedDownMenu.Name = &quot;List&quot;
&#9;droppedDownMenu.Text = &quot;&quot;
&#9;droppedDownMenu.BackgroundTransparency = 1
&#9;--droppedDownMenu.AutoButtonColor = true
&#9;if (whiteSkin) then
&#9;&#9;droppedDownMenu.Style = Enum.ButtonStyle.RobloxRoundDropdownButton
&#9;else
&#9;&#9;droppedDownMenu.Style = Enum.ButtonStyle.RobloxButton
&#9;end
&#9;droppedDownMenu.Visible = false
&#9;droppedDownMenu.Active = true&#9;--Blocks clicks
&#9;droppedDownMenu.Position = UDim2.new(0,0,0,0)
&#9;droppedDownMenu.Size = UDim2.new(1,0, (1 + dropDownItemCount)*.8, 0)
&#9;droppedDownMenu.Parent = frame
&#9;droppedDownMenu.ZIndex = 2 + baseZIndex

&#9;local choiceButton = Instance.new(&quot;TextButton&quot;)
&#9;choiceButton.Name = &quot;ChoiceButton&quot;
&#9;choiceButton.BackgroundTransparency = 1
&#9;choiceButton.BorderSizePixel = 0
&#9;choiceButton.Text = &quot;ReplaceMe&quot;
&#9;choiceButton.TextColor3 = textColor
&#9;choiceButton.TextXAlignment = Enum.TextXAlignment.Left
&#9;choiceButton.TextYAlignment = Enum.TextYAlignment.Center
&#9;choiceButton.BackgroundColor3 = Color3.new(1, 1, 1)
&#9;choiceButton.Font = Enum.Font.Arial
&#9;choiceButton.FontSize = Enum.FontSize.Size18
&#9;if useScrollButtons then
&#9;&#9;choiceButton.Size = UDim2.new(1,-13, .8/((dropDownItemCount + 1)*.8),0) 
&#9;else
&#9;&#9;choiceButton.Size = UDim2.new(1, 0, .8/((dropDownItemCount + 1)*.8),0) 
&#9;end
&#9;choiceButton.TextWrap = true
&#9;choiceButton.ZIndex = 2 + baseZIndex

&#9;local areaSoak = Instance.new(&quot;TextButton&quot;)
&#9;areaSoak.Name = &quot;AreaSoak&quot;
&#9;areaSoak.Text = &quot;&quot;
&#9;areaSoak.BackgroundTransparency = 1
&#9;areaSoak.Active = true
&#9;areaSoak.Size = UDim2.new(1,0,1,0)
&#9;areaSoak.Visible = false
&#9;areaSoak.ZIndex = 3 + baseZIndex

&#9;local dropDownSelected = false

&#9;local scrollUpButton 
&#9;local scrollDownButton
&#9;local scrollMouseCount = 0

&#9;local setZIndex = function(baseZIndex)
&#9;&#9;droppedDownMenu.ZIndex = baseZIndex +1
&#9;&#9;if scrollUpButton then
&#9;&#9;&#9;scrollUpButton.ZIndex = baseZIndex + 3
&#9;&#9;end
&#9;&#9;if scrollDownButton then
&#9;&#9;&#9;scrollDownButton.ZIndex = baseZIndex + 3
&#9;&#9;end
&#9;&#9;
&#9;&#9;local children = droppedDownMenu:GetChildren()
&#9;&#9;if children then
&#9;&#9;&#9;for i, child in ipairs(children) do
&#9;&#9;&#9;&#9;if child.Name == &quot;ChoiceButton&quot; then
&#9;&#9;&#9;&#9;&#9;child.ZIndex = baseZIndex + 2
&#9;&#9;&#9;&#9;elseif child.Name == &quot;ClickCaptureButton&quot; then
&#9;&#9;&#9;&#9;&#9;child.ZIndex = baseZIndex
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;local scrollBarPosition = 1
&#9;local updateScroll = function()
&#9;&#9;if scrollUpButton then
&#9;&#9;&#9;scrollUpButton.Active = scrollBarPosition &gt; 1 
&#9;&#9;end
&#9;&#9;if scrollDownButton then
&#9;&#9;&#9;scrollDownButton.Active = scrollBarPosition + dropDownItemCount &lt;= itemCount 
&#9;&#9;end

&#9;&#9;local children = droppedDownMenu:GetChildren()
&#9;&#9;if not children then return end

&#9;&#9;local childNum = 1&#9;&#9;&#9;
&#9;&#9;for i, obj in ipairs(children) do
&#9;&#9;&#9;if obj.Name == &quot;ChoiceButton&quot; then
&#9;&#9;&#9;&#9;if childNum &lt; scrollBarPosition or childNum &gt;= scrollBarPosition + dropDownItemCount then
&#9;&#9;&#9;&#9;&#9;obj.Visible = false
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;obj.Position = UDim2.new(0,0,((childNum-scrollBarPosition+1)*.8)/((dropDownItemCount+1)*.8),0)
&#9;&#9;&#9;&#9;&#9;obj.Visible = true
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;obj.TextColor3 = textColor
&#9;&#9;&#9;&#9;obj.BackgroundTransparency = 1

&#9;&#9;&#9;&#9;childNum = childNum + 1
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;local toggleVisibility = function()
&#9;&#9;dropDownSelected = not dropDownSelected

&#9;&#9;areaSoak.Visible = not areaSoak.Visible
&#9;&#9;dropDownMenu.Visible = not dropDownSelected
&#9;&#9;droppedDownMenu.Visible = dropDownSelected
&#9;&#9;if dropDownSelected then
&#9;&#9;&#9;setZIndex(4 + baseZIndex)
&#9;&#9;else
&#9;&#9;&#9;setZIndex(2 + baseZIndex)
&#9;&#9;end
&#9;&#9;if useScrollButtons then
&#9;&#9;&#9;updateScroll()
&#9;&#9;end
&#9;end
&#9;droppedDownMenu.MouseButton1Click:connect(toggleVisibility)

&#9;local updateSelection = function(text)
&#9;&#9;local foundItem = false
&#9;&#9;local children = droppedDownMenu:GetChildren()
&#9;&#9;local childNum = 1
&#9;&#9;if children then
&#9;&#9;&#9;for i, obj in ipairs(children) do
&#9;&#9;&#9;&#9;if obj.Name == &quot;ChoiceButton&quot; then
&#9;&#9;&#9;&#9;&#9;if obj.Text == text then
&#9;&#9;&#9;&#9;&#9;&#9;obj.Font = Enum.Font.ArialBold
&#9;&#9;&#9;&#9;&#9;&#9;foundItem = true&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;&#9;scrollBarPosition = childNum&#9;&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;&#9;if (whiteSkin) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;obj.TextColor3 = Color3.new(90/255,142/255,233/255)
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;obj.Font = Enum.Font.Arial
&#9;&#9;&#9;&#9;&#9;&#9;if (whiteSkin) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;obj.TextColor3 = textColor
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;childNum = childNum + 1
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;if not text then
&#9;&#9;&#9;dropDownMenu.Text = &quot;Choose One&quot;
&#9;&#9;&#9;scrollBarPosition = 1
&#9;&#9;else
&#9;&#9;&#9;if not foundItem then
&#9;&#9;&#9;&#9;error(&quot;Invalid Selection Update -- &quot; .. text)
&#9;&#9;&#9;end

&#9;&#9;&#9;if scrollBarPosition + dropDownItemCount &gt; itemCount + 1 then
&#9;&#9;&#9;&#9;scrollBarPosition = itemCount - dropDownItemCount + 1
&#9;&#9;&#9;end

&#9;&#9;&#9;dropDownMenu.Text = text
&#9;&#9;end
&#9;end
&#9;
&#9;local function scrollDown()
&#9;&#9;if scrollBarPosition + dropDownItemCount &lt;= itemCount then
&#9;&#9;&#9;scrollBarPosition = scrollBarPosition + 1
&#9;&#9;&#9;updateScroll()
&#9;&#9;&#9;return true
&#9;&#9;end
&#9;&#9;return false
&#9;end
&#9;local function scrollUp()
&#9;&#9;if scrollBarPosition &gt; 1 then
&#9;&#9;&#9;scrollBarPosition = scrollBarPosition - 1
&#9;&#9;&#9;updateScroll()
&#9;&#9;&#9;return true
&#9;&#9;end
&#9;&#9;return false
&#9;end
&#9;
&#9;if useScrollButtons then
&#9;&#9;--Make some scroll buttons
&#9;&#9;scrollUpButton = Instance.new(&quot;ImageButton&quot;)
&#9;&#9;scrollUpButton.Name = &quot;ScrollUpButton&quot;
&#9;&#9;scrollUpButton.BackgroundTransparency = 1
&#9;&#9;scrollUpButton.Image = &quot;rbxasset://textures/ui/scrollbuttonUp.png&quot;
&#9;&#9;scrollUpButton.Size = UDim2.new(0,17,0,17) 
&#9;&#9;scrollUpButton.Position = UDim2.new(1,-11,(1*.8)/((dropDownItemCount+1)*.8),0)
&#9;&#9;scrollUpButton.MouseButton1Click:connect(
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;scrollMouseCount = scrollMouseCount + 1
&#9;&#9;&#9;end)
&#9;&#9;scrollUpButton.MouseLeave:connect(
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;scrollMouseCount = scrollMouseCount + 1
&#9;&#9;&#9;end)
&#9;&#9;scrollUpButton.MouseButton1Down:connect(
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;scrollMouseCount = scrollMouseCount + 1
&#9;
&#9;&#9;&#9;&#9;scrollUp()
&#9;&#9;&#9;&#9;local val = scrollMouseCount
&#9;&#9;&#9;&#9;wait(0.5)
&#9;&#9;&#9;&#9;while val == scrollMouseCount do
&#9;&#9;&#9;&#9;&#9;if scrollUp() == false then
&#9;&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;wait(0.1)
&#9;&#9;&#9;&#9;end&#9;&#9;&#9;&#9;
&#9;&#9;&#9;end)

&#9;&#9;scrollUpButton.Parent = droppedDownMenu

&#9;&#9;scrollDownButton = Instance.new(&quot;ImageButton&quot;)
&#9;&#9;scrollDownButton.Name = &quot;ScrollDownButton&quot;
&#9;&#9;scrollDownButton.BackgroundTransparency = 1
&#9;&#9;scrollDownButton.Image = &quot;rbxasset://textures/ui/scrollbuttonDown.png&quot;
&#9;&#9;scrollDownButton.Size = UDim2.new(0,17,0,17) 
&#9;&#9;scrollDownButton.Position = UDim2.new(1,-11,1,-11)
&#9;&#9;scrollDownButton.Parent = droppedDownMenu
&#9;&#9;scrollDownButton.MouseButton1Click:connect(
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;scrollMouseCount = scrollMouseCount + 1
&#9;&#9;&#9;end)
&#9;&#9;scrollDownButton.MouseLeave:connect(
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;scrollMouseCount = scrollMouseCount + 1
&#9;&#9;&#9;end)
&#9;&#9;scrollDownButton.MouseButton1Down:connect(
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;scrollMouseCount = scrollMouseCount + 1

&#9;&#9;&#9;&#9;scrollDown()
&#9;&#9;&#9;&#9;local val = scrollMouseCount
&#9;&#9;&#9;&#9;wait(0.5)
&#9;&#9;&#9;&#9;while val == scrollMouseCount do
&#9;&#9;&#9;&#9;&#9;if scrollDown() == false then
&#9;&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;wait(0.1)
&#9;&#9;&#9;&#9;end&#9;&#9;&#9;&#9;
&#9;&#9;&#9;end)&#9;

&#9;&#9;local scrollbar = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;scrollbar.Name = &quot;ScrollBar&quot;
&#9;&#9;scrollbar.Image = &quot;rbxasset://textures/ui/scrollbar.png&quot;
&#9;&#9;scrollbar.BackgroundTransparency = 1
&#9;&#9;scrollbar.Size = UDim2.new(0, 18, (dropDownItemCount*.8)/((dropDownItemCount+1)*.8), -(17) - 11 - 4)
&#9;&#9;scrollbar.Position = UDim2.new(1,-11,(1*.8)/((dropDownItemCount+1)*.8),17+2)
&#9;&#9;scrollbar.Parent = droppedDownMenu
&#9;end

&#9;for i,item in ipairs(items) do
&#9;&#9;-- needed to maintain local scope for items in event listeners below
&#9;&#9;local button = choiceButton:clone()
&#9;&#9;if forRoblox then
&#9;&#9;&#9;button.RobloxLocked = true
&#9;&#9;end&#9;&#9;
&#9;&#9;button.Text = item
&#9;&#9;button.Parent = droppedDownMenu
&#9;&#9;if (whiteSkin) then
&#9;&#9;&#9;button.TextColor3 = textColor
&#9;&#9;end

&#9;&#9;button.MouseButton1Click:connect(function()
&#9;&#9;&#9;--Remove Highlight
&#9;&#9;&#9;if (not whiteSkin) then
&#9;&#9;&#9;&#9;button.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;end
&#9;&#9;&#9;button.BackgroundTransparency = 1

&#9;&#9;&#9;updateSelection(item)
&#9;&#9;&#9;onSelect(item)

&#9;&#9;&#9;toggleVisibility()
&#9;&#9;end)
&#9;&#9;button.MouseEnter:connect(function()
&#9;&#9;&#9;--Add Highlight&#9;
&#9;&#9;&#9;if (not whiteSkin) then
&#9;&#9;&#9;&#9;button.TextColor3 = Color3.new(0,0,0)
&#9;&#9;&#9;end
&#9;&#9;&#9;button.BackgroundTransparency = 0
&#9;&#9;end)

&#9;&#9;button.MouseLeave:connect(function()
&#9;&#9;&#9;--Remove Highlight
&#9;&#9;&#9;if (not whiteSkin) then
&#9;&#9;&#9;&#9;button.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;end
&#9;&#9;&#9;button.BackgroundTransparency = 1
&#9;&#9;end)
&#9;end

&#9;--This does the initial layout of the buttons&#9;
&#9;updateScroll()
&#9;
&#9;frame.AncestryChanged:connect(function(child,parent)
&#9;&#9;if parent == nil then
&#9;&#9;&#9;areaSoak.Parent = nil
&#9;&#9;else
&#9;&#9;&#9;areaSoak.Parent = getScreenGuiAncestor(frame)
&#9;&#9;end
&#9;end)

&#9;dropDownMenu.MouseButton1Click:connect(toggleVisibility)
&#9;areaSoak.MouseButton1Click:connect(toggleVisibility)
&#9;return frame, updateSelection
end

t.CreatePropertyDropDownMenu = function(instance, property, enum)

&#9;local items = enum:GetEnumItems()
&#9;local names = {}
&#9;local nameToItem = {}
&#9;for i,obj in ipairs(items) do
&#9;&#9;names[i] = obj.Name
&#9;&#9;nameToItem[obj.Name] = obj
&#9;end

&#9;local frame
&#9;local updateSelection
&#9;frame, updateSelection = t.CreateDropDownMenu(names, function(text) instance[property] = nameToItem[text] end)

&#9;ScopedConnect(frame, instance, &quot;Changed&quot;, 
&#9;&#9;function(prop)
&#9;&#9;&#9;if prop == property then
&#9;&#9;&#9;&#9;updateSelection(instance[property].Name)
&#9;&#9;&#9;end
&#9;&#9;end,
&#9;&#9;function()
&#9;&#9;&#9;updateSelection(instance[property].Name)
&#9;&#9;end)

&#9;return frame
end

t.GetFontHeight = function(font, fontSize)
&#9;if font == nil or fontSize == nil then
&#9;&#9;error(&quot;Font and FontSize must be non-nil&quot;)
&#9;end

&#9;if font == Enum.Font.Legacy then
&#9;&#9;if fontSize == Enum.FontSize.Size8 then
&#9;&#9;&#9;return 12
&#9;&#9;elseif fontSize == Enum.FontSize.Size9 then
&#9;&#9;&#9;return 14
&#9;&#9;elseif fontSize == Enum.FontSize.Size10 then
&#9;&#9;&#9;return 15
&#9;&#9;elseif fontSize == Enum.FontSize.Size11 then
&#9;&#9;&#9;return 17
&#9;&#9;elseif fontSize == Enum.FontSize.Size12 then
&#9;&#9;&#9;return 18
&#9;&#9;elseif fontSize == Enum.FontSize.Size14 then
&#9;&#9;&#9;return 21
&#9;&#9;elseif fontSize == Enum.FontSize.Size18 then
&#9;&#9;&#9;return 27
&#9;&#9;elseif fontSize == Enum.FontSize.Size24 then
&#9;&#9;&#9;return 36
&#9;&#9;elseif fontSize == Enum.FontSize.Size36 then
&#9;&#9;&#9;return 54
&#9;&#9;elseif fontSize == Enum.FontSize.Size48 then
&#9;&#9;&#9;return 72
&#9;&#9;else
&#9;&#9;&#9;error(&quot;Unknown FontSize&quot;)
&#9;&#9;end
&#9;elseif font == Enum.Font.Arial or font == Enum.Font.ArialBold then
&#9;&#9;if fontSize == Enum.FontSize.Size8 then
&#9;&#9;&#9;return 8
&#9;&#9;elseif fontSize == Enum.FontSize.Size9 then
&#9;&#9;&#9;return 9
&#9;&#9;elseif fontSize == Enum.FontSize.Size10 then
&#9;&#9;&#9;return 10
&#9;&#9;elseif fontSize == Enum.FontSize.Size11 then
&#9;&#9;&#9;return 11
&#9;&#9;elseif fontSize == Enum.FontSize.Size12 then
&#9;&#9;&#9;return 12
&#9;&#9;elseif fontSize == Enum.FontSize.Size14 then
&#9;&#9;&#9;return 14
&#9;&#9;elseif fontSize == Enum.FontSize.Size18 then
&#9;&#9;&#9;return 18
&#9;&#9;elseif fontSize == Enum.FontSize.Size24 then
&#9;&#9;&#9;return 24
&#9;&#9;elseif fontSize == Enum.FontSize.Size36 then
&#9;&#9;&#9;return 36
&#9;&#9;elseif fontSize == Enum.FontSize.Size48 then
&#9;&#9;&#9;return 48
&#9;&#9;else
&#9;&#9;&#9;error(&quot;Unknown FontSize&quot;)
&#9;&#9;end
&#9;else
&#9;&#9;error(&quot;Unknown Font &quot; .. font)
&#9;end
end

local function layoutGuiObjectsHelper(frame, guiObjects, settingsTable)
&#9;local totalPixels = frame.AbsoluteSize.Y
&#9;local pixelsRemaining = frame.AbsoluteSize.Y
&#9;for i, child in ipairs(guiObjects) do
&#9;&#9;if child:IsA(&quot;TextLabel&quot;) or child:IsA(&quot;TextButton&quot;) then
&#9;&#9;&#9;local isLabel = child:IsA(&quot;TextLabel&quot;)
&#9;&#9;&#9;if isLabel then
&#9;&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - settingsTable[&quot;TextLabelPositionPadY&quot;]
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - settingsTable[&quot;TextButtonPositionPadY&quot;]
&#9;&#9;&#9;end
&#9;&#9;&#9;child.Position = UDim2.new(child.Position.X.Scale, child.Position.X.Offset, 0, totalPixels - pixelsRemaining)
&#9;&#9;&#9;child.Size = UDim2.new(child.Size.X.Scale, child.Size.X.Offset, 0, pixelsRemaining)

&#9;&#9;&#9;if child.TextFits and child.TextBounds.Y &lt; pixelsRemaining then
&#9;&#9;&#9;&#9;child.Visible = true
&#9;&#9;&#9;&#9;if isLabel then
&#9;&#9;&#9;&#9;&#9;child.Size = UDim2.new(child.Size.X.Scale, child.Size.X.Offset, 0, child.TextBounds.Y + settingsTable[&quot;TextLabelSizePadY&quot;])
&#9;&#9;&#9;&#9;else 
&#9;&#9;&#9;&#9;&#9;child.Size = UDim2.new(child.Size.X.Scale, child.Size.X.Offset, 0, child.TextBounds.Y + settingsTable[&quot;TextButtonSizePadY&quot;])
&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;while not child.TextFits do
&#9;&#9;&#9;&#9;&#9;child.Size = UDim2.new(child.Size.X.Scale, child.Size.X.Offset, 0, child.AbsoluteSize.Y + 1)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - child.AbsoluteSize.Y&#9;&#9;

&#9;&#9;&#9;&#9;if isLabel then
&#9;&#9;&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - settingsTable[&quot;TextLabelPositionPadY&quot;]
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - settingsTable[&quot;TextButtonPositionPadY&quot;]
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;&#9;pixelsRemaining = -1
&#9;&#9;&#9;end&#9;&#9;&#9;

&#9;&#9;else
&#9;&#9;&#9;--GuiObject
&#9;&#9;&#9;child.Position = UDim2.new(child.Position.X.Scale, child.Position.X.Offset, 0, totalPixels - pixelsRemaining)
&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - child.AbsoluteSize.Y
&#9;&#9;&#9;child.Visible = (pixelsRemaining &gt;= 0)
&#9;&#9;end
&#9;end
end

t.LayoutGuiObjects = function(frame, guiObjects, settingsTable)
&#9;if not frame:IsA(&quot;GuiObject&quot;) then
&#9;&#9;error(&quot;Frame must be a GuiObject&quot;)
&#9;end
&#9;for i, child in ipairs(guiObjects) do
&#9;&#9;if not child:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;error(&quot;All elements that are layed out must be of type GuiObject&quot;)
&#9;&#9;end
&#9;end

&#9;if not settingsTable then
&#9;&#9;settingsTable = {}
&#9;end

&#9;if not settingsTable[&quot;TextLabelSizePadY&quot;] then
&#9;&#9;settingsTable[&quot;TextLabelSizePadY&quot;] = 0
&#9;end
&#9;if not settingsTable[&quot;TextLabelPositionPadY&quot;] then
&#9;&#9;settingsTable[&quot;TextLabelPositionPadY&quot;] = 0
&#9;end
&#9;if not settingsTable[&quot;TextButtonSizePadY&quot;] then
&#9;&#9;settingsTable[&quot;TextButtonSizePadY&quot;] = 12
&#9;end
&#9;if not settingsTable[&quot;TextButtonPositionPadY&quot;] then
&#9;&#9;settingsTable[&quot;TextButtonPositionPadY&quot;] = 2
&#9;end

&#9;--Wrapper frame takes care of styled objects
&#9;local wrapperFrame = Instance.new(&quot;Frame&quot;)
&#9;wrapperFrame.Name = &quot;WrapperFrame&quot;
&#9;wrapperFrame.BackgroundTransparency = 1
&#9;wrapperFrame.Size = UDim2.new(1,0,1,0)
&#9;wrapperFrame.Parent = frame

&#9;for i, child in ipairs(guiObjects) do
&#9;&#9;child.Parent = wrapperFrame
&#9;end

&#9;local recalculate = function()
&#9;&#9;wait()
&#9;&#9;layoutGuiObjectsHelper(wrapperFrame, guiObjects, settingsTable)
&#9;end
&#9;
&#9;frame.Changed:connect(
&#9;&#9;function(prop)
&#9;&#9;&#9;if prop == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;&#9;--Wait a heartbeat for it to sync in
&#9;&#9;&#9;&#9;recalculate(nil)
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;frame.AncestryChanged:connect(recalculate)

&#9;layoutGuiObjectsHelper(wrapperFrame, guiObjects, settingsTable)
end


t.CreateSlider = function(steps,width,position)
&#9;local sliderGui = Instance.new(&quot;Frame&quot;)
&#9;sliderGui.Size = UDim2.new(1,0,1,0)
&#9;sliderGui.BackgroundTransparency = 1
&#9;sliderGui.Name = &quot;SliderGui&quot;
&#9;
&#9;local sliderSteps = Instance.new(&quot;IntValue&quot;)
&#9;sliderSteps.Name = &quot;SliderSteps&quot;
&#9;sliderSteps.Value = steps
&#9;sliderSteps.Parent = sliderGui
&#9;
&#9;local areaSoak = Instance.new(&quot;TextButton&quot;)
&#9;areaSoak.Name = &quot;AreaSoak&quot;
&#9;areaSoak.Text = &quot;&quot;
&#9;areaSoak.BackgroundTransparency = 1
&#9;areaSoak.Active = false
&#9;areaSoak.Size = UDim2.new(1,0,1,0)
&#9;areaSoak.Visible = false
&#9;areaSoak.ZIndex = 4
&#9;
&#9;sliderGui.AncestryChanged:connect(function(child,parent)
&#9;&#9;if parent == nil then
&#9;&#9;&#9;areaSoak.Parent = nil
&#9;&#9;else
&#9;&#9;&#9;areaSoak.Parent = getScreenGuiAncestor(sliderGui)
&#9;&#9;end
&#9;end)
&#9;
&#9;local sliderPosition = Instance.new(&quot;IntValue&quot;)
&#9;sliderPosition.Name = &quot;SliderPosition&quot;
&#9;sliderPosition.Value = 0
&#9;sliderPosition.Parent = sliderGui
&#9;
&#9;local id = math.random(1,100)
&#9;
&#9;local bar = Instance.new(&quot;TextButton&quot;)
&#9;bar.Text = &quot;&quot;
&#9;bar.AutoButtonColor = false
&#9;bar.Name = &quot;Bar&quot;
&#9;bar.BackgroundColor3 = Color3.new(0,0,0)
&#9;if type(width) == &quot;number&quot; then
&#9;&#9;bar.Size = UDim2.new(0,width,0,5)
&#9;else
&#9;&#9;bar.Size = UDim2.new(0,200,0,5)
&#9;end
&#9;bar.BorderColor3 = Color3.new(95/255,95/255,95/255)
&#9;bar.ZIndex = 2
&#9;bar.Parent = sliderGui
&#9;
&#9;if position[&quot;X&quot;] and position[&quot;X&quot;][&quot;Scale&quot;] and position[&quot;X&quot;][&quot;Offset&quot;] and position[&quot;Y&quot;] and position[&quot;Y&quot;][&quot;Scale&quot;] and position[&quot;Y&quot;][&quot;Offset&quot;] then
&#9;&#9;bar.Position = position
&#9;end
&#9;
&#9;local slider = Instance.new(&quot;ImageButton&quot;)
&#9;slider.Name = &quot;Slider&quot;
&#9;slider.BackgroundTransparency = 1
&#9;slider.Image = &quot;rbxasset://textures/ui/Slider.png&quot;
&#9;slider.Position = UDim2.new(0,0,0.5,-10)
&#9;slider.Size = UDim2.new(0,20,0,20)
&#9;slider.ZIndex = 3
&#9;slider.Parent = bar
&#9;
&#9;local areaSoakMouseMoveCon = nil
&#9;
&#9;areaSoak.MouseLeave:connect(function()
&#9;&#9;if areaSoak.Visible then
&#9;&#9;&#9;cancelSlide(areaSoak)
&#9;&#9;end
&#9;end)
&#9;areaSoak.MouseButton1Up:connect(function()
&#9;&#9;if areaSoak.Visible then
&#9;&#9;&#9;cancelSlide(areaSoak)
&#9;&#9;end
&#9;end)
&#9;
&#9;slider.MouseButton1Down:connect(function()
&#9;&#9;areaSoak.Visible = true
&#9;&#9;if areaSoakMouseMoveCon then areaSoakMouseMoveCon:disconnect() end
&#9;&#9;areaSoakMouseMoveCon = areaSoak.MouseMoved:connect(function(x,y)
&#9;&#9;&#9;setSliderPos(x,slider,sliderPosition,bar,steps)
&#9;&#9;end)
&#9;end)
&#9;
&#9;slider.MouseButton1Up:connect(function() cancelSlide(areaSoak) end)
&#9;
&#9;sliderPosition.Changed:connect(function(prop)
&#9;&#9;sliderPosition.Value = math.min(steps, math.max(1,sliderPosition.Value))
&#9;&#9;local relativePosX = (sliderPosition.Value - 1) / (steps - 1)
&#9;&#9;slider.Position = UDim2.new(relativePosX,-slider.AbsoluteSize.X/2,slider.Position.Y.Scale,slider.Position.Y.Offset)
&#9;end)
&#9;
&#9;bar.MouseButton1Down:connect(function(x,y)
&#9;&#9;setSliderPos(x,slider,sliderPosition,bar,steps)
&#9;end)
&#9;
&#9;return sliderGui, sliderPosition, sliderSteps

end



t.CreateSliderNew = function(steps,width,position)
&#9;local sliderGui = Instance.new(&quot;Frame&quot;)
&#9;sliderGui.Size = UDim2.new(1,0,1,0)
&#9;sliderGui.BackgroundTransparency = 1
&#9;sliderGui.Name = &quot;SliderGui&quot;
&#9;
&#9;local sliderSteps = Instance.new(&quot;IntValue&quot;)
&#9;sliderSteps.Name = &quot;SliderSteps&quot;
&#9;sliderSteps.Value = steps
&#9;sliderSteps.Parent = sliderGui
&#9;
&#9;local areaSoak = Instance.new(&quot;TextButton&quot;)
&#9;areaSoak.Name = &quot;AreaSoak&quot;
&#9;areaSoak.Text = &quot;&quot;
&#9;areaSoak.BackgroundTransparency = 1
&#9;areaSoak.Active = false
&#9;areaSoak.Size = UDim2.new(1,0,1,0)
&#9;areaSoak.Visible = false
&#9;areaSoak.ZIndex = 6
&#9;
&#9;sliderGui.AncestryChanged:connect(function(child,parent)
&#9;&#9;if parent == nil then
&#9;&#9;&#9;areaSoak.Parent = nil
&#9;&#9;else
&#9;&#9;&#9;areaSoak.Parent = getScreenGuiAncestor(sliderGui)
&#9;&#9;end
&#9;end)
&#9;
&#9;local sliderPosition = Instance.new(&quot;IntValue&quot;)
&#9;sliderPosition.Name = &quot;SliderPosition&quot;
&#9;sliderPosition.Value = 0
&#9;sliderPosition.Parent = sliderGui
&#9;
&#9;local id = math.random(1,100)
&#9;
&#9;local sliderBarImgHeight = 7
&#9;local sliderBarCapImgWidth = 4

&#9;local bar = Instance.new(&quot;ImageButton&quot;)
&#9;bar.BackgroundTransparency = 1
&#9;bar.Image = &quot;rbxasset://textures/ui/Slider-BKG-Center.png&quot;
&#9;bar.Name = &quot;Bar&quot;
&#9;local displayWidth = 200
&#9;if type(width) == &quot;number&quot; then
&#9;&#9;bar.Size = UDim2.new(0,width - (sliderBarCapImgWidth * 2),0,sliderBarImgHeight)
&#9;&#9;displayWidth = width - (sliderBarCapImgWidth * 2)
&#9;else
&#9;&#9;bar.Size = UDim2.new(0,200,0,sliderBarImgHeight)
&#9;end
&#9;bar.ZIndex = 3
&#9;bar.Parent = sliderGui&#9;
&#9;if position[&quot;X&quot;] and position[&quot;X&quot;][&quot;Scale&quot;] and position[&quot;X&quot;][&quot;Offset&quot;] and position[&quot;Y&quot;] and position[&quot;Y&quot;][&quot;Scale&quot;] and position[&quot;Y&quot;][&quot;Offset&quot;] then
&#9;&#9;bar.Position = position
&#9;end

&#9;local barLeft = bar:clone()
&#9;barLeft.Name = &quot;BarLeft&quot;
&#9;barLeft.Image = &quot;rbxasset://textures/ui/Slider-BKG-Left-Cap.png&quot;
&#9;barLeft.Size = UDim2.new(0, sliderBarCapImgWidth, 0, sliderBarImgHeight)
&#9;barLeft.Position = UDim2.new(position.X.Scale, position.X.Offset - sliderBarCapImgWidth, position.Y.Scale, position.Y.Offset)
&#9;barLeft.Parent = sliderGui&#9;
&#9;barLeft.ZIndex = 3

&#9;local barRight = barLeft:clone()
&#9;barRight.Name = &quot;BarRight&quot;
&#9;barRight.Image = &quot;rbxasset://textures/ui/Slider-BKG-Right-Cap.png&quot;
&#9;barRight.Position = UDim2.new(position.X.Scale, position.X.Offset + displayWidth, position.Y.Scale, position.Y.Offset)
&#9;barRight.Parent = sliderGui&#9;

&#9;local fillLeft = barLeft:clone()
&#9;fillLeft.Name = &quot;FillLeft&quot;
&#9;fillLeft.Image = &quot;rbxasset://textures/ui/Slider-Fill-Left-Cap.png&quot;
&#9;fillLeft.Parent = sliderGui&#9;
&#9;fillLeft.ZIndex = 4

&#9;local fill = fillLeft:clone()
&#9;fill.Name = &quot;Fill&quot;
&#9;fill.Image = &quot;rbxasset://textures/ui/Slider-Fill-Center.png&quot;
&#9;fill.Parent = bar&#9;
&#9;fill.ZIndex = 4
&#9;fill.Position = UDim2.new(0, 0, 0, 0)
&#9;fill.Size = UDim2.new(0.5, 0, 1, 0)


--&#9;bar.Visible = false

&#9;local slider = Instance.new(&quot;ImageButton&quot;)
&#9;slider.Name = &quot;Slider&quot;
&#9;slider.BackgroundTransparency = 1
&#9;slider.Image = &quot;rbxasset://textures/ui/slider_new_tab.png&quot;
&#9;slider.Position = UDim2.new(0,0,0.5,-14)
&#9;slider.Size = UDim2.new(0,28,0,28)
&#9;slider.ZIndex = 5
&#9;slider.Parent = bar
&#9;
&#9;local areaSoakMouseMoveCon = nil
&#9;
&#9;areaSoak.MouseLeave:connect(function()
&#9;&#9;if areaSoak.Visible then
&#9;&#9;&#9;cancelSlide(areaSoak)
&#9;&#9;end
&#9;end)
&#9;areaSoak.MouseButton1Up:connect(function()
&#9;&#9;if areaSoak.Visible then
&#9;&#9;&#9;cancelSlide(areaSoak)
&#9;&#9;end
&#9;end)
&#9;
&#9;slider.MouseButton1Down:connect(function()
&#9;&#9;areaSoak.Visible = true
&#9;&#9;if areaSoakMouseMoveCon then areaSoakMouseMoveCon:disconnect() end
&#9;&#9;areaSoakMouseMoveCon = areaSoak.MouseMoved:connect(function(x,y)
&#9;&#9;&#9;setSliderPos(x,slider,sliderPosition,bar,steps)
&#9;&#9;end)
&#9;end)
&#9;
&#9;slider.MouseButton1Up:connect(function() cancelSlide(areaSoak) end)
&#9;
&#9;sliderPosition.Changed:connect(function(prop)
&#9;&#9;sliderPosition.Value = math.min(steps, math.max(1,sliderPosition.Value))
&#9;&#9;local relativePosX = (sliderPosition.Value - 1) / (steps - 1)
&#9;&#9;slider.Position = UDim2.new(relativePosX,-slider.AbsoluteSize.X/2,slider.Position.Y.Scale,slider.Position.Y.Offset)
&#9;&#9;fill.Size = UDim2.new(relativePosX, 0, 1, 0)
&#9;end)
&#9;
&#9;bar.MouseButton1Down:connect(function(x,y)
&#9;&#9;setSliderPos(x,slider,sliderPosition,bar,steps)
&#9;end)

&#9;return sliderGui, sliderPosition, sliderSteps

end





t.CreateTrueScrollingFrame = function()
&#9;local lowY = nil
&#9;local highY = nil
&#9;
&#9;local dragCon = nil
&#9;local upCon = nil

&#9;local internalChange = false

&#9;local descendantsChangeConMap = {}

&#9;local scrollingFrame = Instance.new(&quot;Frame&quot;)
&#9;scrollingFrame.Name = &quot;ScrollingFrame&quot;
&#9;scrollingFrame.Active = true
&#9;scrollingFrame.Size = UDim2.new(1,0,1,0)
&#9;scrollingFrame.ClipsDescendants = true

&#9;local controlFrame = Instance.new(&quot;Frame&quot;)
&#9;controlFrame.Name = &quot;ControlFrame&quot;
&#9;controlFrame.BackgroundTransparency = 1
&#9;controlFrame.Size = UDim2.new(0,18,1,0)
&#9;controlFrame.Position = UDim2.new(1,-20,0,0)
&#9;controlFrame.Parent = scrollingFrame
&#9;
&#9;local scrollBottom = Instance.new(&quot;BoolValue&quot;)
&#9;scrollBottom.Value = false
&#9;scrollBottom.Name = &quot;ScrollBottom&quot;
&#9;scrollBottom.Parent = controlFrame
&#9;
&#9;local scrollUp = Instance.new(&quot;BoolValue&quot;)
&#9;scrollUp.Value = false
&#9;scrollUp.Name = &quot;scrollUp&quot;
&#9;scrollUp.Parent = controlFrame

&#9;local scrollUpButton = Instance.new(&quot;TextButton&quot;)
&#9;scrollUpButton.Name = &quot;ScrollUpButton&quot;
&#9;scrollUpButton.Text = &quot;&quot;
&#9;scrollUpButton.AutoButtonColor = false
&#9;scrollUpButton.BackgroundColor3 = Color3.new(0,0,0)
&#9;scrollUpButton.BorderColor3 = Color3.new(1,1,1)
&#9;scrollUpButton.BackgroundTransparency = 0.5
&#9;scrollUpButton.Size = UDim2.new(0,18,0,18)
&#9;scrollUpButton.ZIndex = 2
&#9;scrollUpButton.Parent = controlFrame
&#9;for i = 1, 6 do
&#9;&#9;local triFrame = Instance.new(&quot;Frame&quot;)
&#9;&#9;triFrame.BorderColor3 = Color3.new(1,1,1)
&#9;&#9;triFrame.Name = &quot;tri&quot; .. tostring(i)
&#9;&#9;triFrame.ZIndex = 3
&#9;&#9;triFrame.BackgroundTransparency = 0.5
&#9;&#9;triFrame.Size = UDim2.new(0,12 - ((i -1) * 2),0,0)
&#9;&#9;triFrame.Position = UDim2.new(0,3 + (i -1),0.5,2 - (i -1))
&#9;&#9;triFrame.Parent = scrollUpButton
&#9;end
&#9;scrollUpButton.MouseEnter:connect(function()
&#9;&#9;scrollUpButton.BackgroundTransparency = 0.1
&#9;&#9;local upChildren = scrollUpButton:GetChildren()
&#9;&#9;for i = 1, #upChildren do
&#9;&#9;&#9;upChildren[i].BackgroundTransparency = 0.1
&#9;&#9;end
&#9;end)
&#9;scrollUpButton.MouseLeave:connect(function()
&#9;&#9;scrollUpButton.BackgroundTransparency = 0.5
&#9;&#9;local upChildren = scrollUpButton:GetChildren()
&#9;&#9;for i = 1, #upChildren do
&#9;&#9;&#9;upChildren[i].BackgroundTransparency = 0.5
&#9;&#9;end
&#9;end)

&#9;local scrollDownButton = scrollUpButton:clone()
&#9;scrollDownButton.Name = &quot;ScrollDownButton&quot;
&#9;scrollDownButton.Position = UDim2.new(0,0,1,-18)
&#9;local downChildren = scrollDownButton:GetChildren()
&#9;for i = 1, #downChildren do
&#9;&#9;downChildren[i].Position = UDim2.new(0,3 + (i -1),0.5,-2 + (i - 1))
&#9;end
&#9;scrollDownButton.MouseEnter:connect(function()
&#9;&#9;scrollDownButton.BackgroundTransparency = 0.1
&#9;&#9;local downChildren = scrollDownButton:GetChildren()
&#9;&#9;for i = 1, #downChildren do
&#9;&#9;&#9;downChildren[i].BackgroundTransparency = 0.1
&#9;&#9;end
&#9;end)
&#9;scrollDownButton.MouseLeave:connect(function()
&#9;&#9;scrollDownButton.BackgroundTransparency = 0.5
&#9;&#9;local downChildren = scrollDownButton:GetChildren()
&#9;&#9;for i = 1, #downChildren do
&#9;&#9;&#9;downChildren[i].BackgroundTransparency = 0.5
&#9;&#9;end
&#9;end)
&#9;scrollDownButton.Parent = controlFrame
&#9;
&#9;local scrollTrack = Instance.new(&quot;Frame&quot;)
&#9;scrollTrack.Name = &quot;ScrollTrack&quot;
&#9;scrollTrack.BackgroundTransparency = 1
&#9;scrollTrack.Size = UDim2.new(0,18,1,-38)
&#9;scrollTrack.Position = UDim2.new(0,0,0,19)
&#9;scrollTrack.Parent = controlFrame

&#9;local scrollbar = Instance.new(&quot;TextButton&quot;)
&#9;scrollbar.BackgroundColor3 = Color3.new(0,0,0)
&#9;scrollbar.BorderColor3 = Color3.new(1,1,1)
&#9;scrollbar.BackgroundTransparency = 0.5
&#9;scrollbar.AutoButtonColor = false
&#9;scrollbar.Text = &quot;&quot;
&#9;scrollbar.Active = true
&#9;scrollbar.Name = &quot;ScrollBar&quot;
&#9;scrollbar.ZIndex = 2
&#9;scrollbar.BackgroundTransparency = 0.5
&#9;scrollbar.Size = UDim2.new(0, 18, 0.1, 0)
&#9;scrollbar.Position = UDim2.new(0,0,0,0)
&#9;scrollbar.Parent = scrollTrack

&#9;local scrollNub = Instance.new(&quot;Frame&quot;)
&#9;scrollNub.Name = &quot;ScrollNub&quot;
&#9;scrollNub.BorderColor3 = Color3.new(1,1,1)
&#9;scrollNub.Size = UDim2.new(0,10,0,0)
&#9;scrollNub.Position = UDim2.new(0.5,-5,0.5,0)
&#9;scrollNub.ZIndex = 2
&#9;scrollNub.BackgroundTransparency = 0.5
&#9;scrollNub.Parent = scrollbar

&#9;local newNub = scrollNub:clone()
&#9;newNub.Position = UDim2.new(0.5,-5,0.5,-2)
&#9;newNub.Parent = scrollbar
&#9;
&#9;local lastNub = scrollNub:clone()
&#9;lastNub.Position = UDim2.new(0.5,-5,0.5,2)
&#9;lastNub.Parent = scrollbar

&#9;scrollbar.MouseEnter:connect(function()
&#9;&#9;scrollbar.BackgroundTransparency = 0.1
&#9;&#9;scrollNub.BackgroundTransparency = 0.1
&#9;&#9;newNub.BackgroundTransparency = 0.1
&#9;&#9;lastNub.BackgroundTransparency = 0.1
&#9;end)
&#9;scrollbar.MouseLeave:connect(function()
&#9;&#9;scrollbar.BackgroundTransparency = 0.5
&#9;&#9;scrollNub.BackgroundTransparency = 0.5
&#9;&#9;newNub.BackgroundTransparency = 0.5
&#9;&#9;lastNub.BackgroundTransparency = 0.5
&#9;end)

&#9;local mouseDrag = Instance.new(&quot;ImageButton&quot;)
&#9;mouseDrag.Active = false
&#9;mouseDrag.Size = UDim2.new(1.5, 0, 1.5, 0)
&#9;mouseDrag.AutoButtonColor = false
&#9;mouseDrag.BackgroundTransparency = 1
&#9;mouseDrag.Name = &quot;mouseDrag&quot;
&#9;mouseDrag.Position = UDim2.new(-0.25, 0, -0.25, 0)
&#9;mouseDrag.ZIndex = 10
&#9;
&#9;local function positionScrollBar(x,y,offset)
&#9;&#9;local oldPos = scrollbar.Position

&#9;&#9;if y &lt; scrollTrack.AbsolutePosition.y then
&#9;&#9;&#9;scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,0,0)
&#9;&#9;&#9;return (oldPos ~= scrollbar.Position)
&#9;&#9;end
&#9;&#9;
&#9;&#9;local relativeSize = scrollbar.AbsoluteSize.Y/scrollTrack.AbsoluteSize.Y

&#9;&#9;if y &gt; (scrollTrack.AbsolutePosition.y + scrollTrack.AbsoluteSize.y) then
&#9;&#9;&#9;scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,1 - relativeSize,0)
&#9;&#9;&#9;return (oldPos ~= scrollbar.Position)
&#9;&#9;end
&#9;&#9;local newScaleYPos = (y - scrollTrack.AbsolutePosition.y - offset)/scrollTrack.AbsoluteSize.y
&#9;&#9;if newScaleYPos + relativeSize &gt; 1 then
&#9;&#9;&#9;newScaleYPos = 1 - relativeSize
&#9;&#9;&#9;scrollBottom.Value = true
&#9;&#9;&#9;scrollUp.Value = false
&#9;&#9;elseif newScaleYPos &lt;= 0 then
&#9;&#9;&#9;newScaleYPos = 0
&#9;&#9;&#9;scrollUp.Value = true
&#9;&#9;&#9;scrollBottom.Value = false
&#9;&#9;else
&#9;&#9;&#9;scrollUp.Value = false
&#9;&#9;&#9;scrollBottom.Value = false
&#9;&#9;end
&#9;&#9;scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,newScaleYPos,0)
&#9;&#9;
&#9;&#9;return (oldPos ~= scrollbar.Position)
&#9;end

&#9;local function drillDownSetHighLow(instance)
&#9;&#9;if not instance or not instance:IsA(&quot;GuiObject&quot;) then return end
&#9;&#9;if instance == controlFrame then return end
&#9;&#9;if instance:IsDescendantOf(controlFrame) then return end
&#9;&#9;if not instance.Visible then return end

&#9;&#9;if lowY and lowY &gt; instance.AbsolutePosition.Y then
&#9;&#9;&#9;lowY = instance.AbsolutePosition.Y
&#9;&#9;elseif not lowY then
&#9;&#9;&#9;lowY = instance.AbsolutePosition.Y
&#9;&#9;end
&#9;&#9;if highY and highY &lt; (instance.AbsolutePosition.Y + instance.AbsoluteSize.Y) then
&#9;&#9;&#9;highY = instance.AbsolutePosition.Y + instance.AbsoluteSize.Y
&#9;&#9;elseif not highY then
&#9;&#9;&#9;highY = instance.AbsolutePosition.Y + instance.AbsoluteSize.Y
&#9;&#9;end
&#9;&#9;local children = instance:GetChildren()
&#9;&#9;for i = 1, #children do
&#9;&#9;&#9;drillDownSetHighLow(children[i])
&#9;&#9;end
&#9;end

&#9;local function resetHighLow()
&#9;&#9;local firstChildren = scrollingFrame:GetChildren()

&#9;&#9;for i = 1, #firstChildren do
&#9;&#9;&#9;drillDownSetHighLow(firstChildren[i])
&#9;&#9;end
&#9;end

&#9;local function recalculate()
&#9;&#9;internalChange = true

&#9;&#9;local percentFrame = 0
&#9;&#9;if scrollbar.Position.Y.Scale &gt; 0 then
&#9;&#9;&#9;if scrollbar.Visible then
&#9;&#9;&#9;&#9;percentFrame = scrollbar.Position.Y.Scale/((scrollTrack.AbsoluteSize.Y - scrollbar.AbsoluteSize.Y)/scrollTrack.AbsoluteSize.Y)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;percentFrame = 0
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;if percentFrame &gt; 0.99 then percentFrame = 1 end

&#9;&#9;local hiddenYAmount = (scrollingFrame.AbsoluteSize.Y - (highY - lowY)) * percentFrame
&#9;&#9;
&#9;&#9;local guiChildren = scrollingFrame:GetChildren()
&#9;&#9;for i = 1, #guiChildren do
&#9;&#9;&#9;if guiChildren[i] ~= controlFrame then
&#9;&#9;&#9;&#9;guiChildren[i].Position = UDim2.new(guiChildren[i].Position.X.Scale,guiChildren[i].Position.X.Offset,
&#9;&#9;&#9;&#9;&#9;0, math.ceil(guiChildren[i].AbsolutePosition.Y) - math.ceil(lowY) + hiddenYAmount)
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;lowY = nil
&#9;&#9;highY = nil
&#9;&#9;resetHighLow()
&#9;&#9;internalChange = false
&#9;end

&#9;local function setSliderSizeAndPosition()
&#9;&#9;if not highY or not lowY then return end

&#9;&#9;local totalYSpan = math.abs(highY - lowY)
&#9;&#9;if totalYSpan == 0 then
&#9;&#9;&#9;scrollbar.Visible = false
&#9;&#9;&#9;scrollDownButton.Visible = false
&#9;&#9;&#9;scrollUpButton.Visible = false

&#9;&#9;&#9;if dragCon then dragCon:disconnect() dragCon = nil end
&#9;&#9;&#9;if upCon then upCon:disconnect() upCon = nil end
&#9;&#9;&#9;return
&#9;&#9;end

&#9;&#9;local percentShown = scrollingFrame.AbsoluteSize.Y/totalYSpan
&#9;&#9;if percentShown &gt;= 1 then
&#9;&#9;&#9;scrollbar.Visible = false
&#9;&#9;&#9;scrollDownButton.Visible = false
&#9;&#9;&#9;scrollUpButton.Visible = false
&#9;&#9;&#9;recalculate()
&#9;&#9;else
&#9;&#9;&#9;scrollbar.Visible = true
&#9;&#9;&#9;scrollDownButton.Visible = true
&#9;&#9;&#9;scrollUpButton.Visible = true

&#9;&#9;&#9;scrollbar.Size = UDim2.new(scrollbar.Size.X.Scale,scrollbar.Size.X.Offset,percentShown,0)
&#9;&#9;end

&#9;&#9;local percentPosition = (scrollingFrame.AbsolutePosition.Y - lowY)/totalYSpan
&#9;&#9;scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,percentPosition,-scrollbar.AbsoluteSize.X/2)

&#9;&#9;if scrollbar.AbsolutePosition.y &lt; scrollTrack.AbsolutePosition.y then
&#9;&#9;&#9;scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,0,0)
&#9;&#9;end

&#9;&#9;if (scrollbar.AbsolutePosition.y + scrollbar.AbsoluteSize.Y) &gt; (scrollTrack.AbsolutePosition.y + scrollTrack.AbsoluteSize.y) then
&#9;&#9;&#9;local relativeSize = scrollbar.AbsoluteSize.Y/scrollTrack.AbsoluteSize.Y
&#9;&#9;&#9;scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,1 - relativeSize,0)
&#9;&#9;end
&#9;end
&#9;
&#9;local buttonScrollAmountPixels = 7
&#9;local reentrancyGuardScrollUp = false
&#9;local function doScrollUp()
&#9;&#9;if reentrancyGuardScrollUp then return end
&#9;&#9;
&#9;&#9;reentrancyGuardScrollUp = true
&#9;&#9;&#9;if positionScrollBar(0,scrollbar.AbsolutePosition.Y - buttonScrollAmountPixels,0) then
&#9;&#9;&#9;&#9;recalculate()
&#9;&#9;&#9;end
&#9;&#9;reentrancyGuardScrollUp = false
&#9;end
&#9;
&#9;local reentrancyGuardScrollDown = false
&#9;local function doScrollDown()
&#9;&#9;if reentrancyGuardScrollDown then return end
&#9;&#9;
&#9;&#9;reentrancyGuardScrollDown = true
&#9;&#9;&#9;if positionScrollBar(0,scrollbar.AbsolutePosition.Y + buttonScrollAmountPixels,0) then
&#9;&#9;&#9;&#9;recalculate()
&#9;&#9;&#9;end
&#9;&#9;reentrancyGuardScrollDown = false
&#9;end

&#9;local function scrollUp(mouseYPos)
&#9;&#9;if scrollUpButton.Active then
&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;local current = scrollStamp
&#9;&#9;&#9;local upCon
&#9;&#9;&#9;upCon = mouseDrag.MouseButton1Up:connect(function()
&#9;&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;&#9;mouseDrag.Parent = nil
&#9;&#9;&#9;&#9;upCon:disconnect()
&#9;&#9;&#9;end)
&#9;&#9;&#9;mouseDrag.Parent = getScreenGuiAncestor(scrollbar)
&#9;&#9;&#9;doScrollUp()
&#9;&#9;&#9;wait(0.2)
&#9;&#9;&#9;local t = tick()
&#9;&#9;&#9;local w = 0.1
&#9;&#9;&#9;while scrollStamp == current do
&#9;&#9;&#9;&#9;doScrollUp()
&#9;&#9;&#9;&#9;if mouseYPos and mouseYPos &gt; scrollbar.AbsolutePosition.y then
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if not scrollUpButton.Active then break end
&#9;&#9;&#9;&#9;if tick()-t &gt; 5 then
&#9;&#9;&#9;&#9;&#9;w = 0
&#9;&#9;&#9;&#9;elseif tick()-t &gt; 2 then
&#9;&#9;&#9;&#9;&#9;w = 0.06
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;wait(w)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;local function scrollDown(mouseYPos)
&#9;&#9;if scrollDownButton.Active then
&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;local current = scrollStamp
&#9;&#9;&#9;local downCon
&#9;&#9;&#9;downCon = mouseDrag.MouseButton1Up:connect(function()
&#9;&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;&#9;mouseDrag.Parent = nil
&#9;&#9;&#9;&#9;downCon:disconnect()
&#9;&#9;&#9;end)
&#9;&#9;&#9;mouseDrag.Parent = getScreenGuiAncestor(scrollbar)
&#9;&#9;&#9;doScrollDown()
&#9;&#9;&#9;wait(0.2)
&#9;&#9;&#9;local t = tick()
&#9;&#9;&#9;local w = 0.1
&#9;&#9;&#9;while scrollStamp == current do
&#9;&#9;&#9;&#9;doScrollDown()
&#9;&#9;&#9;&#9;if mouseYPos and mouseYPos &lt; (scrollbar.AbsolutePosition.y + scrollbar.AbsoluteSize.x) then
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if not scrollDownButton.Active then break end
&#9;&#9;&#9;&#9;if tick()-t &gt; 5 then
&#9;&#9;&#9;&#9;&#9;w = 0
&#9;&#9;&#9;&#9;elseif tick()-t &gt; 2 then
&#9;&#9;&#9;&#9;&#9;w = 0.06
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;wait(w)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;scrollbar.MouseButton1Down:connect(function(x,y)
&#9;&#9;if scrollbar.Active then
&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;local mouseOffset = y - scrollbar.AbsolutePosition.y
&#9;&#9;&#9;if dragCon then dragCon:disconnect() dragCon = nil end
&#9;&#9;&#9;if upCon then upCon:disconnect() upCon = nil end
&#9;&#9;&#9;local prevY = y
&#9;&#9;&#9;local reentrancyGuardMouseScroll = false
&#9;&#9;&#9;dragCon = mouseDrag.MouseMoved:connect(function(x,y)
&#9;&#9;&#9;&#9;if reentrancyGuardMouseScroll then return end
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;reentrancyGuardMouseScroll = true
&#9;&#9;&#9;&#9;&#9;if positionScrollBar(x,y,mouseOffset) then
&#9;&#9;&#9;&#9;&#9;&#9;recalculate()
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;reentrancyGuardMouseScroll = false
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;end)
&#9;&#9;&#9;upCon = mouseDrag.MouseButton1Up:connect(function()
&#9;&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;&#9;mouseDrag.Parent = nil
&#9;&#9;&#9;&#9;dragCon:disconnect(); dragCon = nil
&#9;&#9;&#9;&#9;upCon:disconnect(); drag = nil
&#9;&#9;&#9;end)
&#9;&#9;&#9;mouseDrag.Parent = getScreenGuiAncestor(scrollbar)
&#9;&#9;end
&#9;end)

&#9;local scrollMouseCount = 0

&#9;scrollUpButton.MouseButton1Down:connect(function()
&#9;&#9;scrollUp()
&#9;end)
&#9;scrollUpButton.MouseButton1Up:connect(function()
&#9;&#9;scrollStamp = tick()
&#9;end)

&#9;scrollDownButton.MouseButton1Up:connect(function()
&#9;&#9;scrollStamp = tick()
&#9;end)
&#9;scrollDownButton.MouseButton1Down:connect(function()
&#9;&#9; scrollDown()
&#9;end)
&#9;&#9;
&#9;scrollbar.MouseButton1Up:connect(function()
&#9;&#9;scrollStamp = tick()
&#9;end)
&#9;
&#9;local function heightCheck(instance)
&#9;&#9;if highY and (instance.AbsolutePosition.Y + instance.AbsoluteSize.Y) &gt; highY then
&#9;&#9;&#9;highY = instance.AbsolutePosition.Y + instance.AbsoluteSize.Y
&#9;&#9;elseif not highY then
&#9;&#9;&#9;highY = instance.AbsolutePosition.Y + instance.AbsoluteSize.Y
&#9;&#9;end
&#9;&#9;setSliderSizeAndPosition()
&#9;end
&#9;
&#9;local function highLowRecheck()
&#9;&#9;local oldLowY = lowY
&#9;&#9;local oldHighY = highY
&#9;&#9;lowY = nil
&#9;&#9;highY = nil
&#9;&#9;resetHighLow()

&#9;&#9;if (lowY ~= oldLowY) or (highY ~= oldHighY) then
&#9;&#9;&#9;setSliderSizeAndPosition()
&#9;&#9;end
&#9;end

&#9;local function descendantChanged(this, prop)
&#9;&#9;if internalChange then return end
&#9;&#9;if not this.Visible then return end

&#9;&#9;if prop == &quot;Size&quot; or prop == &quot;Position&quot; then
&#9;&#9;&#9;wait()
&#9;&#9;&#9;highLowRecheck()
&#9;&#9;end
&#9;end

&#9;scrollingFrame.DescendantAdded:connect(function(instance)
&#9;&#9;if not instance:IsA(&quot;GuiObject&quot;) then return end

&#9;&#9;if instance.Visible then
&#9;&#9;&#9;wait() -- wait a heartbeat for sizes to reconfig
&#9;&#9;&#9;highLowRecheck()
&#9;&#9;end

&#9;&#9;descendantsChangeConMap[instance] = instance.Changed:connect(function(prop) descendantChanged(instance, prop) end)
&#9;end)

&#9;scrollingFrame.DescendantRemoving:connect(function(instance)
&#9;&#9;if not instance:IsA(&quot;GuiObject&quot;) then return end
&#9;&#9;if descendantsChangeConMap[instance] then
&#9;&#9;&#9;descendantsChangeConMap[instance]:disconnect()
&#9;&#9;&#9;descendantsChangeConMap[instance] = nil
&#9;&#9;end
&#9;&#9;wait() -- wait a heartbeat for sizes to reconfig
&#9;&#9;highLowRecheck()
&#9;end)
&#9;
&#9;scrollingFrame.Changed:connect(function(prop)
&#9;&#9;if prop == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;if not highY or not lowY then return end

&#9;&#9;&#9;highLowRecheck()
&#9;&#9;&#9;setSliderSizeAndPosition()
&#9;&#9;end
&#9;end)

&#9;return scrollingFrame, controlFrame
end

t.CreateScrollingFrame = function(orderList,scrollStyle)
&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;frame.Name = &quot;ScrollingFrame&quot;
&#9;frame.BackgroundTransparency = 1
&#9;frame.Size = UDim2.new(1,0,1,0)
&#9;
&#9;local scrollUpButton = Instance.new(&quot;ImageButton&quot;)
&#9;scrollUpButton.Name = &quot;ScrollUpButton&quot;
&#9;scrollUpButton.BackgroundTransparency = 1
&#9;scrollUpButton.Image = &quot;rbxasset://textures/ui/scrollbuttonUp.png&quot;
&#9;scrollUpButton.Size = UDim2.new(0,17,0,17) 

&#9;
&#9;local scrollDownButton = Instance.new(&quot;ImageButton&quot;)
&#9;scrollDownButton.Name = &quot;ScrollDownButton&quot;
&#9;scrollDownButton.BackgroundTransparency = 1
&#9;scrollDownButton.Image = &quot;rbxasset://textures/ui/scrollbuttonDown.png&quot;
&#9;scrollDownButton.Size = UDim2.new(0,17,0,17) 
&#9;
&#9;local scrollbar = Instance.new(&quot;ImageButton&quot;)
&#9;scrollbar.Name = &quot;ScrollBar&quot;
&#9;scrollbar.Image = &quot;rbxasset://textures/ui/scrollbar.png&quot;
&#9;scrollbar.BackgroundTransparency = 1
&#9;scrollbar.Size = UDim2.new(0, 18, 0, 150)

&#9;local scrollStamp = 0
&#9;&#9;
&#9;local scrollDrag = Instance.new(&quot;ImageButton&quot;)
&#9;scrollDrag.Image = &quot;http://www.roblox.com/asset/?id=61367186&quot;
&#9;scrollDrag.Size = UDim2.new(1, 0, 0, 16)
&#9;scrollDrag.BackgroundTransparency = 1
&#9;scrollDrag.Name = &quot;ScrollDrag&quot;
&#9;scrollDrag.Active = true
&#9;scrollDrag.Parent = scrollbar
&#9;
&#9;local mouseDrag = Instance.new(&quot;ImageButton&quot;)
&#9;mouseDrag.Active = false
&#9;mouseDrag.Size = UDim2.new(1.5, 0, 1.5, 0)
&#9;mouseDrag.AutoButtonColor = false
&#9;mouseDrag.BackgroundTransparency = 1
&#9;mouseDrag.Name = &quot;mouseDrag&quot;
&#9;mouseDrag.Position = UDim2.new(-0.25, 0, -0.25, 0)
&#9;mouseDrag.ZIndex = 10

&#9;local style = &quot;simple&quot;
&#9;if scrollStyle and tostring(scrollStyle) then
&#9;&#9;style = scrollStyle
&#9;end
&#9;
&#9;local scrollPosition = 1
&#9;local rowSize = 0
&#9;local howManyDisplayed = 0
&#9;&#9;
&#9;local layoutGridScrollBar = function()
&#9;&#9;howManyDisplayed = 0
&#9;&#9;local guiObjects = {}
&#9;&#9;if orderList then
&#9;&#9;&#9;for i, child in ipairs(orderList) do
&#9;&#9;&#9;&#9;if child.Parent == frame then
&#9;&#9;&#9;&#9;&#9;table.insert(guiObjects, child)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;local children = frame:GetChildren()
&#9;&#9;&#9;if children then
&#9;&#9;&#9;&#9;for i, child in ipairs(children) do 
&#9;&#9;&#9;&#9;&#9;if child:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;table.insert(guiObjects, child)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;if #guiObjects == 0 then
&#9;&#9;&#9;scrollUpButton.Active = false
&#9;&#9;&#9;scrollDownButton.Active = false
&#9;&#9;&#9;scrollDrag.Active = false
&#9;&#9;&#9;scrollPosition = 1
&#9;&#9;&#9;return
&#9;&#9;end

&#9;&#9;if scrollPosition &gt; #guiObjects then
&#9;&#9;&#9;scrollPosition = #guiObjects
&#9;&#9;end
&#9;&#9;
&#9;&#9;if scrollPosition &lt; 1 then scrollPosition = 1 end
&#9;&#9;
&#9;&#9;local totalPixelsY = frame.AbsoluteSize.Y
&#9;&#9;local pixelsRemainingY = frame.AbsoluteSize.Y
&#9;&#9;
&#9;&#9;local totalPixelsX  = frame.AbsoluteSize.X
&#9;&#9;
&#9;&#9;local xCounter = 0
&#9;&#9;local rowSizeCounter = 0
&#9;&#9;local setRowSize = true

&#9;&#9;local pixelsBelowScrollbar = 0
&#9;&#9;local pos = #guiObjects
&#9;&#9;
&#9;&#9;local currentRowY = 0

&#9;&#9;pos = scrollPosition
&#9;&#9;--count up from current scroll position to fill out grid
&#9;&#9;while pos &lt;= #guiObjects and pixelsBelowScrollbar &lt; totalPixelsY do
&#9;&#9;&#9;xCounter = xCounter + guiObjects[pos].AbsoluteSize.X
&#9;&#9;&#9;--previous pos was the end of a row
&#9;&#9;&#9;if xCounter &gt;= totalPixelsX then
&#9;&#9;&#9;&#9;pixelsBelowScrollbar = pixelsBelowScrollbar + currentRowY
&#9;&#9;&#9;&#9;currentRowY = 0
&#9;&#9;&#9;&#9;xCounter = guiObjects[pos].AbsoluteSize.X
&#9;&#9;&#9;end
&#9;&#9;&#9;if guiObjects[pos].AbsoluteSize.Y &gt; currentRowY then
&#9;&#9;&#9;&#9;currentRowY = guiObjects[pos].AbsoluteSize.Y
&#9;&#9;&#9;end
&#9;&#9;&#9;pos = pos + 1
&#9;&#9;end
&#9;&#9;--Count wherever current row left off
&#9;&#9;pixelsBelowScrollbar = pixelsBelowScrollbar + currentRowY
&#9;&#9;currentRowY = 0
&#9;&#9;
&#9;&#9;pos = scrollPosition - 1
&#9;&#9;xCounter = 0
&#9;&#9;
&#9;&#9;--objects with varying X,Y dimensions can rarely cause minor errors
&#9;&#9;--rechecking every new scrollPosition is necessary to avoid 100% of errors
&#9;&#9;
&#9;&#9;--count backwards from current scrollPosition to see if we can add more rows
&#9;&#9;while pixelsBelowScrollbar + currentRowY &lt; totalPixelsY and pos &gt;= 1 do
&#9;&#9;&#9;xCounter = xCounter + guiObjects[pos].AbsoluteSize.X
&#9;&#9;&#9;rowSizeCounter = rowSizeCounter + 1
&#9;&#9;&#9;if xCounter &gt;= totalPixelsX then
&#9;&#9;&#9;&#9;rowSize = rowSizeCounter - 1
&#9;&#9;&#9;&#9;rowSizeCounter = 0
&#9;&#9;&#9;&#9;xCounter = guiObjects[pos].AbsoluteSize.X
&#9;&#9;&#9;&#9;if pixelsBelowScrollbar + currentRowY &lt;= totalPixelsY then
&#9;&#9;&#9;&#9;&#9;--It fits, so back up our scroll position
&#9;&#9;&#9;&#9;&#9;pixelsBelowScrollbar = pixelsBelowScrollbar + currentRowY
&#9;&#9;&#9;&#9;&#9;if scrollPosition &lt;= rowSize then
&#9;&#9;&#9;&#9;&#9;&#9;scrollPosition = 1 
&#9;&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;scrollPosition = scrollPosition - rowSize
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;currentRowY = 0
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;if guiObjects[pos].AbsoluteSize.Y &gt; currentRowY then
&#9;&#9;&#9;&#9;currentRowY = guiObjects[pos].AbsoluteSize.Y
&#9;&#9;&#9;end

&#9;&#9;&#9;pos = pos - 1
&#9;&#9;end
&#9;&#9;
&#9;&#9;--Do check last time if pos = 0
&#9;&#9;if (pos == 0) and (pixelsBelowScrollbar + currentRowY &lt;= totalPixelsY) then
&#9;&#9;&#9;scrollPosition = 1
&#9;&#9;end

&#9;&#9;xCounter = 0
&#9;&#9;--pos = scrollPosition
&#9;&#9;rowSizeCounter = 0
&#9;&#9;setRowSize = true
&#9;&#9;local lastChildSize = 0
&#9;&#9;
&#9;&#9;local xOffset,yOffset = 0
&#9;&#9;if guiObjects[1] then
&#9;&#9;&#9;yOffset = math.ceil(math.floor(math.fmod(totalPixelsY,guiObjects[1].AbsoluteSize.X))/2)
&#9;&#9;&#9;xOffset = math.ceil(math.floor(math.fmod(totalPixelsX,guiObjects[1].AbsoluteSize.Y))/2)
&#9;&#9;end
&#9;&#9;
&#9;&#9;for i, child in ipairs(guiObjects) do
&#9;&#9;&#9;if i &lt; scrollPosition then
&#9;&#9;&#9;&#9;--print(&quot;Hiding &quot; .. child.Name)
&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;if pixelsRemainingY &lt; 0 then
&#9;&#9;&#9;&#9;&#9;--print(&quot;Out of Space &quot; .. child.Name)
&#9;&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;--print(&quot;Laying out &quot; .. child.Name)
&#9;&#9;&#9;&#9;&#9;--GuiObject
&#9;&#9;&#9;&#9;&#9;if setRowSize then rowSizeCounter = rowSizeCounter + 1 end
&#9;&#9;&#9;&#9;&#9;if xCounter + child.AbsoluteSize.X &gt;= totalPixelsX then
&#9;&#9;&#9;&#9;&#9;&#9;if setRowSize then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;rowSize = rowSizeCounter - 1
&#9;&#9;&#9;&#9;&#9;&#9;&#9;setRowSize = false
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;xCounter = 0
&#9;&#9;&#9;&#9;&#9;&#9;pixelsRemainingY = pixelsRemainingY - child.AbsoluteSize.Y
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;child.Position = UDim2.new(child.Position.X.Scale,xCounter + xOffset, 0, totalPixelsY - pixelsRemainingY + yOffset)
&#9;&#9;&#9;&#9;&#9;xCounter = xCounter + child.AbsoluteSize.X
&#9;&#9;&#9;&#9;&#9;child.Visible = ((pixelsRemainingY - child.AbsoluteSize.Y) &gt;= 0)
&#9;&#9;&#9;&#9;&#9;if child.Visible then
&#9;&#9;&#9;&#9;&#9;&#9;howManyDisplayed = howManyDisplayed + 1
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;lastChildSize = child.AbsoluteSize&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;scrollUpButton.Active = (scrollPosition &gt; 1)
&#9;&#9;if lastChildSize == 0 then 
&#9;&#9;&#9;scrollDownButton.Active = false
&#9;&#9;else
&#9;&#9;&#9;scrollDownButton.Active = ((pixelsRemainingY - lastChildSize.Y) &lt; 0)
&#9;&#9;end
&#9;&#9;scrollDrag.Active = #guiObjects &gt; howManyDisplayed
&#9;&#9;scrollDrag.Visible = scrollDrag.Active
&#9;end



&#9;local layoutSimpleScrollBar = function()
&#9;&#9;local guiObjects = {}&#9;
&#9;&#9;howManyDisplayed = 0
&#9;&#9;
&#9;&#9;if orderList then
&#9;&#9;&#9;for i, child in ipairs(orderList) do
&#9;&#9;&#9;&#9;if child.Parent == frame then
&#9;&#9;&#9;&#9;&#9;table.insert(guiObjects, child)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;local children = frame:GetChildren()
&#9;&#9;&#9;if children then
&#9;&#9;&#9;&#9;for i, child in ipairs(children) do 
&#9;&#9;&#9;&#9;&#9;if child:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;table.insert(guiObjects, child)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;if #guiObjects == 0 then
&#9;&#9;&#9;scrollUpButton.Active = false
&#9;&#9;&#9;scrollDownButton.Active = false
&#9;&#9;&#9;scrollDrag.Active = false
&#9;&#9;&#9;scrollPosition = 1
&#9;&#9;&#9;return
&#9;&#9;end

&#9;&#9;if scrollPosition &gt; #guiObjects then
&#9;&#9;&#9;scrollPosition = #guiObjects
&#9;&#9;end
&#9;&#9;
&#9;&#9;local totalPixels = frame.AbsoluteSize.Y
&#9;&#9;local pixelsRemaining = frame.AbsoluteSize.Y

&#9;&#9;local pixelsBelowScrollbar = 0
&#9;&#9;local pos = #guiObjects
&#9;&#9;while pixelsBelowScrollbar &lt; totalPixels and pos &gt;= 1 do
&#9;&#9;&#9;if pos &gt;= scrollPosition then
&#9;&#9;&#9;&#9;pixelsBelowScrollbar = pixelsBelowScrollbar + guiObjects[pos].AbsoluteSize.Y
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;if pixelsBelowScrollbar + guiObjects[pos].AbsoluteSize.Y &lt;= totalPixels then
&#9;&#9;&#9;&#9;&#9;--It fits, so back up our scroll position
&#9;&#9;&#9;&#9;&#9;pixelsBelowScrollbar = pixelsBelowScrollbar + guiObjects[pos].AbsoluteSize.Y
&#9;&#9;&#9;&#9;&#9;if scrollPosition &lt;= 1 then
&#9;&#9;&#9;&#9;&#9;&#9;scrollPosition = 1
&#9;&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;--local (&quot;Backing up ScrollPosition from -- &quot; ..scrollPosition)
&#9;&#9;&#9;&#9;&#9;&#9;scrollPosition = scrollPosition - 1
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;pos = pos - 1
&#9;&#9;end

&#9;&#9;pos = scrollPosition
&#9;&#9;for i, child in ipairs(guiObjects) do
&#9;&#9;&#9;if i &lt; scrollPosition then
&#9;&#9;&#9;&#9;--print(&quot;Hiding &quot; .. child.Name)
&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;if pixelsRemaining &lt; 0 then
&#9;&#9;&#9;&#9;&#9;--print(&quot;Out of Space &quot; .. child.Name)
&#9;&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;--print(&quot;Laying out &quot; .. child.Name)
&#9;&#9;&#9;&#9;&#9;--GuiObject
&#9;&#9;&#9;&#9;&#9;child.Position = UDim2.new(child.Position.X.Scale, child.Position.X.Offset, 0, totalPixels - pixelsRemaining)
&#9;&#9;&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - child.AbsoluteSize.Y
&#9;&#9;&#9;&#9;&#9;if  (pixelsRemaining &gt;= 0) then
&#9;&#9;&#9;&#9;&#9;&#9;child.Visible = true
&#9;&#9;&#9;&#9;&#9;&#9;howManyDisplayed = howManyDisplayed + 1
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;&#9;&#9;end&#9;&#9;
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;scrollUpButton.Active = (scrollPosition &gt; 1)
&#9;&#9;scrollDownButton.Active = (pixelsRemaining &lt; 0)
&#9;&#9;scrollDrag.Active = #guiObjects &gt; howManyDisplayed
&#9;&#9;scrollDrag.Visible = scrollDrag.Active
&#9;end
&#9;
&#9;&#9;
&#9;local moveDragger = function()&#9;
&#9;&#9;local guiObjects = 0
&#9;&#9;local children = frame:GetChildren()
&#9;&#9;if children then
&#9;&#9;&#9;for i, child in ipairs(children) do 
&#9;&#9;&#9;&#9;if child:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;&#9;guiObjects = guiObjects + 1
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;
&#9;&#9;if not scrollDrag.Parent then return end
&#9;&#9;
&#9;&#9;local dragSizeY = scrollDrag.Parent.AbsoluteSize.y * (1/(guiObjects - howManyDisplayed + 1))
&#9;&#9;if dragSizeY &lt; 16 then dragSizeY = 16 end
&#9;&#9;scrollDrag.Size = UDim2.new(scrollDrag.Size.X.Scale,scrollDrag.Size.X.Offset,scrollDrag.Size.Y.Scale,dragSizeY)

&#9;&#9;local relativeYPos = (scrollPosition - 1)/(guiObjects - (howManyDisplayed))
&#9;&#9;if relativeYPos &gt; 1 then relativeYPos = 1
&#9;&#9;elseif relativeYPos &lt; 0 then relativeYPos = 0 end
&#9;&#9;local absYPos = 0
&#9;&#9;
&#9;&#9;if relativeYPos ~= 0 then
&#9;&#9;&#9;absYPos = (relativeYPos * scrollbar.AbsoluteSize.y) - (relativeYPos * scrollDrag.AbsoluteSize.y)
&#9;&#9;end
&#9;&#9;
&#9;&#9;scrollDrag.Position = UDim2.new(scrollDrag.Position.X.Scale,scrollDrag.Position.X.Offset,scrollDrag.Position.Y.Scale,absYPos)
&#9;end

&#9;local reentrancyGuard = false
&#9;local recalculate = function()
&#9;&#9;if reentrancyGuard then
&#9;&#9;&#9;return
&#9;&#9;end
&#9;&#9;reentrancyGuard = true
&#9;&#9;wait()
&#9;&#9;local success, err = nil
&#9;&#9;if style == &quot;grid&quot; then
&#9;&#9;&#9;success, err = pcall(function() layoutGridScrollBar() end)
&#9;&#9;elseif style == &quot;simple&quot; then
&#9;&#9;&#9;success, err = pcall(function() layoutSimpleScrollBar() end)
&#9;&#9;end
&#9;&#9;if not success then print(err) end
&#9;&#9;moveDragger()
&#9;&#9;reentrancyGuard = false
&#9;end
&#9;
&#9;local doScrollUp = function()
&#9;&#9;scrollPosition = (scrollPosition) - rowSize
&#9;&#9;if scrollPosition &lt; 1 then scrollPosition = 1 end
&#9;&#9;recalculate(nil)
&#9;end
&#9;
&#9;local doScrollDown = function()
&#9;&#9;scrollPosition = (scrollPosition) + rowSize
&#9;&#9;recalculate(nil)
&#9;end

&#9;local scrollUp = function(mouseYPos)
&#9;&#9;if scrollUpButton.Active then
&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;local current = scrollStamp
&#9;&#9;&#9;local upCon
&#9;&#9;&#9;upCon = mouseDrag.MouseButton1Up:connect(function()
&#9;&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;&#9;mouseDrag.Parent = nil
&#9;&#9;&#9;&#9;upCon:disconnect()
&#9;&#9;&#9;end)
&#9;&#9;&#9;mouseDrag.Parent = getScreenGuiAncestor(scrollbar)
&#9;&#9;&#9;doScrollUp()
&#9;&#9;&#9;wait(0.2)
&#9;&#9;&#9;local t = tick()
&#9;&#9;&#9;local w = 0.1
&#9;&#9;&#9;while scrollStamp == current do
&#9;&#9;&#9;&#9;doScrollUp()
&#9;&#9;&#9;&#9;if mouseYPos and mouseYPos &gt; scrollDrag.AbsolutePosition.y then
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if not scrollUpButton.Active then break end
&#9;&#9;&#9;&#9;if tick()-t &gt; 5 then
&#9;&#9;&#9;&#9;&#9;w = 0
&#9;&#9;&#9;&#9;elseif tick()-t &gt; 2 then
&#9;&#9;&#9;&#9;&#9;w = 0.06
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;wait(w)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;local scrollDown = function(mouseYPos)
&#9;&#9;if scrollDownButton.Active then
&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;local current = scrollStamp
&#9;&#9;&#9;local downCon
&#9;&#9;&#9;downCon = mouseDrag.MouseButton1Up:connect(function()
&#9;&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;&#9;mouseDrag.Parent = nil
&#9;&#9;&#9;&#9;downCon:disconnect()
&#9;&#9;&#9;end)
&#9;&#9;&#9;mouseDrag.Parent = getScreenGuiAncestor(scrollbar)
&#9;&#9;&#9;doScrollDown()
&#9;&#9;&#9;wait(0.2)
&#9;&#9;&#9;local t = tick()
&#9;&#9;&#9;local w = 0.1
&#9;&#9;&#9;while scrollStamp == current do
&#9;&#9;&#9;&#9;doScrollDown()
&#9;&#9;&#9;&#9;if mouseYPos and mouseYPos &lt; (scrollDrag.AbsolutePosition.y + scrollDrag.AbsoluteSize.x) then
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if not scrollDownButton.Active then break end
&#9;&#9;&#9;&#9;if tick()-t &gt; 5 then
&#9;&#9;&#9;&#9;&#9;w = 0
&#9;&#9;&#9;&#9;elseif tick()-t &gt; 2 then
&#9;&#9;&#9;&#9;&#9;w = 0.06
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;wait(w)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;local y = 0
&#9;scrollDrag.MouseButton1Down:connect(function(x,y)
&#9;&#9;if scrollDrag.Active then
&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;local mouseOffset = y - scrollDrag.AbsolutePosition.y
&#9;&#9;&#9;local dragCon
&#9;&#9;&#9;local upCon
&#9;&#9;&#9;dragCon = mouseDrag.MouseMoved:connect(function(x,y)
&#9;&#9;&#9;&#9;local barAbsPos = scrollbar.AbsolutePosition.y
&#9;&#9;&#9;&#9;local barAbsSize = scrollbar.AbsoluteSize.y
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local dragAbsSize = scrollDrag.AbsoluteSize.y
&#9;&#9;&#9;&#9;local barAbsOne = barAbsPos + barAbsSize - dragAbsSize
&#9;&#9;&#9;&#9;y = y - mouseOffset
&#9;&#9;&#9;&#9;y = y &lt; barAbsPos and barAbsPos or y &gt; barAbsOne and barAbsOne or y
&#9;&#9;&#9;&#9;y = y - barAbsPos
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local guiObjects = 0
&#9;&#9;&#9;&#9;local children = frame:GetChildren()
&#9;&#9;&#9;&#9;if children then
&#9;&#9;&#9;&#9;&#9;for i, child in ipairs(children) do 
&#9;&#9;&#9;&#9;&#9;&#9;if child:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;guiObjects = guiObjects + 1
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local doublePercent = y/(barAbsSize-dragAbsSize)
&#9;&#9;&#9;&#9;local rowDiff = rowSize
&#9;&#9;&#9;&#9;local totalScrollCount = guiObjects - (howManyDisplayed - 1)
&#9;&#9;&#9;&#9;local newScrollPosition = math.floor((doublePercent * totalScrollCount) + 0.5) + rowDiff
&#9;&#9;&#9;&#9;if newScrollPosition &lt; scrollPosition then
&#9;&#9;&#9;&#9;&#9;rowDiff = -rowDiff
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;if newScrollPosition &lt; 1 then
&#9;&#9;&#9;&#9;&#9;newScrollPosition = 1
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;scrollPosition = newScrollPosition
&#9;&#9;&#9;&#9;recalculate(nil)
&#9;&#9;&#9;end)
&#9;&#9;&#9;upCon = mouseDrag.MouseButton1Up:connect(function()
&#9;&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;&#9;mouseDrag.Parent = nil
&#9;&#9;&#9;&#9;dragCon:disconnect(); dragCon = nil
&#9;&#9;&#9;&#9;upCon:disconnect(); drag = nil
&#9;&#9;&#9;end)
&#9;&#9;&#9;mouseDrag.Parent = getScreenGuiAncestor(scrollbar)
&#9;&#9;end
&#9;end)

&#9;local scrollMouseCount = 0

&#9;scrollUpButton.MouseButton1Down:connect(
&#9;&#9;function()
&#9;&#9;&#9;scrollUp()
&#9;&#9;end)
&#9;scrollUpButton.MouseButton1Up:connect(function()
&#9;&#9;scrollStamp = tick()
&#9;end)


&#9;scrollDownButton.MouseButton1Up:connect(function()
&#9;&#9;scrollStamp = tick()
&#9;end)
&#9;scrollDownButton.MouseButton1Down:connect(
&#9;&#9;function()
&#9;&#9;&#9;scrollDown()&#9;
&#9;&#9;end)
&#9;&#9;
&#9;scrollbar.MouseButton1Up:connect(function()
&#9;&#9;scrollStamp = tick()
&#9;end)
&#9;scrollbar.MouseButton1Down:connect(
&#9;&#9;function(x,y)
&#9;&#9;&#9;if y &gt; (scrollDrag.AbsoluteSize.y + scrollDrag.AbsolutePosition.y) then
&#9;&#9;&#9;&#9;scrollDown(y)
&#9;&#9;&#9;elseif y &lt; (scrollDrag.AbsolutePosition.y) then
&#9;&#9;&#9;&#9;scrollUp(y)
&#9;&#9;&#9;end
&#9;&#9;end)


&#9;frame.ChildAdded:connect(function()
&#9;&#9;recalculate(nil)
&#9;end)

&#9;frame.ChildRemoved:connect(function()
&#9;&#9;recalculate(nil)
&#9;end)
&#9;
&#9;frame.Changed:connect(
&#9;&#9;function(prop)
&#9;&#9;&#9;if prop == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;&#9;--Wait a heartbeat for it to sync in
&#9;&#9;&#9;&#9;recalculate(nil)
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;frame.AncestryChanged:connect(function() recalculate(nil) end)

&#9;return frame, scrollUpButton, scrollDownButton, recalculate, scrollbar
end
local function binaryGrow(min, max, fits)
&#9;if min &gt; max then
&#9;&#9;return min
&#9;end
&#9;local biggestLegal = min

&#9;while min &lt;= max do
&#9;&#9;local mid = min + math.floor((max - min) / 2)
&#9;&#9;if fits(mid) and (biggestLegal == nil or biggestLegal &lt; mid) then
&#9;&#9;&#9;biggestLegal = mid
&#9;&#9;&#9;
&#9;&#9;&#9;--Try growing
&#9;&#9;&#9;min = mid + 1
&#9;&#9;else
&#9;&#9;&#9;--Doesn&apos;t fit, shrink
&#9;&#9;&#9;max = mid - 1
&#9;&#9;end
&#9;end
&#9;return biggestLegal
end


local function binaryShrink(min, max, fits)
&#9;if min &gt; max then
&#9;&#9;return min
&#9;end
&#9;local smallestLegal = max

&#9;while min &lt;= max do
&#9;&#9;local mid = min + math.floor((max - min) / 2)
&#9;&#9;if fits(mid) and (smallestLegal == nil or smallestLegal &gt; mid) then
&#9;&#9;&#9;smallestLegal = mid
&#9;&#9;&#9;
&#9;&#9;&#9;--It fits, shrink
&#9;&#9;&#9;max = mid - 1&#9;&#9;&#9;
&#9;&#9;else
&#9;&#9;&#9;--Doesn&apos;t fit, grow
&#9;&#9;&#9;min = mid + 1
&#9;&#9;end
&#9;end
&#9;return smallestLegal
end


local function getGuiOwner(instance)
&#9;while instance ~= nil do
&#9;&#9;if instance:IsA(&quot;ScreenGui&quot;) or instance:IsA(&quot;BillboardGui&quot;)  then
&#9;&#9;&#9;return instance
&#9;&#9;end
&#9;&#9;instance = instance.Parent
&#9;end
&#9;return nil
end

t.AutoTruncateTextObject = function(textLabel)
&#9;local text = textLabel.Text

&#9;local fullLabel = textLabel:Clone()
&#9;fullLabel.Name = &quot;Full&quot; .. textLabel.Name 
&#9;fullLabel.BorderSizePixel = 0
&#9;fullLabel.BackgroundTransparency = 0
&#9;fullLabel.Text = text
&#9;fullLabel.TextXAlignment = Enum.TextXAlignment.Center
&#9;fullLabel.Position = UDim2.new(0,-3,0,0)
&#9;fullLabel.Size = UDim2.new(0,100,1,0)
&#9;fullLabel.Visible = false
&#9;fullLabel.Parent = textLabel

&#9;local shortText = nil
&#9;local mouseEnterConnection = nil
&#9;local mouseLeaveConnection= nil

&#9;local checkForResize = function()
&#9;&#9;if getGuiOwner(textLabel) == nil then
&#9;&#9;&#9;return
&#9;&#9;end
&#9;&#9;textLabel.Text = text
&#9;&#9;if textLabel.TextFits then 
&#9;&#9;&#9;--Tear down the rollover if it is active
&#9;&#9;&#9;if mouseEnterConnection then
&#9;&#9;&#9;&#9;mouseEnterConnection:disconnect()
&#9;&#9;&#9;&#9;mouseEnterConnection = nil
&#9;&#9;&#9;end
&#9;&#9;&#9;if mouseLeaveConnection then
&#9;&#9;&#9;&#9;mouseLeaveConnection:disconnect()
&#9;&#9;&#9;&#9;mouseLeaveConnection = nil
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;local len = string.len(text)
&#9;&#9;&#9;textLabel.Text = text .. &quot;~&quot;

&#9;&#9;&#9;--Shrink the text
&#9;&#9;&#9;local textSize = binaryGrow(0, len, 
&#9;&#9;&#9;&#9;function(pos)
&#9;&#9;&#9;&#9;&#9;if pos == 0 then
&#9;&#9;&#9;&#9;&#9;&#9;textLabel.Text = &quot;~&quot;
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;textLabel.Text = string.sub(text, 1, pos) .. &quot;~&quot;
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;return textLabel.TextFits
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;shortText = string.sub(text, 1, textSize) .. &quot;~&quot;
&#9;&#9;&#9;textLabel.Text = shortText
&#9;&#9;&#9;
&#9;&#9;&#9;--Make sure the fullLabel fits
&#9;&#9;&#9;if not fullLabel.TextFits then
&#9;&#9;&#9;&#9;--Already too small, grow it really bit to start
&#9;&#9;&#9;&#9;fullLabel.Size = UDim2.new(0, 10000, 1, 0)
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;--Okay, now try to binary shrink it back down
&#9;&#9;&#9;local fullLabelSize = binaryShrink(textLabel.AbsoluteSize.X,fullLabel.AbsoluteSize.X, 
&#9;&#9;&#9;&#9;function(size)
&#9;&#9;&#9;&#9;&#9;fullLabel.Size = UDim2.new(0, size, 1, 0)
&#9;&#9;&#9;&#9;&#9;return fullLabel.TextFits
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;fullLabel.Size = UDim2.new(0,fullLabelSize+6,1,0)

&#9;&#9;&#9;--Now setup the rollover effects, if they are currently off
&#9;&#9;&#9;if mouseEnterConnection == nil then
&#9;&#9;&#9;&#9;mouseEnterConnection = textLabel.MouseEnter:connect(
&#9;&#9;&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;&#9;&#9;fullLabel.ZIndex = textLabel.ZIndex + 1
&#9;&#9;&#9;&#9;&#9;&#9;fullLabel.Visible = true
&#9;&#9;&#9;&#9;&#9;&#9;--textLabel.Text = &quot;&quot;
&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;end
&#9;&#9;&#9;if mouseLeaveConnection == nil then
&#9;&#9;&#9;&#9;mouseLeaveConnection = textLabel.MouseLeave:connect(
&#9;&#9;&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;&#9;&#9;fullLabel.Visible = false
&#9;&#9;&#9;&#9;&#9;&#9;--textLabel.Text = shortText
&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;textLabel.AncestryChanged:connect(checkForResize)
&#9;textLabel.Changed:connect(
&#9;&#9;function(prop) 
&#9;&#9;&#9;if prop == &quot;AbsoluteSize&quot; then 
&#9;&#9;&#9;&#9;checkForResize() &#9;
&#9;&#9;&#9;end 
&#9;&#9;end)

&#9;checkForResize()

&#9;local function changeText(newText)
&#9;&#9;text = newText
&#9;&#9;fullLabel.Text = text
&#9;&#9;checkForResize()
&#9;end

&#9;return textLabel, changeText
end

local function TransitionTutorialPages(fromPage, toPage, transitionFrame, currentPageValue)&#9;
&#9;if fromPage then
&#9;&#9;fromPage.Visible = false
&#9;&#9;if transitionFrame.Visible == false then
&#9;&#9;&#9;transitionFrame.Size = fromPage.Size
&#9;&#9;&#9;transitionFrame.Position = fromPage.Position
&#9;&#9;end
&#9;else
&#9;&#9;if transitionFrame.Visible == false then
&#9;&#9;&#9;transitionFrame.Size = UDim2.new(0.0,50,0.0,50)
&#9;&#9;&#9;transitionFrame.Position = UDim2.new(0.5,-25,0.5,-25)
&#9;&#9;end
&#9;end
&#9;transitionFrame.Visible = true
&#9;currentPageValue.Value = nil

&#9;local newsize, newPosition
&#9;if toPage then
&#9;&#9;--Make it visible so it resizes
&#9;&#9;toPage.Visible = true

&#9;&#9;newSize = toPage.Size
&#9;&#9;newPosition = toPage.Position

&#9;&#9;toPage.Visible = false
&#9;else
&#9;&#9;newSize = UDim2.new(0.0,50,0.0,50)
&#9;&#9;newPosition = UDim2.new(0.5,-25,0.5,-25)
&#9;end
&#9;transitionFrame:TweenSizeAndPosition(newSize, newPosition, Enum.EasingDirection.InOut, Enum.EasingStyle.Quad, 0.3, true,
&#9;&#9;function(state)
&#9;&#9;&#9;if state == Enum.TweenStatus.Completed then
&#9;&#9;&#9;&#9;transitionFrame.Visible = false
&#9;&#9;&#9;&#9;if toPage then
&#9;&#9;&#9;&#9;&#9;toPage.Visible = true
&#9;&#9;&#9;&#9;&#9;currentPageValue.Value = toPage
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end)
end

t.CreateTutorial = function(name, tutorialKey, createButtons)
&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;frame.Name = &quot;Tutorial-&quot; .. name
&#9;frame.BackgroundTransparency = 1
&#9;frame.Size = UDim2.new(0.6, 0, 0.6, 0)
&#9;frame.Position = UDim2.new(0.2, 0, 0.2, 0)

&#9;local transitionFrame = Instance.new(&quot;Frame&quot;)
&#9;transitionFrame.Name = &quot;TransitionFrame&quot;
&#9;transitionFrame.Style = Enum.FrameStyle.RobloxRound
&#9;transitionFrame.Size = UDim2.new(0.6, 0, 0.6, 0)
&#9;transitionFrame.Position = UDim2.new(0.2, 0, 0.2, 0)
&#9;transitionFrame.Visible = false
&#9;transitionFrame.Parent = frame

&#9;local currentPageValue = Instance.new(&quot;ObjectValue&quot;)
&#9;currentPageValue.Name = &quot;CurrentTutorialPage&quot;
&#9;currentPageValue.Value = nil
&#9;currentPageValue.Parent = frame

&#9;local boolValue = Instance.new(&quot;BoolValue&quot;)
&#9;boolValue.Name = &quot;Buttons&quot;
&#9;boolValue.Value = createButtons
&#9;boolValue.Parent = frame

&#9;local pages = Instance.new(&quot;Frame&quot;)
&#9;pages.Name = &quot;Pages&quot;
&#9;pages.BackgroundTransparency = 1
&#9;pages.Size = UDim2.new(1,0,1,0)
&#9;pages.Parent = frame

&#9;local function getVisiblePageAndHideOthers()
&#9;&#9;local visiblePage = nil
&#9;&#9;local children = pages:GetChildren()
&#9;&#9;if children then
&#9;&#9;&#9;for i,child in ipairs(children) do
&#9;&#9;&#9;&#9;if child.Visible then
&#9;&#9;&#9;&#9;&#9;if visiblePage then
&#9;&#9;&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;visiblePage = child
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;return visiblePage
&#9;end

&#9;local showTutorial = function(alwaysShow)
&#9;&#9;if alwaysShow or UserSettings().GameSettings:GetTutorialState(tutorialKey) == false then
&#9;&#9;&#9;print(&quot;Showing tutorial-&quot;,tutorialKey)
&#9;&#9;&#9;local currentTutorialPage = getVisiblePageAndHideOthers()

&#9;&#9;&#9;local firstPage = pages:FindFirstChild(&quot;TutorialPage1&quot;)
&#9;&#9;&#9;if firstPage then
&#9;&#9;&#9;&#9;TransitionTutorialPages(currentTutorialPage, firstPage, transitionFrame, currentPageValue)&#9;
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;error(&quot;Could not find TutorialPage1&quot;)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;local dismissTutorial = function()
&#9;&#9;local currentTutorialPage = getVisiblePageAndHideOthers()

&#9;&#9;if currentTutorialPage then
&#9;&#9;&#9;TransitionTutorialPages(currentTutorialPage, nil, transitionFrame, currentPageValue)
&#9;&#9;end

&#9;&#9;UserSettings().GameSettings:SetTutorialState(tutorialKey, true)
&#9;end

&#9;local gotoPage = function(pageNum)
&#9;&#9;local page = pages:FindFirstChild(&quot;TutorialPage&quot; .. pageNum)
&#9;&#9;local currentTutorialPage = getVisiblePageAndHideOthers()
&#9;&#9;TransitionTutorialPages(currentTutorialPage, page, transitionFrame, currentPageValue)
&#9;end

&#9;return frame, showTutorial, dismissTutorial, gotoPage
end 

local function CreateBasicTutorialPage(name, handleResize, skipTutorial, giveDoneButton)
&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;frame.Name = &quot;TutorialPage&quot;
&#9;frame.Style = Enum.FrameStyle.RobloxRound
&#9;frame.Size = UDim2.new(0.6, 0, 0.6, 0)
&#9;frame.Position = UDim2.new(0.2, 0, 0.2, 0)
&#9;frame.Visible = false
&#9;
&#9;local frameHeader = Instance.new(&quot;TextLabel&quot;)
&#9;frameHeader.Name = &quot;Header&quot;
&#9;frameHeader.Text = name
&#9;frameHeader.BackgroundTransparency = 1
&#9;frameHeader.FontSize = Enum.FontSize.Size24
&#9;frameHeader.Font = Enum.Font.ArialBold
&#9;frameHeader.TextColor3 = Color3.new(1,1,1)
&#9;frameHeader.TextXAlignment = Enum.TextXAlignment.Center
&#9;frameHeader.TextWrap = true
&#9;frameHeader.Size = UDim2.new(1,-55, 0, 22)
&#9;frameHeader.Position = UDim2.new(0,0,0,0)
&#9;frameHeader.Parent = frame

&#9;local skipButton = Instance.new(&quot;ImageButton&quot;)
&#9;skipButton.Name = &quot;SkipButton&quot;
&#9;skipButton.AutoButtonColor = false
&#9;skipButton.BackgroundTransparency = 1
&#9;skipButton.Image = &quot;rbxasset://textures/ui/closeButton.png&quot;
&#9;skipButton.MouseButton1Click:connect(function()
&#9;&#9;skipTutorial()
&#9;end)
&#9;skipButton.MouseEnter:connect(function()
&#9;&#9;skipButton.Image = &quot;rbxasset://textures/ui/closeButton_dn.png&quot;
&#9;end)
&#9;skipButton.MouseLeave:connect(function()
&#9;&#9;skipButton.Image = &quot;rbxasset://textures/ui/closeButton.png&quot;
&#9;end)
&#9;skipButton.Size = UDim2.new(0, 25, 0, 25)
&#9;skipButton.Position = UDim2.new(1, -25, 0, 0)
&#9;skipButton.Parent = frame
&#9;
&#9;
&#9;if giveDoneButton then
&#9;&#9;local doneButton = Instance.new(&quot;TextButton&quot;)
&#9;&#9;doneButton.Name = &quot;DoneButton&quot;
&#9;&#9;doneButton.Style = Enum.ButtonStyle.RobloxButtonDefault
&#9;&#9;doneButton.Text = &quot;Done&quot;
&#9;&#9;doneButton.TextColor3 = Color3.new(1,1,1)
&#9;&#9;doneButton.Font = Enum.Font.ArialBold
&#9;&#9;doneButton.FontSize = Enum.FontSize.Size18
&#9;&#9;doneButton.Size = UDim2.new(0,100,0,50)
&#9;&#9;doneButton.Position = UDim2.new(0.5,-50,1,-50)
&#9;&#9;
&#9;&#9;if skipTutorial then
&#9;&#9;&#9;doneButton.MouseButton1Click:connect(function() skipTutorial() end)
&#9;&#9;end
&#9;&#9;
&#9;&#9;doneButton.Parent = frame
&#9;end

&#9;local innerFrame = Instance.new(&quot;Frame&quot;)
&#9;innerFrame.Name = &quot;ContentFrame&quot;
&#9;innerFrame.BackgroundTransparency = 1
&#9;innerFrame.Position = UDim2.new(0,0,0,25)
&#9;innerFrame.Parent = frame

&#9;local nextButton = Instance.new(&quot;TextButton&quot;)
&#9;nextButton.Name = &quot;NextButton&quot;
&#9;nextButton.Text = &quot;Next&quot;
&#9;nextButton.TextColor3 = Color3.new(1,1,1)
&#9;nextButton.Font = Enum.Font.Arial
&#9;nextButton.FontSize = Enum.FontSize.Size18
&#9;nextButton.Style = Enum.ButtonStyle.RobloxButtonDefault
&#9;nextButton.Size = UDim2.new(0,80, 0, 32)
&#9;nextButton.Position = UDim2.new(0.5, 5, 1, -32)
&#9;nextButton.Active = false
&#9;nextButton.Visible = false
&#9;nextButton.Parent = frame

&#9;local prevButton = Instance.new(&quot;TextButton&quot;)
&#9;prevButton.Name = &quot;PrevButton&quot;
&#9;prevButton.Text = &quot;Previous&quot;
&#9;prevButton.TextColor3 = Color3.new(1,1,1)
&#9;prevButton.Font = Enum.Font.Arial
&#9;prevButton.FontSize = Enum.FontSize.Size18
&#9;prevButton.Style = Enum.ButtonStyle.RobloxButton
&#9;prevButton.Size = UDim2.new(0,80, 0, 32)
&#9;prevButton.Position = UDim2.new(0.5, -85, 1, -32)
&#9;prevButton.Active = false
&#9;prevButton.Visible = false
&#9;prevButton.Parent = frame

&#9;if giveDoneButton then
&#9;&#9;innerFrame.Size = UDim2.new(1,0,1,-75)
&#9;else
&#9;&#9;innerFrame.Size = UDim2.new(1,0,1,-22)
&#9;end

&#9;local parentConnection = nil

&#9;local function basicHandleResize()
&#9;&#9;if frame.Visible and frame.Parent then
&#9;&#9;&#9;local maxSize = math.min(frame.Parent.AbsoluteSize.X, frame.Parent.AbsoluteSize.Y)
&#9;&#9;&#9;handleResize(200,maxSize)
&#9;&#9;end
&#9;end

&#9;frame.Changed:connect(
&#9;&#9;function(prop)
&#9;&#9;&#9;if prop == &quot;Parent&quot; then
&#9;&#9;&#9;&#9;if parentConnection ~= nil then
&#9;&#9;&#9;&#9;&#9;parentConnection:disconnect()
&#9;&#9;&#9;&#9;&#9;parentConnection = nil
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if frame.Parent and frame.Parent:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;&#9;parentConnection = frame.Parent.Changed:connect(
&#9;&#9;&#9;&#9;&#9;&#9;function(parentProp)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if parentProp == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;wait()
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;basicHandleResize()
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;&#9;basicHandleResize()
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end

&#9;&#9;&#9;if prop == &quot;Visible&quot; then 
&#9;&#9;&#9;&#9;basicHandleResize()
&#9;&#9;&#9;end
&#9;&#9;end)

&#9;return frame, innerFrame
end

t.CreateTextTutorialPage = function(name, text, skipTutorialFunc)
&#9;local frame = nil
&#9;local contentFrame = nil

&#9;local textLabel = Instance.new(&quot;TextLabel&quot;)
&#9;textLabel.BackgroundTransparency = 1
&#9;textLabel.TextColor3 = Color3.new(1,1,1)
&#9;textLabel.Text = text
&#9;textLabel.TextWrap = true
&#9;textLabel.TextXAlignment = Enum.TextXAlignment.Left
&#9;textLabel.TextYAlignment = Enum.TextYAlignment.Center
&#9;textLabel.Font = Enum.Font.Arial
&#9;textLabel.FontSize = Enum.FontSize.Size14
&#9;textLabel.Size = UDim2.new(1,0,1,0)

&#9;local function handleResize(minSize, maxSize)
&#9;&#9;size = binaryShrink(minSize, maxSize,
&#9;&#9;&#9;function(size)
&#9;&#9;&#9;&#9;frame.Size = UDim2.new(0, size, 0, size)
&#9;&#9;&#9;&#9;return textLabel.TextFits
&#9;&#9;&#9;end)
&#9;&#9;frame.Size = UDim2.new(0, size, 0, size)
&#9;&#9;frame.Position = UDim2.new(0.5, -size/2, 0.5, -size/2)
&#9;end

&#9;frame, contentFrame = CreateBasicTutorialPage(name, handleResize, skipTutorialFunc)
&#9;textLabel.Parent = contentFrame

&#9;return frame
end

t.CreateImageTutorialPage = function(name, imageAsset, x, y, skipTutorialFunc, giveDoneButton)
&#9;local frame = nil
&#9;local contentFrame = nil

&#9;local imageLabel = Instance.new(&quot;ImageLabel&quot;)
&#9;imageLabel.BackgroundTransparency = 1
&#9;imageLabel.Image = imageAsset
&#9;imageLabel.Size = UDim2.new(0,x,0,y)
&#9;imageLabel.Position = UDim2.new(0.5,-x/2,0.5,-y/2)

&#9;local function handleResize(minSize, maxSize)
&#9;&#9;size = binaryShrink(minSize, maxSize,
&#9;&#9;&#9;function(size)
&#9;&#9;&#9;&#9;return size &gt;= x and size &gt;= y
&#9;&#9;&#9;end)
&#9;&#9;if size &gt;= x and size &gt;= y then
&#9;&#9;&#9;imageLabel.Size = UDim2.new(0,x, 0,y)
&#9;&#9;&#9;imageLabel.Position = UDim2.new(0.5,-x/2, 0.5, -y/2)
&#9;&#9;else
&#9;&#9;&#9;if x &gt; y then
&#9;&#9;&#9;&#9;--X is limiter, so 
&#9;&#9;&#9;&#9;imageLabel.Size = UDim2.new(1,0,y/x,0)
&#9;&#9;&#9;&#9;imageLabel.Position = UDim2.new(0,0, 0.5 - (y/x)/2, 0)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;--Y is limiter
&#9;&#9;&#9;&#9;imageLabel.Size = UDim2.new(x/y,0,1, 0)
&#9;&#9;&#9;&#9;imageLabel.Position = UDim2.new(0.5-(x/y)/2, 0, 0, 0)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;size = size + 50
&#9;&#9;frame.Size = UDim2.new(0, size, 0, size)
&#9;&#9;frame.Position = UDim2.new(0.5, -size/2, 0.5, -size/2)
&#9;end

&#9;frame, contentFrame = CreateBasicTutorialPage(name, handleResize, skipTutorialFunc, giveDoneButton)
&#9;imageLabel.Parent = contentFrame

&#9;return frame
end

t.AddTutorialPage = function(tutorial, tutorialPage)
&#9;local transitionFrame = tutorial.TransitionFrame
&#9;local currentPageValue = tutorial.CurrentTutorialPage

&#9;if not tutorial.Buttons.Value then
&#9;&#9;tutorialPage.NextButton.Parent = nil
&#9;&#9;tutorialPage.PrevButton.Parent = nil
&#9;end

&#9;local children = tutorial.Pages:GetChildren()
&#9;if children and #children &gt; 0 then
&#9;&#9;tutorialPage.Name = &quot;TutorialPage&quot; .. (#children+1)
&#9;&#9;local previousPage = children[#children]
&#9;&#9;if not previousPage:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;error(&quot;All elements under Pages must be GuiObjects&quot;)
&#9;&#9;end

&#9;&#9;if tutorial.Buttons.Value then
&#9;&#9;&#9;if previousPage.NextButton.Active then
&#9;&#9;&#9;&#9;error(&quot;NextButton already Active on previousPage, please only add pages with RbxGui.AddTutorialPage function&quot;)
&#9;&#9;&#9;end
&#9;&#9;&#9;previousPage.NextButton.MouseButton1Click:connect(
&#9;&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;&#9;TransitionTutorialPages(previousPage, tutorialPage, transitionFrame, currentPageValue)
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;previousPage.NextButton.Active = true
&#9;&#9;&#9;previousPage.NextButton.Visible = true

&#9;&#9;&#9;if tutorialPage.PrevButton.Active then
&#9;&#9;&#9;&#9;error(&quot;PrevButton already Active on tutorialPage, please only add pages with RbxGui.AddTutorialPage function&quot;)
&#9;&#9;&#9;end
&#9;&#9;&#9;tutorialPage.PrevButton.MouseButton1Click:connect(
&#9;&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;&#9;TransitionTutorialPages(tutorialPage, previousPage, transitionFrame, currentPageValue)
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;tutorialPage.PrevButton.Active = true
&#9;&#9;&#9;tutorialPage.PrevButton.Visible = true
&#9;&#9;end

&#9;&#9;tutorialPage.Parent = tutorial.Pages
&#9;else
&#9;&#9;--First child
&#9;&#9;tutorialPage.Name = &quot;TutorialPage1&quot;
&#9;&#9;tutorialPage.Parent = tutorial.Pages
&#9;end
end 

t.CreateSetPanel = function(userIdsForSets, objectSelected, dialogClosed, size, position, showAdminCategories, useAssetVersionId)

&#9;if not userIdsForSets then
&#9;&#9;error(&quot;CreateSetPanel: userIdsForSets (first arg) is nil, should be a table of number ids&quot;)
&#9;end
&#9;if type(userIdsForSets) ~= &quot;table&quot; and type(userIdsForSets) ~= &quot;userdata&quot; then
&#9;&#9;error(&quot;CreateSetPanel: userIdsForSets (first arg) is of type &quot; ..type(userIdsForSets) .. &quot;, should be of type table or userdata&quot;)
&#9;end
&#9;if not objectSelected then
&#9;&#9;error(&quot;CreateSetPanel: objectSelected (second arg) is nil, should be a callback function!&quot;)
&#9;end
&#9;if type(objectSelected) ~= &quot;function&quot; then
&#9;&#9;error(&quot;CreateSetPanel: objectSelected (second arg) is of type &quot; .. type(objectSelected) .. &quot;, should be of type function!&quot;)
&#9;end
&#9;if dialogClosed and type(dialogClosed) ~= &quot;function&quot; then
&#9;&#9;error(&quot;CreateSetPanel: dialogClosed (third arg) is of type &quot; .. type(dialogClosed) .. &quot;, should be of type function!&quot;)
&#9;end
&#9;
&#9;if showAdminCategories == nil then -- by default, don&apos;t show beta sets
&#9;&#9;showAdminCategories = false
&#9;end

&#9;local arrayPosition = 1
&#9;local insertButtons = {}
&#9;local insertButtonCons = {}
&#9;local contents = nil
&#9;local setGui = nil

&#9;-- used for water selections
&#9;local waterForceDirection = &quot;NegX&quot;
&#9;local waterForce = &quot;None&quot;
&#9;local waterGui, waterTypeChangedEvent = nil
&#9;
&#9;local Data = {}
&#9;Data.CurrentCategory = nil
&#9;Data.Category = {}
&#9;local SetCache = {}
&#9;
&#9;local userCategoryButtons = nil
&#9;
&#9;local buttonWidth = 64
&#9;local buttonHeight = buttonWidth
&#9;
&#9;local SmallThumbnailUrl = nil
&#9;local LargeThumbnailUrl = nil
&#9;local BaseUrl = game:GetService(&quot;ContentProvider&quot;).BaseUrl:lower()
&#9;
&#9;if useAssetVersionId then
&#9;&#9;LargeThumbnailUrl = BaseUrl .. &quot;Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=420&amp;ht=420&amp;assetversionid=&quot;
&#9;&#9;SmallThumbnailUrl = BaseUrl .. &quot;Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=75&amp;ht=75&amp;assetversionid=&quot;
&#9;else
&#9;&#9;LargeThumbnailUrl = BaseUrl .. &quot;Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=420&amp;ht=420&amp;aid=&quot;
&#9;&#9;SmallThumbnailUrl = BaseUrl .. &quot;Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=75&amp;ht=75&amp;aid=&quot;
&#9;end
&#9;&#9;
&#9;local function drillDownSetZIndex(parent, index)
&#9;&#9;local children = parent:GetChildren()
&#9;&#9;for i = 1, #children do
&#9;&#9;&#9;if children[i]:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;children[i].ZIndex = index
&#9;&#9;&#9;end
&#9;&#9;&#9;drillDownSetZIndex(children[i], index)
&#9;&#9;end
&#9;end
&#9;
&#9;-- for terrain stamping
&#9;local currTerrainDropDownFrame = nil
&#9;local terrainShapes = {&quot;Block&quot;,&quot;Vertical Ramp&quot;,&quot;Corner Wedge&quot;,&quot;Inverse Corner Wedge&quot;,&quot;Horizontal Ramp&quot;,&quot;Auto-Wedge&quot;}
&#9;local terrainShapeMap = {}
&#9;for i = 1, #terrainShapes do
&#9;&#9;terrainShapeMap[terrainShapes[i]] = i - 1
&#9;end&#9;
&#9;terrainShapeMap[terrainShapes[#terrainShapes]] = 6

&#9;local function createWaterGui()
&#9;&#9;local waterForceDirections = {&quot;NegX&quot;,&quot;X&quot;,&quot;NegY&quot;,&quot;Y&quot;,&quot;NegZ&quot;,&quot;Z&quot;}
&#9;&#9;local waterForces = {&quot;None&quot;, &quot;Small&quot;, &quot;Medium&quot;, &quot;Strong&quot;, &quot;Max&quot;}

&#9;&#9;local waterFrame = Instance.new(&quot;Frame&quot;)
&#9;&#9;waterFrame.Name = &quot;WaterFrame&quot;
&#9;&#9;waterFrame.Style = Enum.FrameStyle.RobloxSquare
&#9;&#9;waterFrame.Size = UDim2.new(0,150,0,110)
&#9;&#9;waterFrame.Visible = false

&#9;&#9;local waterForceLabel = Instance.new(&quot;TextLabel&quot;)
&#9;&#9;waterForceLabel.Name = &quot;WaterForceLabel&quot;
&#9;&#9;waterForceLabel.BackgroundTransparency = 1
&#9;&#9;waterForceLabel.Size = UDim2.new(1,0,0,12)
&#9;&#9;waterForceLabel.Font = Enum.Font.ArialBold
&#9;&#9;waterForceLabel.FontSize = Enum.FontSize.Size12
&#9;&#9;waterForceLabel.TextColor3 = Color3.new(1,1,1)
&#9;&#9;waterForceLabel.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;waterForceLabel.Text = &quot;Water Force&quot;
&#9;&#9;waterForceLabel.Parent = waterFrame

&#9;&#9;local waterForceDirLabel = waterForceLabel:Clone()
&#9;&#9;waterForceDirLabel.Name = &quot;WaterForceDirectionLabel&quot;
&#9;&#9;waterForceDirLabel.Text = &quot;Water Force Direction&quot;
&#9;&#9;waterForceDirLabel.Position = UDim2.new(0,0,0,50)
&#9;&#9;waterForceDirLabel.Parent = waterFrame

&#9;&#9;local waterTypeChangedEvent = Instance.new(&quot;BindableEvent&quot;,waterFrame)
&#9;&#9;waterTypeChangedEvent.Name = &quot;WaterTypeChangedEvent&quot;

&#9;&#9;local waterForceDirectionSelectedFunc = function(newForceDirection)
&#9;&#9;&#9;waterForceDirection = newForceDirection
&#9;&#9;&#9;waterTypeChangedEvent:Fire({waterForce, waterForceDirection})
&#9;&#9;end
&#9;&#9;local waterForceSelectedFunc = function(newForce)
&#9;&#9;&#9;waterForce = newForce
&#9;&#9;&#9;waterTypeChangedEvent:Fire({waterForce, waterForceDirection})
&#9;&#9;end

&#9;&#9;local waterForceDirectionDropDown, forceWaterDirectionSelection = t.CreateDropDownMenu(waterForceDirections, waterForceDirectionSelectedFunc)
&#9;&#9;waterForceDirectionDropDown.Size = UDim2.new(1,0,0,25)
&#9;&#9;waterForceDirectionDropDown.Position = UDim2.new(0,0,1,3)
&#9;&#9;forceWaterDirectionSelection(&quot;NegX&quot;)
&#9;&#9;waterForceDirectionDropDown.Parent = waterForceDirLabel

&#9;&#9;local waterForceDropDown, forceWaterForceSelection = t.CreateDropDownMenu(waterForces, waterForceSelectedFunc)
&#9;&#9;forceWaterForceSelection(&quot;None&quot;)
&#9;&#9;waterForceDropDown.Size = UDim2.new(1,0,0,25)
&#9;&#9;waterForceDropDown.Position = UDim2.new(0,0,1,3)
&#9;&#9;waterForceDropDown.Parent = waterForceLabel

&#9;&#9;return waterFrame, waterTypeChangedEvent
&#9;end

&#9;-- Helper Function that contructs gui elements
&#9;local function createSetGui()
&#9;
&#9;&#9;local setGui = Instance.new(&quot;ScreenGui&quot;)
&#9;&#9;setGui.Name = &quot;SetGui&quot;
&#9;&#9;
&#9;&#9;local setPanel = Instance.new(&quot;Frame&quot;)
&#9;&#9;setPanel.Name = &quot;SetPanel&quot;
&#9;&#9;setPanel.Active = true
&#9;&#9;setPanel.BackgroundTransparency = 1
&#9;&#9;if position then
&#9;&#9;&#9;setPanel.Position = position
&#9;&#9;else
&#9;&#9;&#9;setPanel.Position = UDim2.new(0.2, 29, 0.1, 24)
&#9;&#9;end
&#9;&#9;if size then
&#9;&#9;&#9;setPanel.Size = size
&#9;&#9;else
&#9;&#9;&#9;setPanel.Size = UDim2.new(0.6, -58, 0.64, 0)
&#9;&#9;end
&#9;&#9;setPanel.Style = Enum.FrameStyle.RobloxRound
&#9;&#9;setPanel.ZIndex = 6
&#9;&#9;setPanel.Parent = setGui
&#9;&#9;
&#9;&#9;&#9;-- Children of SetPanel
&#9;&#9;&#9;local itemPreview = Instance.new(&quot;Frame&quot;)
&#9;&#9;&#9;itemPreview.Name = &quot;ItemPreview&quot;
&#9;&#9;&#9;itemPreview.BackgroundTransparency = 1
&#9;&#9;&#9;itemPreview.Position = UDim2.new(0.8,5,0.085,0)
&#9;&#9;&#9;itemPreview.Size = UDim2.new(0.21,0,0.9,0)
&#9;&#9;&#9;itemPreview.ZIndex = 6
&#9;&#9;&#9;itemPreview.Parent = setPanel
&#9;&#9;&#9;
&#9;&#9;&#9;&#9;-- Children of ItemPreview
&#9;&#9;&#9;&#9;local textPanel = Instance.new(&quot;Frame&quot;)
&#9;&#9;&#9;&#9;textPanel.Name = &quot;TextPanel&quot;
&#9;&#9;&#9;&#9;textPanel.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;textPanel.Position = UDim2.new(0,0,0.45,0)
&#9;&#9;&#9;&#9;textPanel.Size = UDim2.new(1,0,0.55,0)
&#9;&#9;&#9;&#9;textPanel.ZIndex = 6
&#9;&#9;&#9;&#9;textPanel.Parent = itemPreview
&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;-- Children of TextPanel
&#9;&#9;&#9;&#9;&#9;local rolloverText = Instance.new(&quot;TextLabel&quot;)
&#9;&#9;&#9;&#9;&#9;rolloverText.Name = &quot;RolloverText&quot;
&#9;&#9;&#9;&#9;&#9;rolloverText.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;&#9;rolloverText.Size = UDim2.new(1,0,0,48)
&#9;&#9;&#9;&#9;&#9;rolloverText.ZIndex = 6
&#9;&#9;&#9;&#9;&#9;rolloverText.Font = Enum.Font.ArialBold
&#9;&#9;&#9;&#9;&#9;rolloverText.FontSize = Enum.FontSize.Size24
&#9;&#9;&#9;&#9;&#9;rolloverText.Text = &quot;&quot;
&#9;&#9;&#9;&#9;&#9;rolloverText.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;&#9;rolloverText.TextWrap = true
&#9;&#9;&#9;&#9;&#9;rolloverText.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;&#9;&#9;&#9;rolloverText.TextYAlignment = Enum.TextYAlignment.Top
&#9;&#9;&#9;&#9;&#9;rolloverText.Parent = textPanel
&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local largePreview = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;&#9;&#9;largePreview.Name = &quot;LargePreview&quot;
&#9;&#9;&#9;&#9;largePreview.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;largePreview.Image = &quot;&quot;
&#9;&#9;&#9;&#9;largePreview.Size = UDim2.new(1,0,0,170)
&#9;&#9;&#9;&#9;largePreview.ZIndex = 6
&#9;&#9;&#9;&#9;largePreview.Parent = itemPreview
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;local sets = Instance.new(&quot;Frame&quot;)
&#9;&#9;&#9;sets.Name = &quot;Sets&quot;
&#9;&#9;&#9;sets.BackgroundTransparency = 1
&#9;&#9;&#9;sets.Position = UDim2.new(0,0,0,5)
&#9;&#9;&#9;sets.Size = UDim2.new(0.23,0,1,-5)
&#9;&#9;&#9;sets.ZIndex = 6
&#9;&#9;&#9;sets.Parent = setPanel
&#9;&#9;&#9;
&#9;&#9;&#9;&#9;-- Children of Sets
&#9;&#9;&#9;&#9;local line = Instance.new(&quot;Frame&quot;)
&#9;&#9;&#9;&#9;line.Name = &quot;Line&quot;
&#9;&#9;&#9;&#9;line.BackgroundColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;line.BackgroundTransparency = 0.7
&#9;&#9;&#9;&#9;line.BorderSizePixel = 0
&#9;&#9;&#9;&#9;line.Position = UDim2.new(1,-3,0.06,0)
&#9;&#9;&#9;&#9;line.Size = UDim2.new(0,3,0.9,0)
&#9;&#9;&#9;&#9;line.ZIndex = 6
&#9;&#9;&#9;&#9;line.Parent = sets
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local setsLists, controlFrame = t.CreateTrueScrollingFrame()
&#9;&#9;&#9;&#9;setsLists.Size = UDim2.new(1,-6,0.94,0)
&#9;&#9;&#9;&#9;setsLists.Position = UDim2.new(0,0,0.06,0)
&#9;&#9;&#9;&#9;setsLists.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;setsLists.Name = &quot;SetsLists&quot;
&#9;&#9;&#9;&#9;setsLists.ZIndex = 6
&#9;&#9;&#9;&#9;setsLists.Parent = sets
&#9;&#9;&#9;&#9;drillDownSetZIndex(controlFrame, 7)
&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local setsHeader = Instance.new(&quot;TextLabel&quot;)
&#9;&#9;&#9;&#9;setsHeader.Name = &quot;SetsHeader&quot;
&#9;&#9;&#9;&#9;setsHeader.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;setsHeader.Size = UDim2.new(0,47,0,24)
&#9;&#9;&#9;&#9;setsHeader.ZIndex = 6
&#9;&#9;&#9;&#9;setsHeader.Font = Enum.Font.ArialBold
&#9;&#9;&#9;&#9;setsHeader.FontSize = Enum.FontSize.Size24
&#9;&#9;&#9;&#9;setsHeader.Text = &quot;Sets&quot;
&#9;&#9;&#9;&#9;setsHeader.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;setsHeader.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;&#9;&#9;setsHeader.TextYAlignment = Enum.TextYAlignment.Top
&#9;&#9;&#9;&#9;setsHeader.Parent = sets
&#9;&#9;&#9;
&#9;&#9;&#9;local cancelButton = Instance.new(&quot;TextButton&quot;)
&#9;&#9;&#9;cancelButton.Name = &quot;CancelButton&quot;
&#9;&#9;&#9;cancelButton.Position = UDim2.new(1,-32,0,-2)
&#9;&#9;&#9;cancelButton.Size = UDim2.new(0,34,0,34)
&#9;&#9;&#9;cancelButton.Style = Enum.ButtonStyle.RobloxButtonDefault
&#9;&#9;&#9;cancelButton.ZIndex = 6
&#9;&#9;&#9;cancelButton.Text = &quot;&quot;
&#9;&#9;&#9;cancelButton.Modal = true
&#9;&#9;&#9;cancelButton.Parent = setPanel
&#9;&#9;&#9;
&#9;&#9;&#9;&#9;-- Children of Cancel Button
&#9;&#9;&#9;&#9;local cancelImage = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;&#9;&#9;cancelImage.Name = &quot;CancelImage&quot;
&#9;&#9;&#9;&#9;cancelImage.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;cancelImage.Image = &quot;http://www.roblox.com/asset/?id=54135717&quot;
&#9;&#9;&#9;&#9;cancelImage.Position = UDim2.new(0,-2,0,-2)
&#9;&#9;&#9;&#9;cancelImage.Size = UDim2.new(0,16,0,16)
&#9;&#9;&#9;&#9;cancelImage.ZIndex = 6
&#9;&#9;&#9;&#9;cancelImage.Parent = cancelButton
&#9;&#9;&#9;&#9;&#9;
&#9;&#9;return setGui
&#9;end
&#9;
&#9;local function createSetButton(text)
&#9;&#9;local setButton = Instance.new(&quot;TextButton&quot;)
&#9;&#9;
&#9;&#9;if text then setButton.Text = text
&#9;&#9;else setButton.Text = &quot;&quot; end
&#9;&#9;
&#9;&#9;setButton.AutoButtonColor = false
&#9;&#9;setButton.BackgroundTransparency = 1
&#9;&#9;setButton.BackgroundColor3 = Color3.new(1,1,1)
&#9;&#9;setButton.BorderSizePixel = 0
&#9;&#9;setButton.Size = UDim2.new(1,-5,0,18)
&#9;&#9;setButton.ZIndex = 6
&#9;&#9;setButton.Visible = false
&#9;&#9;setButton.Font = Enum.Font.Arial
&#9;&#9;setButton.FontSize = Enum.FontSize.Size18
&#9;&#9;setButton.TextColor3 = Color3.new(1,1,1)
&#9;&#9;setButton.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;
&#9;&#9;return setButton
&#9;end
&#9;
&#9;local function buildSetButton(name, setId, setImageId, i,  count)
&#9;&#9;local button = createSetButton(name)
&#9;&#9;button.Text = name
&#9;&#9;button.Name = &quot;SetButton&quot;
&#9;&#9;button.Visible = true
&#9;&#9;
&#9;&#9;local setValue = Instance.new(&quot;IntValue&quot;)
&#9;&#9;setValue.Name = &quot;SetId&quot;
&#9;&#9;setValue.Value = setId
&#9;&#9;setValue.Parent = button

&#9;&#9;local setName = Instance.new(&quot;StringValue&quot;)
&#9;&#9;setName.Name = &quot;SetName&quot;
&#9;&#9;setName.Value = name
&#9;&#9;setName.Parent = button

&#9;&#9;return button
&#9;end
&#9;
&#9;local function processCategory(sets)
&#9;&#9;local setButtons = {}
&#9;&#9;local numSkipped = 0
&#9;&#9;for i = 1, #sets do
&#9;&#9;&#9;if not showAdminCategories and sets[i].Name == &quot;Beta&quot; then
&#9;&#9;&#9;&#9;numSkipped = numSkipped + 1
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;setButtons[i - numSkipped] = buildSetButton(sets[i].Name, sets[i].CategoryId, sets[i].ImageAssetId, i - numSkipped, #sets)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;return setButtons
&#9;end
&#9;
&#9;local function handleResize()
&#9;&#9;wait() -- neccessary to insure heartbeat happened
&#9;&#9;
&#9;&#9;local itemPreview = setGui.SetPanel.ItemPreview
&#9;&#9;
&#9;&#9;itemPreview.LargePreview.Size = UDim2.new(1,0,0,itemPreview.AbsoluteSize.X)
&#9;&#9;itemPreview.LargePreview.Position = UDim2.new(0.5,-itemPreview.LargePreview.AbsoluteSize.X/2,0,0)
&#9;&#9;itemPreview.TextPanel.Position = UDim2.new(0,0,0,itemPreview.LargePreview.AbsoluteSize.Y)
&#9;&#9;itemPreview.TextPanel.Size = UDim2.new(1,0,0,itemPreview.AbsoluteSize.Y - itemPreview.LargePreview.AbsoluteSize.Y)
&#9;end
&#9;
&#9;local function makeInsertAssetButton()
&#9;&#9;local insertAssetButtonExample = Instance.new(&quot;Frame&quot;)
&#9;&#9;insertAssetButtonExample.Name = &quot;InsertAssetButtonExample&quot;
&#9;&#9;insertAssetButtonExample.Position = UDim2.new(0,128,0,64)
&#9;&#9;insertAssetButtonExample.Size = UDim2.new(0,64,0,64)
&#9;&#9;insertAssetButtonExample.BackgroundTransparency = 1
&#9;&#9;insertAssetButtonExample.ZIndex = 6
&#9;&#9;insertAssetButtonExample.Visible = false

&#9;&#9;local assetId = Instance.new(&quot;IntValue&quot;)
&#9;&#9;assetId.Name = &quot;AssetId&quot;
&#9;&#9;assetId.Value = 0
&#9;&#9;assetId.Parent = insertAssetButtonExample
&#9;&#9;
&#9;&#9;local assetName = Instance.new(&quot;StringValue&quot;)
&#9;&#9;assetName.Name = &quot;AssetName&quot;
&#9;&#9;assetName.Value = &quot;&quot;
&#9;&#9;assetName.Parent = insertAssetButtonExample

&#9;&#9;local button = Instance.new(&quot;TextButton&quot;)
&#9;&#9;button.Name = &quot;Button&quot;
&#9;&#9;button.Text = &quot;&quot;
&#9;&#9;button.Style = Enum.ButtonStyle.RobloxButton
&#9;&#9;button.Position = UDim2.new(0.025,0,0.025,0)
&#9;&#9;button.Size = UDim2.new(0.95,0,0.95,0)
&#9;&#9;button.ZIndex = 6
&#9;&#9;button.Parent = insertAssetButtonExample

&#9;&#9;local buttonImage = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;buttonImage.Name = &quot;ButtonImage&quot;
&#9;&#9;buttonImage.Image = &quot;&quot;
&#9;&#9;buttonImage.Position = UDim2.new(0,-7,0,-7)
&#9;&#9;buttonImage.Size = UDim2.new(1,14,1,14)
&#9;&#9;buttonImage.BackgroundTransparency = 1
&#9;&#9;buttonImage.ZIndex = 7
&#9;&#9;buttonImage.Parent = button

&#9;&#9;local configIcon = buttonImage:clone()
&#9;&#9;configIcon.Name = &quot;ConfigIcon&quot;
&#9;&#9;configIcon.Visible = false
&#9;&#9;configIcon.Position = UDim2.new(1,-23,1,-24)
&#9;&#9;configIcon.Size = UDim2.new(0,16,0,16)
&#9;&#9;configIcon.Image = &quot;&quot;
&#9;&#9;configIcon.ZIndex = 6
&#9;&#9;configIcon.Parent = insertAssetButtonExample
&#9;&#9;
&#9;&#9;return insertAssetButtonExample
&#9;end
&#9;
&#9;local function showLargePreview(insertButton)
&#9;&#9;if insertButton:FindFirstChild(&quot;AssetId&quot;) then
&#9;&#9;&#9;delay(0,function()
&#9;&#9;&#9;&#9;game:GetService(&quot;ContentProvider&quot;):Preload(LargeThumbnailUrl .. tostring(insertButton.AssetId.Value))
&#9;&#9;&#9;&#9;setGui.SetPanel.ItemPreview.LargePreview.Image = LargeThumbnailUrl .. tostring(insertButton.AssetId.Value)
&#9;&#9;&#9;end)
&#9;&#9;end
&#9;&#9;if insertButton:FindFirstChild(&quot;AssetName&quot;) then
&#9;&#9;&#9;setGui.SetPanel.ItemPreview.TextPanel.RolloverText.Text = insertButton.AssetName.Value
&#9;&#9;end
&#9;end
&#9;
&#9;local function selectTerrainShape(shape)
&#9;&#9;if currTerrainDropDownFrame then
&#9;&#9;&#9;objectSelected(tostring(currTerrainDropDownFrame.AssetName.Value), tonumber(currTerrainDropDownFrame.AssetId.Value), shape)
&#9;&#9;end
&#9;end
&#9;
&#9;local function createTerrainTypeButton(name, parent)
&#9;&#9;local dropDownTextButton = Instance.new(&quot;TextButton&quot;)
&#9;&#9;dropDownTextButton.Name = name .. &quot;Button&quot;
&#9;&#9;dropDownTextButton.Font = Enum.Font.ArialBold
&#9;&#9;dropDownTextButton.FontSize = Enum.FontSize.Size14
&#9;&#9;dropDownTextButton.BorderSizePixel = 0
&#9;&#9;dropDownTextButton.TextColor3 = Color3.new(1,1,1)
&#9;&#9;dropDownTextButton.Text = name
&#9;&#9;dropDownTextButton.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;dropDownTextButton.BackgroundTransparency = 1
&#9;&#9;dropDownTextButton.ZIndex = parent.ZIndex + 1
&#9;&#9;dropDownTextButton.Size = UDim2.new(0,parent.Size.X.Offset - 2,0,16)
&#9;&#9;dropDownTextButton.Position = UDim2.new(0,1,0,0)

&#9;&#9;dropDownTextButton.MouseEnter:connect(function()
&#9;&#9;&#9;dropDownTextButton.BackgroundTransparency = 0
&#9;&#9;&#9;dropDownTextButton.TextColor3 = Color3.new(0,0,0)
&#9;&#9;end)

&#9;&#9;dropDownTextButton.MouseLeave:connect(function()
&#9;&#9;&#9;dropDownTextButton.BackgroundTransparency = 1
&#9;&#9;&#9;dropDownTextButton.TextColor3 = Color3.new(1,1,1)
&#9;&#9;end)

&#9;&#9;dropDownTextButton.MouseButton1Click:connect(function()
&#9;&#9;&#9;dropDownTextButton.BackgroundTransparency = 1
&#9;&#9;&#9;dropDownTextButton.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;if dropDownTextButton.Parent and dropDownTextButton.Parent:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;dropDownTextButton.Parent.Visible = false
&#9;&#9;&#9;end
&#9;&#9;&#9;selectTerrainShape(terrainShapeMap[dropDownTextButton.Text])
&#9;&#9;end)

&#9;&#9;return dropDownTextButton
&#9;end
&#9;
&#9;local function createTerrainDropDownMenu(zIndex)
&#9;&#9;local dropDown = Instance.new(&quot;Frame&quot;)
&#9;&#9;dropDown.Name = &quot;TerrainDropDown&quot;
&#9;&#9;dropDown.BackgroundColor3 = Color3.new(0,0,0)
&#9;&#9;dropDown.BorderColor3 = Color3.new(1,0,0)
&#9;&#9;dropDown.Size = UDim2.new(0,200,0,0)
&#9;&#9;dropDown.Visible = false
&#9;&#9;dropDown.ZIndex = zIndex
&#9;&#9;dropDown.Parent = setGui

&#9;&#9;for i = 1, #terrainShapes do
&#9;&#9;&#9;local shapeButton = createTerrainTypeButton(terrainShapes[i],dropDown)
&#9;&#9;&#9;shapeButton.Position = UDim2.new(0,1,0,(i - 1) * (shapeButton.Size.Y.Offset))
&#9;&#9;&#9;shapeButton.Parent = dropDown
&#9;&#9;&#9;dropDown.Size = UDim2.new(0,200,0,dropDown.Size.Y.Offset + (shapeButton.Size.Y.Offset))
&#9;&#9;end

&#9;&#9;dropDown.MouseLeave:connect(function()
&#9;&#9;&#9;dropDown.Visible = false
&#9;&#9;end)
&#9;end

&#9;
&#9;local function createDropDownMenuButton(parent)
&#9;&#9;local dropDownButton = Instance.new(&quot;ImageButton&quot;)
&#9;&#9;dropDownButton.Name = &quot;DropDownButton&quot;
&#9;&#9;dropDownButton.Image = &quot;http://www.roblox.com/asset/?id=67581509&quot;
&#9;&#9;dropDownButton.BackgroundTransparency = 1
&#9;&#9;dropDownButton.Size = UDim2.new(0,16,0,16)
&#9;&#9;dropDownButton.Position = UDim2.new(1,-24,0,6)
&#9;&#9;dropDownButton.ZIndex = parent.ZIndex + 2
&#9;&#9;dropDownButton.Parent = parent
&#9;&#9;
&#9;&#9;if not setGui:FindFirstChild(&quot;TerrainDropDown&quot;) then
&#9;&#9;&#9;createTerrainDropDownMenu(8)
&#9;&#9;end
&#9;&#9;
&#9;&#9;dropDownButton.MouseButton1Click:connect(function()
&#9;&#9;&#9;setGui.TerrainDropDown.Visible = true
&#9;&#9;&#9;setGui.TerrainDropDown.Position = UDim2.new(0,parent.AbsolutePosition.X,0,parent.AbsolutePosition.Y)
&#9;&#9;&#9;currTerrainDropDownFrame = parent
&#9;&#9;end)
&#9;end
&#9;
&#9;local function buildInsertButton()
&#9;&#9;local insertButton = makeInsertAssetButton()
&#9;&#9;insertButton.Name = &quot;InsertAssetButton&quot;
&#9;&#9;insertButton.Visible = true

&#9;&#9;if Data.Category[Data.CurrentCategory].SetName == &quot;High Scalability&quot; then
&#9;&#9;&#9;createDropDownMenuButton(insertButton)
&#9;&#9;end

&#9;&#9;local lastEnter = nil
&#9;&#9;local mouseEnterCon = insertButton.MouseEnter:connect(function()
&#9;&#9;&#9;lastEnter = insertButton
&#9;&#9;&#9;delay(0.1,function()
&#9;&#9;&#9;&#9;if lastEnter == insertButton then
&#9;&#9;&#9;&#9;&#9;showLargePreview(insertButton)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;end)
&#9;&#9;return insertButton, mouseEnterCon
&#9;end
&#9;
&#9;local function realignButtonGrid(columns)
&#9;&#9;local x = 0
&#9;&#9;local y = 0 
&#9;&#9;for i = 1, #insertButtons do
&#9;&#9;&#9;insertButtons[i].Position = UDim2.new(0, buttonWidth * x, 0, buttonHeight * y)
&#9;&#9;&#9;x = x + 1
&#9;&#9;&#9;if x &gt;= columns then
&#9;&#9;&#9;&#9;x = 0
&#9;&#9;&#9;&#9;y = y + 1
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;local function setInsertButtonImageBehavior(insertFrame, visible, name, assetId)
&#9;&#9;if visible then
&#9;&#9;&#9;insertFrame.AssetName.Value = name
&#9;&#9;&#9;insertFrame.AssetId.Value = assetId
&#9;&#9;&#9;local newImageUrl = SmallThumbnailUrl  .. assetId
&#9;&#9;&#9;if newImageUrl ~= insertFrame.Button.ButtonImage.Image then
&#9;&#9;&#9;&#9;delay(0,function()
&#9;&#9;&#9;&#9;&#9;game:GetService(&quot;ContentProvider&quot;):Preload(SmallThumbnailUrl  .. assetId)
&#9;&#9;&#9;&#9;&#9;if insertFrame:findFirstChild(&quot;Button&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;insertFrame.Button.ButtonImage.Image = SmallThumbnailUrl  .. assetId
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;end
&#9;&#9;&#9;table.insert(insertButtonCons,
&#9;&#9;&#9;&#9;insertFrame.Button.MouseButton1Click:connect(function()
&#9;&#9;&#9;&#9;&#9;-- special case for water, show water selection gui
&#9;&#9;&#9;&#9;&#9;local isWaterSelected = (name == &quot;Water&quot;) and (Data.Category[Data.CurrentCategory].SetName == &quot;High Scalability&quot;)
&#9;&#9;&#9;&#9;&#9;waterGui.Visible = isWaterSelected
&#9;&#9;&#9;&#9;&#9;if isWaterSelected then
&#9;&#9;&#9;&#9;&#9;&#9;objectSelected(name, tonumber(assetId), nil)
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;objectSelected(name, tonumber(assetId))
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;)
&#9;&#9;&#9;insertFrame.Visible = true
&#9;&#9;else
&#9;&#9;&#9;insertFrame.Visible = false
&#9;&#9;end
&#9;end
&#9;
&#9;local function loadSectionOfItems(setGui, rows, columns)
&#9;&#9;local pageSize = rows * columns

&#9;&#9;if arrayPosition &gt; #contents then return end

&#9;&#9;local origArrayPos = arrayPosition

&#9;&#9;local yCopy = 0
&#9;&#9;for i = 1, pageSize + 1 do 
&#9;&#9;&#9;if arrayPosition &gt;= #contents + 1 then
&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;end

&#9;&#9;&#9;local buttonCon
&#9;&#9;&#9;insertButtons[arrayPosition], buttonCon = buildInsertButton()
&#9;&#9;&#9;table.insert(insertButtonCons,buttonCon)
&#9;&#9;&#9;insertButtons[arrayPosition].Parent = setGui.SetPanel.ItemsFrame
&#9;&#9;&#9;arrayPosition = arrayPosition + 1
&#9;&#9;end
&#9;&#9;realignButtonGrid(columns)

&#9;&#9;local indexCopy = origArrayPos
&#9;&#9;for index = origArrayPos, arrayPosition do
&#9;&#9;&#9;if insertButtons[index] then
&#9;&#9;&#9;&#9;if contents[index] then

&#9;&#9;&#9;&#9;&#9;-- we don&apos;t want water to have a drop down button
&#9;&#9;&#9;&#9;&#9;if contents[index].Name == &quot;Water&quot; then
&#9;&#9;&#9;&#9;&#9;&#9;if Data.Category[Data.CurrentCategory].SetName == &quot;High Scalability&quot; then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;insertButtons[index]:FindFirstChild(&quot;DropDownButton&quot;,true):Destroy()
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;&#9;local assetId
&#9;&#9;&#9;&#9;&#9;if useAssetVersionId then
&#9;&#9;&#9;&#9;&#9;&#9;assetId = contents[index].AssetVersionId
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;assetId = contents[index].AssetId
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;setInsertButtonImageBehavior(insertButtons[index], true, contents[index].Name, assetId)
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;end
&#9;&#9;&#9;indexCopy = index
&#9;&#9;end
&#9;end
&#9;
&#9;local function setSetIndex()
&#9;&#9;Data.Category[Data.CurrentCategory].Index = 0

&#9;&#9;rows = 7
&#9;&#9;columns = math.floor(setGui.SetPanel.ItemsFrame.AbsoluteSize.X/buttonWidth)

&#9;&#9;contents = Data.Category[Data.CurrentCategory].Contents
&#9;&#9;if contents then
&#9;&#9;&#9;-- remove our buttons and their connections
&#9;&#9;&#9;for i = 1, #insertButtons do
&#9;&#9;&#9;&#9;insertButtons[i]:remove()
&#9;&#9;&#9;end
&#9;&#9;&#9;for i = 1, #insertButtonCons do
&#9;&#9;&#9;&#9;if insertButtonCons[i] then insertButtonCons[i]:disconnect() end
&#9;&#9;&#9;end
&#9;&#9;&#9;insertButtonCons = {}
&#9;&#9;&#9;insertButtons = {}

&#9;&#9;&#9;arrayPosition = 1
&#9;&#9;&#9;loadSectionOfItems(setGui, rows, columns)
&#9;&#9;end
&#9;end
&#9;
&#9;local function selectSet(button, setName, setId, setIndex)
&#9;&#9;if button and Data.Category[Data.CurrentCategory] ~= nil then
&#9;&#9;&#9;if button ~= Data.Category[Data.CurrentCategory].Button then
&#9;&#9;&#9;&#9;Data.Category[Data.CurrentCategory].Button = button

&#9;&#9;&#9;&#9;if SetCache[setId] == nil then
&#9;&#9;&#9;&#9;&#9;SetCache[setId] = game:GetService(&quot;InsertService&quot;):GetCollection(setId)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;Data.Category[Data.CurrentCategory].Contents = SetCache[setId]

&#9;&#9;&#9;&#9;Data.Category[Data.CurrentCategory].SetName = setName
&#9;&#9;&#9;&#9;Data.Category[Data.CurrentCategory].SetId = setId
&#9;&#9;&#9;end
&#9;&#9;&#9;setSetIndex()
&#9;&#9;end
&#9;end
&#9;
&#9;local function selectCategoryPage(buttons, page)
&#9;&#9;if buttons ~= Data.CurrentCategory then
&#9;&#9;&#9;if Data.CurrentCategory then
&#9;&#9;&#9;&#9;for key, button in pairs(Data.CurrentCategory) do
&#9;&#9;&#9;&#9;&#9;button.Visible = false
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end

&#9;&#9;&#9;Data.CurrentCategory = buttons
&#9;&#9;&#9;if Data.Category[Data.CurrentCategory] == nil then
&#9;&#9;&#9;&#9;Data.Category[Data.CurrentCategory] = {}
&#9;&#9;&#9;&#9;if #buttons &gt; 0 then
&#9;&#9;&#9;&#9;&#9;selectSet(buttons[1], buttons[1].SetName.Value, buttons[1].SetId.Value, 0)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;Data.Category[Data.CurrentCategory].Button = nil
&#9;&#9;&#9;&#9;selectSet(Data.Category[Data.CurrentCategory].ButtonFrame, Data.Category[Data.CurrentCategory].SetName, Data.Category[Data.CurrentCategory].SetId, Data.Category[Data.CurrentCategory].Index)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;local function selectCategory(category)
&#9;&#9;selectCategoryPage(category, 0)
&#9;end
&#9;
&#9;local function resetAllSetButtonSelection()
&#9;&#9;local setButtons = setGui.SetPanel.Sets.SetsLists:GetChildren()
&#9;&#9;for i = 1, #setButtons do
&#9;&#9;&#9;if setButtons[i]:IsA(&quot;TextButton&quot;) then
&#9;&#9;&#9;&#9;setButtons[i].Selected = false
&#9;&#9;&#9;&#9;setButtons[i].BackgroundTransparency = 1
&#9;&#9;&#9;&#9;setButtons[i].TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;setButtons[i].BackgroundColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;local function populateSetsFrame()
&#9;&#9;local currRow = 0
&#9;&#9;for i = 1, #userCategoryButtons do
&#9;&#9;&#9;local button = userCategoryButtons[i]
&#9;&#9;&#9;button.Visible = true
&#9;&#9;&#9;button.Position = UDim2.new(0,5,0,currRow * button.Size.Y.Offset)
&#9;&#9;&#9;button.Parent = setGui.SetPanel.Sets.SetsLists
&#9;&#9;&#9;
&#9;&#9;&#9;if i == 1 then -- we will have this selected by default, so show it
&#9;&#9;&#9;&#9;button.Selected = true
&#9;&#9;&#9;&#9;button.BackgroundColor3 = Color3.new(0,204/255,0)
&#9;&#9;&#9;&#9;button.TextColor3 = Color3.new(0,0,0)
&#9;&#9;&#9;&#9;button.BackgroundTransparency = 0
&#9;&#9;&#9;end

&#9;&#9;&#9;button.MouseEnter:connect(function()
&#9;&#9;&#9;&#9;if not button.Selected then
&#9;&#9;&#9;&#9;&#9;button.BackgroundTransparency = 0
&#9;&#9;&#9;&#9;&#9;button.TextColor3 = Color3.new(0,0,0)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;&#9;button.MouseLeave:connect(function()
&#9;&#9;&#9;&#9;if not button.Selected then
&#9;&#9;&#9;&#9;&#9;button.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;&#9;button.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;&#9;button.MouseButton1Click:connect(function()
&#9;&#9;&#9;&#9;resetAllSetButtonSelection()
&#9;&#9;&#9;&#9;button.Selected = not button.Selected
&#9;&#9;&#9;&#9;button.BackgroundColor3 = Color3.new(0,204/255,0)
&#9;&#9;&#9;&#9;button.TextColor3 = Color3.new(0,0,0)
&#9;&#9;&#9;&#9;button.BackgroundTransparency = 0
&#9;&#9;&#9;&#9;selectSet(button, button.Text, userCategoryButtons[i].SetId.Value, 0)
&#9;&#9;&#9;end)

&#9;&#9;&#9;currRow = currRow + 1
&#9;&#9;end

&#9;&#9;local buttons =  setGui.SetPanel.Sets.SetsLists:GetChildren()

&#9;&#9;-- set first category as loaded for default
&#9;&#9;if buttons then
&#9;&#9;&#9;for i = 1, #buttons do
&#9;&#9;&#9;&#9;if buttons[i]:IsA(&quot;TextButton&quot;) then
&#9;&#9;&#9;&#9;&#9;selectSet(buttons[i], buttons[i].Text, userCategoryButtons[i].SetId.Value, 0)
&#9;&#9;&#9;&#9;&#9;selectCategory(userCategoryButtons)
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;setGui = createSetGui()
&#9;waterGui, waterTypeChangedEvent = createWaterGui()
&#9;waterGui.Position = UDim2.new(0,55,0,0)
&#9;waterGui.Parent = setGui
&#9;setGui.Changed:connect(function(prop) -- this resizes the preview image to always be the right size
&#9;&#9;if prop == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;handleResize()
&#9;&#9;&#9;setSetIndex()
&#9;&#9;end
&#9;end)
&#9;
&#9;local scrollFrame, controlFrame = t.CreateTrueScrollingFrame()
&#9;scrollFrame.Size = UDim2.new(0.54,0,0.85,0)
&#9;scrollFrame.Position = UDim2.new(0.24,0,0.085,0)
&#9;scrollFrame.Name = &quot;ItemsFrame&quot;
&#9;scrollFrame.ZIndex = 6
&#9;scrollFrame.Parent = setGui.SetPanel
&#9;scrollFrame.BackgroundTransparency = 1

&#9;drillDownSetZIndex(controlFrame,7)

&#9;controlFrame.Parent = setGui.SetPanel
&#9;controlFrame.Position = UDim2.new(0.76, 5, 0, 0)

&#9;local debounce = false
&#9;controlFrame.ScrollBottom.Changed:connect(function(prop)
&#9;&#9;if controlFrame.ScrollBottom.Value == true then
&#9;&#9;&#9;if debounce then return end
&#9;&#9;&#9;debounce = true
&#9;&#9;&#9;&#9;loadSectionOfItems(setGui, rows, columns)
&#9;&#9;&#9;debounce = false
&#9;&#9;end
&#9;end)

&#9;local userData = {}
&#9;for id = 1, #userIdsForSets do
&#9;&#9;local newUserData = game:GetService(&quot;InsertService&quot;):GetUserSets(userIdsForSets[id])
&#9;&#9;if newUserData and #newUserData &gt; 2 then
&#9;&#9;&#9;-- start at #3 to skip over My Decals and My Models for each account
&#9;&#9;&#9;for category = 3, #newUserData do
&#9;&#9;&#9;&#9;if newUserData[category].Name == &quot;High Scalability&quot; then -- we want high scalability parts to show first
&#9;&#9;&#9;&#9;&#9;table.insert(userData,1,newUserData[category])
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;table.insert(userData, newUserData[category])
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;
&#9;end
&#9;if userData then
&#9;&#9;userCategoryButtons = processCategory(userData)
&#9;end

&#9;rows = math.floor(setGui.SetPanel.ItemsFrame.AbsoluteSize.Y/buttonHeight)
&#9;columns = math.floor(setGui.SetPanel.ItemsFrame.AbsoluteSize.X/buttonWidth)

&#9;populateSetsFrame()

&#9;insertPanelCloseCon = setGui.SetPanel.CancelButton.MouseButton1Click:connect(function()
&#9;&#9;setGui.SetPanel.Visible = false
&#9;&#9;if dialogClosed then dialogClosed() end
&#9;end)
&#9;
&#9;local setVisibilityFunction = function(visible)
&#9;&#9;if visible then
&#9;&#9;&#9;setGui.SetPanel.Visible = true
&#9;&#9;else
&#9;&#9;&#9;setGui.SetPanel.Visible = false
&#9;&#9;end
&#9;end
&#9;
&#9;local getVisibilityFunction = function()
&#9;&#9;if setGui then
&#9;&#9;&#9;if setGui:FindFirstChild(&quot;SetPanel&quot;) then
&#9;&#9;&#9;&#9;return setGui.SetPanel.Visible
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;
&#9;&#9;return false
&#9;end
&#9;
&#9;return setGui, setVisibilityFunction, getVisibilityFunction, waterTypeChangedEvent
end

t.CreateTerrainMaterialSelector = function(size,position)
&#9;local terrainMaterialSelectionChanged = Instance.new(&quot;BindableEvent&quot;)
&#9;terrainMaterialSelectionChanged.Name = &quot;TerrainMaterialSelectionChanged&quot;

&#9;local selectedButton = nil

&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;frame.Name = &quot;TerrainMaterialSelector&quot;
&#9;if size then
&#9;&#9;frame.Size = size
&#9;else
&#9;&#9;frame.Size = UDim2.new(0, 245, 0, 230)
&#9;end
&#9;if position then
&#9;&#9;frame.Position = position
&#9;end
&#9;frame.BorderSizePixel = 0
&#9;frame.BackgroundColor3 = Color3.new(0,0,0)
&#9;frame.Active = true

&#9;terrainMaterialSelectionChanged.Parent = frame

&#9;local waterEnabled = true -- todo: turn this on when water is ready

&#9;local materialToImageMap = {}
&#9;local materialNames = {&quot;Grass&quot;, &quot;Sand&quot;, &quot;Brick&quot;, &quot;Granite&quot;, &quot;Asphalt&quot;, &quot;Iron&quot;, &quot;Aluminum&quot;, &quot;Gold&quot;, &quot;Plank&quot;, &quot;Log&quot;, &quot;Gravel&quot;, &quot;Cinder Block&quot;, &quot;Stone Wall&quot;, &quot;Concrete&quot;, &quot;Plastic (red)&quot;, &quot;Plastic (blue)&quot;}
&#9;if waterEnabled then
&#9;&#9;table.insert(materialNames,&quot;Water&quot;)
&#9;end
&#9;local currentMaterial = 1

&#9;function getEnumFromName(choice)
&#9;&#9;if choice == &quot;Grass&quot; then return 1 end
&#9;&#9;if choice == &quot;Sand&quot; then return 2 end 
&#9;&#9;if choice == &quot;Erase&quot; then return 0 end
&#9;&#9;if choice == &quot;Brick&quot; then return 3 end
&#9;&#9;if choice == &quot;Granite&quot; then return 4 end
&#9;&#9;if choice == &quot;Asphalt&quot; then return 5 end
&#9;&#9;if choice == &quot;Iron&quot; then return 6 end
&#9;&#9;if choice == &quot;Aluminum&quot; then return 7 end
&#9;&#9;if choice == &quot;Gold&quot; then return 8 end
&#9;&#9;if choice == &quot;Plank&quot; then return 9 end
&#9;&#9;if choice == &quot;Log&quot; then return 10 end
&#9;&#9;if choice == &quot;Gravel&quot; then return 11 end
&#9;&#9;if choice == &quot;Cinder Block&quot; then return 12 end
&#9;&#9;if choice == &quot;Stone Wall&quot; then return 13 end
&#9;&#9;if choice == &quot;Concrete&quot; then return 14 end
&#9;&#9;if choice == &quot;Plastic (red)&quot; then return 15 end
&#9;&#9;if choice == &quot;Plastic (blue)&quot; then return 16 end
&#9;&#9;if choice == &quot;Water&quot; then return 17 end
&#9;end

&#9;function getNameFromEnum(choice)
&#9;&#9;if choice == Enum.CellMaterial.Grass or choice == 1 then return &quot;Grass&quot;end
&#9;&#9;if choice == Enum.CellMaterial.Sand or choice == 2 then return &quot;Sand&quot; end 
&#9;&#9;if choice == Enum.CellMaterial.Empty or choice == 0 then return &quot;Erase&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Brick or choice == 3 then return &quot;Brick&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Granite or choice == 4 then return &quot;Granite&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Asphalt or choice == 5 then return &quot;Asphalt&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Iron or choice == 6 then return &quot;Iron&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Aluminum or choice == 7 then return &quot;Aluminum&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Gold or choice == 8 then return &quot;Gold&quot; end
&#9;&#9;if choice == Enum.CellMaterial.WoodPlank or choice == 9 then return &quot;Plank&quot; end
&#9;&#9;if choice == Enum.CellMaterial.WoodLog or choice == 10 then return &quot;Log&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Gravel or choice == 11 then return &quot;Gravel&quot; end
&#9;&#9;if choice == Enum.CellMaterial.CinderBlock or choice == 12 then return &quot;Cinder Block&quot; end
&#9;&#9;if choice == Enum.CellMaterial.MossyStone or choice == 13 then return &quot;Stone Wall&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Cement or choice == 14 then return &quot;Concrete&quot; end
&#9;&#9;if choice == Enum.CellMaterial.RedPlastic or choice == 15 then return &quot;Plastic (red)&quot; end
&#9;&#9;if choice == Enum.CellMaterial.BluePlastic or choice == 16 then return &quot;Plastic (blue)&quot; end

&#9;&#9;if waterEnabled then
&#9;&#9;&#9;if choice == Enum.CellMaterial.Water or choice == 17 then return &quot;Water&quot; end
&#9;&#9;end
&#9;end


&#9;local function updateMaterialChoice(choice)
&#9;&#9;currentMaterial = getEnumFromName(choice)
&#9;&#9;terrainMaterialSelectionChanged:Fire(currentMaterial)
&#9;end

&#9;-- we so need a better way to do this
&#9;for i,v in pairs(materialNames) do
&#9;&#9;materialToImageMap[v] = {}
&#9;&#9;if v == &quot;Grass&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=56563112&quot;
&#9;&#9;elseif v == &quot;Sand&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=62356652&quot;
&#9;&#9;elseif v == &quot;Brick&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=65961537&quot;
&#9;&#9;elseif v == &quot;Granite&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67532153&quot;
&#9;&#9;elseif v == &quot;Asphalt&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67532038&quot;
&#9;&#9;elseif v == &quot;Iron&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67532093&quot;
&#9;&#9;elseif v == &quot;Aluminum&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67531995&quot;
&#9;&#9;elseif v == &quot;Gold&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67532118&quot;
&#9;&#9;elseif v == &quot;Plastic (red)&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67531848&quot;
&#9;&#9;elseif v == &quot;Plastic (blue)&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67531924&quot;
&#9;&#9;elseif v == &quot;Plank&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67532015&quot;
&#9;&#9;elseif v == &quot;Log&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67532051&quot;
&#9;&#9;elseif v == &quot;Gravel&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67532206&quot;
&#9;&#9;elseif v == &quot;Cinder Block&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67532103&quot;
&#9;&#9;elseif v == &quot;Stone Wall&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67531804&quot;
&#9;&#9;elseif v == &quot;Concrete&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=67532059&quot;
&#9;&#9;elseif v == &quot;Water&quot; then materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=81407474&quot;
&#9;&#9;else materialToImageMap[v].Regular = &quot;http://www.roblox.com/asset/?id=66887593&quot; -- fill in the rest here!!
&#9;&#9;end
&#9;end

&#9;local scrollFrame, scrollUp, scrollDown, recalculateScroll = t.CreateScrollingFrame(nil,&quot;grid&quot;)
&#9;scrollFrame.Size = UDim2.new(0.85,0,1,0)
&#9;scrollFrame.Position = UDim2.new(0,0,0,0)
&#9;scrollFrame.Parent = frame

&#9;scrollUp.Parent = frame
&#9;scrollUp.Visible = true
&#9;scrollUp.Position = UDim2.new(1,-19,0,0)

&#9;scrollDown.Parent = frame
&#9;scrollDown.Visible = true
&#9;scrollDown.Position = UDim2.new(1,-19,1,-17)

&#9;local function goToNewMaterial(buttonWrap, materialName)
&#9;&#9;updateMaterialChoice(materialName)
&#9;&#9;buttonWrap.BackgroundTransparency = 0
&#9;&#9;selectedButton.BackgroundTransparency = 1
&#9;&#9;selectedButton = buttonWrap
&#9;end

&#9;local function createMaterialButton(name)&#9;
&#9;&#9;local buttonWrap = Instance.new(&quot;TextButton&quot;)
&#9;&#9;buttonWrap.Text = &quot;&quot;
&#9;&#9;buttonWrap.Size = UDim2.new(0,32,0,32)
&#9;&#9;buttonWrap.BackgroundColor3 = Color3.new(1,1,1)
&#9;&#9;buttonWrap.BorderSizePixel = 0
&#9;&#9;buttonWrap.BackgroundTransparency = 1
&#9;&#9;buttonWrap.AutoButtonColor = false
&#9;&#9;buttonWrap.Name = tostring(name)
&#9;&#9;
&#9;&#9;local imageButton = Instance.new(&quot;ImageButton&quot;)
&#9;&#9;imageButton.AutoButtonColor = false
&#9;&#9;imageButton.BackgroundTransparency = 1
&#9;&#9;imageButton.Size = UDim2.new(0,30,0,30)
&#9;&#9;imageButton.Position = UDim2.new(0,1,0,1)
&#9;&#9;imageButton.Name = tostring(name)
&#9;&#9;imageButton.Parent = buttonWrap
&#9;&#9;imageButton.Image = materialToImageMap[name].Regular

&#9;&#9;local enumType = Instance.new(&quot;NumberValue&quot;)
&#9;&#9;enumType.Name = &quot;EnumType&quot;
&#9;&#9;enumType.Parent = buttonWrap
&#9;&#9;enumType.Value = 0
&#9;&#9;
&#9;&#9;imageButton.MouseEnter:connect(function()
&#9;&#9;&#9;buttonWrap.BackgroundTransparency = 0
&#9;&#9;end)
&#9;&#9;imageButton.MouseLeave:connect(function()
&#9;&#9;&#9;if selectedButton ~= buttonWrap then
&#9;&#9;&#9;&#9;buttonWrap.BackgroundTransparency = 1
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;&#9;imageButton.MouseButton1Click:connect(function()
&#9;&#9;&#9;if selectedButton ~= buttonWrap then
&#9;&#9;&#9;&#9;goToNewMaterial(buttonWrap, tostring(name))
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;&#9;
&#9;&#9;return buttonWrap 
&#9;end

&#9;for i = 1, #materialNames do
&#9;&#9;local imageButton = createMaterialButton(materialNames[i])
&#9;&#9;
&#9;&#9;if materialNames[i] == &quot;Grass&quot; then -- always start with grass as the default
&#9;&#9;&#9;selectedButton = imageButton
&#9;&#9;&#9;imageButton.BackgroundTransparency = 0
&#9;&#9;end
&#9;&#9;
&#9;&#9;imageButton.Parent = scrollFrame
&#9;end

&#9;local forceTerrainMaterialSelection = function(newMaterialType)
&#9;&#9;if not newMaterialType then return end
&#9;&#9;if currentMaterial == newMaterialType then return end

&#9;&#9;local matName = getNameFromEnum(newMaterialType)
&#9;&#9;local buttons = scrollFrame:GetChildren()
&#9;&#9;for i = 1, #buttons do
&#9;&#9;&#9;if buttons[i].Name == &quot;Plastic (blue)&quot; and matName == &quot;Plastic (blue)&quot; then goToNewMaterial(buttons[i],matName) return end
&#9;&#9;&#9;if buttons[i].Name == &quot;Plastic (red)&quot; and matName == &quot;Plastic (red)&quot; then goToNewMaterial(buttons[i],matName) return end
&#9;&#9;&#9;if string.find(buttons[i].Name, matName) then
&#9;&#9;&#9;&#9;goToNewMaterial(buttons[i],matName)
&#9;&#9;&#9;&#9;return
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;frame.Changed:connect(function ( prop )
&#9;&#9;if prop == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;recalculateScroll()
&#9;&#9;end
&#9;end)

&#9;recalculateScroll()
&#9;return frame, terrainMaterialSelectionChanged, forceTerrainMaterialSelection
end

t.CreateLoadingFrame = function(name,size,position)
&#9;game:GetService(&quot;ContentProvider&quot;):Preload(&quot;http://www.roblox.com/asset/?id=35238053&quot;)

&#9;local loadingFrame = Instance.new(&quot;Frame&quot;)
&#9;loadingFrame.Name = &quot;LoadingFrame&quot;
&#9;loadingFrame.Style = Enum.FrameStyle.RobloxRound

&#9;if size then loadingFrame.Size = size
&#9;else loadingFrame.Size = UDim2.new(0,300,0,160) end
&#9;if position then loadingFrame.Position = position 
&#9;else loadingFrame.Position = UDim2.new(0.5, -150, 0.5,-80) end

&#9;local loadingBar = Instance.new(&quot;Frame&quot;)
&#9;loadingBar.Name = &quot;LoadingBar&quot;
&#9;loadingBar.BackgroundColor3 = Color3.new(0,0,0)
&#9;loadingBar.BorderColor3 = Color3.new(79/255,79/255,79/255)
&#9;loadingBar.Position = UDim2.new(0,0,0,41)
&#9;loadingBar.Size = UDim2.new(1,0,0,30)
&#9;loadingBar.Parent = loadingFrame

&#9;&#9;local loadingGreenBar = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;loadingGreenBar.Name = &quot;LoadingGreenBar&quot;
&#9;&#9;loadingGreenBar.Image = &quot;http://www.roblox.com/asset/?id=35238053&quot;
&#9;&#9;loadingGreenBar.Position = UDim2.new(0,0,0,0)
&#9;&#9;loadingGreenBar.Size = UDim2.new(0,0,1,0)
&#9;&#9;loadingGreenBar.Visible = false
&#9;&#9;loadingGreenBar.Parent = loadingBar

&#9;&#9;local loadingPercent = Instance.new(&quot;TextLabel&quot;)
&#9;&#9;loadingPercent.Name = &quot;LoadingPercent&quot;
&#9;&#9;loadingPercent.BackgroundTransparency = 1
&#9;&#9;loadingPercent.Position = UDim2.new(0,0,1,0)
&#9;&#9;loadingPercent.Size = UDim2.new(1,0,0,14)
&#9;&#9;loadingPercent.Font = Enum.Font.Arial
&#9;&#9;loadingPercent.Text = &quot;0%&quot;
&#9;&#9;loadingPercent.FontSize = Enum.FontSize.Size14
&#9;&#9;loadingPercent.TextColor3 = Color3.new(1,1,1)
&#9;&#9;loadingPercent.Parent = loadingBar

&#9;local cancelButton = Instance.new(&quot;TextButton&quot;)
&#9;cancelButton.Name = &quot;CancelButton&quot;
&#9;cancelButton.Position = UDim2.new(0.5,-60,1,-40)
&#9;cancelButton.Size = UDim2.new(0,120,0,40)
&#9;cancelButton.Font = Enum.Font.Arial
&#9;cancelButton.FontSize = Enum.FontSize.Size18
&#9;cancelButton.TextColor3 = Color3.new(1,1,1)
&#9;cancelButton.Text = &quot;Cancel&quot;
&#9;cancelButton.Style = Enum.ButtonStyle.RobloxButton
&#9;cancelButton.Parent = loadingFrame

&#9;local loadingName = Instance.new(&quot;TextLabel&quot;)
&#9;loadingName.Name = &quot;loadingName&quot;
&#9;loadingName.BackgroundTransparency = 1
&#9;loadingName.Size = UDim2.new(1,0,0,18)
&#9;loadingName.Position = UDim2.new(0,0,0,2)
&#9;loadingName.Font = Enum.Font.Arial
&#9;loadingName.Text = name
&#9;loadingName.TextColor3 = Color3.new(1,1,1)
&#9;loadingName.TextStrokeTransparency = 1
&#9;loadingName.FontSize = Enum.FontSize.Size18
&#9;loadingName.Parent = loadingFrame

&#9;local cancelButtonClicked = Instance.new(&quot;BindableEvent&quot;)
&#9;cancelButtonClicked.Name = &quot;CancelButtonClicked&quot;
&#9;cancelButtonClicked.Parent = cancelButton
&#9;cancelButton.MouseButton1Click:connect(function()
&#9;&#9;cancelButtonClicked:Fire()
&#9;end)

&#9;local updateLoadingGuiPercent = function(percent, tweenAction, tweenLength)
&#9;&#9;if percent and type(percent) ~= &quot;number&quot; then
&#9;&#9;&#9;error(&quot;updateLoadingGuiPercent expects number as argument, got&quot;,type(percent),&quot;instead&quot;)
&#9;&#9;end

&#9;&#9;local newSize = nil
&#9;&#9;if percent &lt; 0 then
&#9;&#9;&#9;newSize = UDim2.new(0,0,1,0)
&#9;&#9;elseif percent &gt; 1 then
&#9;&#9;&#9;newSize = UDim2.new(1,0,1,0)
&#9;&#9;else
&#9;&#9;&#9;newSize = UDim2.new(percent,0,1,0)
&#9;&#9;end

&#9;&#9;if tweenAction then
&#9;&#9;&#9;if not tweenLength then
&#9;&#9;&#9;&#9;error(&quot;updateLoadingGuiPercent is set to tween new percentage, but got no tween time length! Please pass this in as third argument&quot;)
&#9;&#9;&#9;end

&#9;&#9;&#9;if (newSize.X.Scale &gt; 0) then
&#9;&#9;&#9;&#9;loadingGreenBar.Visible = true
&#9;&#9;&#9;&#9;loadingGreenBar:TweenSize(&#9;newSize,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Enum.EasingDirection.Out,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Enum.EasingStyle.Quad,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;tweenLength,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;true)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;loadingGreenBar:TweenSize(&#9;newSize,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Enum.EasingDirection.Out,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Enum.EasingStyle.Quad,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;tweenLength,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;true,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;function() 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;if (newSize.X.Scale &lt; 0) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;loadingGreenBar.Visible = false
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;end

&#9;&#9;else
&#9;&#9;&#9;loadingGreenBar.Size = newSize
&#9;&#9;&#9;loadingGreenBar.Visible = (newSize.X.Scale &gt; 0)
&#9;&#9;end
&#9;end

&#9;loadingGreenBar.Changed:connect(function(prop)
&#9;&#9;if prop == &quot;Size&quot; then
&#9;&#9;&#9;loadingPercent.Text = tostring( math.ceil(loadingGreenBar.Size.X.Scale * 100) ) .. &quot;%&quot;
&#9;&#9;end
&#9;end)

&#9;return loadingFrame, updateLoadingGuiPercent, cancelButtonClicked
end

t.CreatePluginFrame = function (name,size,position,scrollable,parent)
&#9;function createMenuButton(size,position,text,fontsize,name,parent)
&#9;&#9;local button = Instance.new(&quot;TextButton&quot;,parent)
&#9;&#9;button.AutoButtonColor = false
&#9;&#9;button.Name = name
&#9;&#9;button.BackgroundTransparency = 1
&#9;&#9;button.Position = position
&#9;&#9;button.Size = size
&#9;&#9;button.Font = Enum.Font.ArialBold
&#9;&#9;button.FontSize = fontsize
&#9;&#9;button.Text =  text
&#9;&#9;button.TextColor3 = Color3.new(1,1,1)
&#9;&#9;button.BorderSizePixel = 0
&#9;&#9;button.BackgroundColor3 = Color3.new(20/255,20/255,20/255)

&#9;&#9;button.MouseEnter:connect(function ( )
&#9;&#9;&#9;if button.Selected then return end
&#9;&#9;&#9;button.BackgroundTransparency = 0
&#9;&#9;end)
&#9;&#9;button.MouseLeave:connect(function ( )
&#9;&#9;&#9;if button.Selected then return end
&#9;&#9;&#9;button.BackgroundTransparency = 1
&#9;&#9;end)

&#9;&#9;return button

&#9;end

&#9;local dragBar = Instance.new(&quot;Frame&quot;,parent)
&#9;dragBar.Name = tostring(name) .. &quot;DragBar&quot;
&#9;dragBar.BackgroundColor3 = Color3.new(39/255,39/255,39/255)
&#9;dragBar.BorderColor3 = Color3.new(0,0,0)
&#9;if size then
&#9;&#9;dragBar.Size =  UDim2.new(size.X.Scale,size.X.Offset,0,20)  + UDim2.new(0,20,0,0)
&#9;else
&#9;&#9;dragBar.Size = UDim2.new(0,183,0,20)
&#9;end
&#9;if position then
&#9;&#9;dragBar.Position = position
&#9;end
&#9;dragBar.Active = true
&#9;dragBar.Draggable = true
&#9;--dragBar.Visible = false
&#9;dragBar.MouseEnter:connect(function (  )
&#9;&#9;dragBar.BackgroundColor3 = Color3.new(49/255,49/255,49/255)
&#9;end)
&#9;dragBar.MouseLeave:connect(function (  )
&#9;&#9;dragBar.BackgroundColor3 = Color3.new(39/255,39/255,39/255)
&#9;end)

&#9;-- plugin name label
&#9;local pluginNameLabel = Instance.new(&quot;TextLabel&quot;,dragBar)
&#9;pluginNameLabel.Name = &quot;BarNameLabel&quot;
&#9;pluginNameLabel.Text = &quot; &quot; .. tostring(name)
&#9;pluginNameLabel.TextColor3 = Color3.new(1,1,1)
&#9;pluginNameLabel.TextStrokeTransparency = 0
&#9;pluginNameLabel.Size = UDim2.new(1,0,1,0)
&#9;pluginNameLabel.Font = Enum.Font.ArialBold
&#9;pluginNameLabel.FontSize = Enum.FontSize.Size18
&#9;pluginNameLabel.TextXAlignment = Enum.TextXAlignment.Left
&#9;pluginNameLabel.BackgroundTransparency = 1

&#9;-- close button
&#9;local closeButton = createMenuButton(UDim2.new(0,15,0,17),UDim2.new(1,-16,0.5,-8),&quot;X&quot;,Enum.FontSize.Size14,&quot;CloseButton&quot;,dragBar)
&#9;local closeEvent = Instance.new(&quot;BindableEvent&quot;)
&#9;closeEvent.Name = &quot;CloseEvent&quot;
&#9;closeEvent.Parent = closeButton
&#9;closeButton.MouseButton1Click:connect(function ()
&#9;&#9;closeEvent:Fire()
&#9;&#9;closeButton.BackgroundTransparency = 1
&#9;end)

&#9;-- help button
&#9;local helpButton = createMenuButton(UDim2.new(0,15,0,17),UDim2.new(1,-51,0.5,-8),&quot;?&quot;,Enum.FontSize.Size14,&quot;HelpButton&quot;,dragBar)
&#9;local helpFrame = Instance.new(&quot;Frame&quot;,dragBar)
&#9;helpFrame.Name = &quot;HelpFrame&quot;
&#9;helpFrame.BackgroundColor3 = Color3.new(0,0,0)
&#9;helpFrame.Size = UDim2.new(0,300,0,552)
&#9;helpFrame.Position = UDim2.new(1,5,0,0)
&#9;helpFrame.Active = true
&#9;helpFrame.BorderSizePixel = 0
&#9;helpFrame.Visible = false

&#9;helpButton.MouseButton1Click:connect(function(  )
&#9;&#9;helpFrame.Visible = not helpFrame.Visible
&#9;&#9;if helpFrame.Visible then
&#9;&#9;&#9;helpButton.Selected = true
&#9;&#9;&#9;helpButton.BackgroundTransparency = 0
&#9;&#9;&#9;local screenGui = getScreenGuiAncestor(helpFrame)
&#9;&#9;&#9;if screenGui then
&#9;&#9;&#9;&#9;if helpFrame.AbsolutePosition.X + helpFrame.AbsoluteSize.X &gt; screenGui.AbsoluteSize.X then --position on left hand side
&#9;&#9;&#9;&#9;&#9;helpFrame.Position = UDim2.new(0,-5 - helpFrame.AbsoluteSize.X,0,0)
&#9;&#9;&#9;&#9;else -- position on right hand side
&#9;&#9;&#9;&#9;&#9;helpFrame.Position = UDim2.new(1,5,0,0)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;helpFrame.Position = UDim2.new(1,5,0,0)
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;helpButton.Selected = false
&#9;&#9;&#9;helpButton.BackgroundTransparency = 1
&#9;&#9;end
&#9;end)

&#9;local minimizeButton = createMenuButton(UDim2.new(0,16,0,17),UDim2.new(1,-34,0.5,-8),&quot;-&quot;,Enum.FontSize.Size14,&quot;MinimizeButton&quot;,dragBar)
&#9;minimizeButton.TextYAlignment = Enum.TextYAlignment.Top

&#9;local minimizeFrame = Instance.new(&quot;Frame&quot;,dragBar)
&#9;minimizeFrame.Name = &quot;MinimizeFrame&quot;
&#9;minimizeFrame.BackgroundColor3 = Color3.new(73/255,73/255,73/255)
&#9;minimizeFrame.BorderColor3 = Color3.new(0,0,0)
&#9;minimizeFrame.Position = UDim2.new(0,0,1,0)
&#9;if size then
&#9;&#9;minimizeFrame.Size =  UDim2.new(size.X.Scale,size.X.Offset,0,50) + UDim2.new(0,20,0,0)
&#9;else
&#9;&#9;minimizeFrame.Size = UDim2.new(0,183,0,50)
&#9;end
&#9;minimizeFrame.Visible = false

&#9;local minimizeBigButton = Instance.new(&quot;TextButton&quot;,minimizeFrame)
&#9;minimizeBigButton.Position = UDim2.new(0.5,-50,0.5,-20)
&#9;minimizeBigButton.Name = &quot;MinimizeButton&quot;
&#9;minimizeBigButton.Size = UDim2.new(0,100,0,40)
&#9;minimizeBigButton.Style = Enum.ButtonStyle.RobloxButton
&#9;minimizeBigButton.Font = Enum.Font.ArialBold
&#9;minimizeBigButton.FontSize = Enum.FontSize.Size18
&#9;minimizeBigButton.TextColor3 = Color3.new(1,1,1)
&#9;minimizeBigButton.Text = &quot;Show&quot;

&#9;local separatingLine = Instance.new(&quot;Frame&quot;,dragBar)
&#9;separatingLine.Name = &quot;SeparatingLine&quot;
&#9;separatingLine.BackgroundColor3 = Color3.new(115/255,115/255,115/255)
&#9;separatingLine.BorderSizePixel = 0
&#9;separatingLine.Position = UDim2.new(1,-18,0.5,-7)
&#9;separatingLine.Size = UDim2.new(0,1,0,14)

&#9;local otherSeparatingLine = separatingLine:clone()
&#9;otherSeparatingLine.Position = UDim2.new(1,-35,0.5,-7)
&#9;otherSeparatingLine.Parent = dragBar

&#9;local widgetContainer = Instance.new(&quot;Frame&quot;,dragBar)
&#9;widgetContainer.Name = &quot;WidgetContainer&quot;
&#9;widgetContainer.BackgroundTransparency = 1
&#9;widgetContainer.Position = UDim2.new(0,0,1,0)
&#9;widgetContainer.BorderColor3 = Color3.new(0,0,0)
&#9;if not scrollable then
&#9;&#9;widgetContainer.BackgroundTransparency = 0
&#9;&#9;widgetContainer.BackgroundColor3 = Color3.new(72/255,72/255,72/255)
&#9;end

&#9;if size then
&#9;&#9;if scrollable then
&#9;&#9;&#9;widgetContainer.Size = size
&#9;&#9;else
&#9;&#9;&#9;widgetContainer.Size = UDim2.new(0,dragBar.AbsoluteSize.X,size.Y.Scale,size.Y.Offset)
&#9;&#9;end
&#9;else
&#9;&#9;if scrollable then
&#9;&#9;&#9;widgetContainer.Size = UDim2.new(0,163,0,400)
&#9;&#9;else
&#9;&#9;&#9;widgetContainer.Size = UDim2.new(0,dragBar.AbsoluteSize.X,0,400)
&#9;&#9;end
&#9;end
&#9;if position then
&#9;&#9;widgetContainer.Position = position + UDim2.new(0,0,0,20)
&#9;end

&#9;local frame,control,verticalDragger = nil
&#9;if scrollable then
&#9;&#9;--frame for widgets
&#9;&#9;frame,control = t.CreateTrueScrollingFrame()
&#9;&#9;frame.Size = UDim2.new(1, 0, 1, 0)
&#9;&#9;frame.BackgroundColor3 = Color3.new(72/255,72/255,72/255)
&#9;&#9;frame.BorderColor3 = Color3.new(0,0,0)
&#9;&#9;frame.Active = true
&#9;&#9;frame.Parent = widgetContainer
&#9;&#9;control.Parent = dragBar
&#9;&#9;control.BackgroundColor3 = Color3.new(72/255,72/255,72/255)
&#9;&#9;control.BorderSizePixel = 0
&#9;&#9;control.BackgroundTransparency = 0
&#9;&#9;control.Position = UDim2.new(1,-21,1,1)
&#9;&#9;if size then
&#9;&#9;&#9;control.Size = UDim2.new(0,21,size.Y.Scale,size.Y.Offset)
&#9;&#9;else
&#9;&#9;&#9;control.Size = UDim2.new(0,21,0,400)
&#9;&#9;end
&#9;&#9;control:FindFirstChild(&quot;ScrollDownButton&quot;).Position = UDim2.new(0,0,1,-20)

&#9;&#9;local fakeLine = Instance.new(&quot;Frame&quot;,control)
&#9;&#9;fakeLine.Name = &quot;FakeLine&quot;
&#9;&#9;fakeLine.BorderSizePixel = 0
&#9;&#9;fakeLine.BackgroundColor3 = Color3.new(0,0,0)
&#9;&#9;fakeLine.Size = UDim2.new(0,1,1,1)
&#9;&#9;fakeLine.Position = UDim2.new(1,0,0,0)

&#9;&#9;verticalDragger = Instance.new(&quot;TextButton&quot;,widgetContainer)
&#9;&#9;verticalDragger.ZIndex = 2
&#9;&#9;verticalDragger.AutoButtonColor = false
&#9;&#9;verticalDragger.Name = &quot;VerticalDragger&quot;
&#9;&#9;verticalDragger.BackgroundColor3 = Color3.new(50/255,50/255,50/255)
&#9;&#9;verticalDragger.BorderColor3 = Color3.new(0,0,0)
&#9;&#9;verticalDragger.Size = UDim2.new(1,20,0,20)
&#9;&#9;verticalDragger.Position = UDim2.new(0,0,1,0)
&#9;&#9;verticalDragger.Active = true
&#9;&#9;verticalDragger.Text = &quot;&quot;

&#9;&#9;local scrubFrame = Instance.new(&quot;Frame&quot;,verticalDragger)
&#9;&#9;scrubFrame.Name = &quot;ScrubFrame&quot;
&#9;&#9;scrubFrame.BackgroundColor3 = Color3.new(1,1,1)
&#9;&#9;scrubFrame.BorderSizePixel = 0
&#9;&#9;scrubFrame.Position = UDim2.new(0.5,-5,0.5,0)
&#9;&#9;scrubFrame.Size = UDim2.new(0,10,0,1)
&#9;&#9;scrubFrame.ZIndex = 5
&#9;&#9;local scrubTwo = scrubFrame:clone()
&#9;&#9;scrubTwo.Position = UDim2.new(0.5,-5,0.5,-2)
&#9;&#9;scrubTwo.Parent = verticalDragger
&#9;&#9;local scrubThree = scrubFrame:clone()
&#9;&#9;scrubThree.Position = UDim2.new(0.5,-5,0.5,2)
&#9;&#9;scrubThree.Parent = verticalDragger

&#9;&#9;local areaSoak = Instance.new(&quot;TextButton&quot;,getScreenGuiAncestor(parent))
&#9;&#9;areaSoak.Name = &quot;AreaSoak&quot;
&#9;&#9;areaSoak.Size = UDim2.new(1,0,1,0)
&#9;&#9;areaSoak.BackgroundTransparency = 1
&#9;&#9;areaSoak.BorderSizePixel = 0
&#9;&#9;areaSoak.Text = &quot;&quot;
&#9;&#9;areaSoak.ZIndex = 10
&#9;&#9;areaSoak.Visible = false
&#9;&#9;areaSoak.Active = true

&#9;&#9;local draggingVertical = false
&#9;&#9;local startYPos = nil
&#9;&#9;verticalDragger.MouseEnter:connect(function ()
&#9;&#9;&#9;verticalDragger.BackgroundColor3 = Color3.new(60/255,60/255,60/255)
&#9;&#9;end)
&#9;&#9;verticalDragger.MouseLeave:connect(function ()
&#9;&#9;&#9;verticalDragger.BackgroundColor3 = Color3.new(50/255,50/255,50/255)
&#9;&#9;end)
&#9;&#9;verticalDragger.MouseButton1Down:connect(function(x,y)
&#9;&#9;&#9;draggingVertical = true
&#9;&#9;&#9;areaSoak.Visible = true
&#9;&#9;&#9;startYPos = y
&#9;&#9;end)
&#9;&#9;areaSoak.MouseButton1Up:connect(function (  )
&#9;&#9;&#9;draggingVertical = false
&#9;&#9;&#9;areaSoak.Visible = false
&#9;&#9;end)
&#9;&#9;areaSoak.MouseMoved:connect(function(x,y)
&#9;&#9;&#9;if not draggingVertical then return end

&#9;&#9;&#9;local yDelta = y - startYPos
&#9;&#9;&#9;if not control.ScrollDownButton.Visible and yDelta &gt; 0 then
&#9;&#9;&#9;&#9;return
&#9;&#9;&#9;end

&#9;&#9;&#9;if (widgetContainer.Size.Y.Offset + yDelta) &lt; 150 then
&#9;&#9;&#9;&#9;widgetContainer.Size = UDim2.new(widgetContainer.Size.X.Scale, widgetContainer.Size.X.Offset,widgetContainer.Size.Y.Scale,150)
&#9;&#9;&#9;&#9;control.Size = UDim2.new (0,21,0,150)
&#9;&#9;&#9;&#9;return 
&#9;&#9;&#9;end 

&#9;&#9;&#9;startYPos = y

&#9;&#9;&#9;if widgetContainer.Size.Y.Offset + yDelta &gt;= 0 then
&#9;&#9;&#9;&#9;widgetContainer.Size = UDim2.new(widgetContainer.Size.X.Scale, widgetContainer.Size.X.Offset,widgetContainer.Size.Y.Scale,widgetContainer.Size.Y.Offset + yDelta)
&#9;&#9;&#9;&#9;control.Size = UDim2.new(0,21,0,control.Size.Y.Offset + yDelta )
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;end

&#9;local function switchMinimize()
&#9;&#9;minimizeFrame.Visible = not minimizeFrame.Visible
&#9;&#9;if scrollable then
&#9;&#9;&#9;frame.Visible = not frame.Visible
&#9;&#9;&#9;verticalDragger.Visible = not verticalDragger.Visible
&#9;&#9;&#9;control.Visible = not control.Visible
&#9;&#9;else
&#9;&#9;&#9;widgetContainer.Visible = not widgetContainer.Visible
&#9;&#9;end

&#9;&#9;if minimizeFrame.Visible then
&#9;&#9;&#9;minimizeButton.Text = &quot;+&quot;
&#9;&#9;else
&#9;&#9;&#9;minimizeButton.Text = &quot;-&quot;
&#9;&#9;end
&#9;end

&#9;minimizeBigButton.MouseButton1Click:connect(function (  )
&#9;&#9;switchMinimize()
&#9;end)

&#9;minimizeButton.MouseButton1Click:connect(function(  )
&#9;&#9;switchMinimize()
&#9;end)

&#9;if scrollable then
&#9;&#9;return dragBar, frame, helpFrame, closeEvent
&#9;else
&#9;&#9;return dragBar, widgetContainer, helpFrame, closeEvent
&#9;end
end

t.Help = 
&#9;function(funcNameOrFunc) 
&#9;&#9;--input argument can be a string or a function.  Should return a description (of arguments and expected side effects)
&#9;&#9;if funcNameOrFunc == &quot;CreatePropertyDropDownMenu&quot; or funcNameOrFunc == t.CreatePropertyDropDownMenu then
&#9;&#9;&#9;return &quot;Function CreatePropertyDropDownMenu.  &quot; ..
&#9;&#9;&#9;&#9;   &quot;Arguments: (instance, propertyName, enumType).  &quot; .. 
&#9;&#9;&#9;&#9;   &quot;Side effect: returns a container with a drop-down-box that is linked to the &apos;property&apos; field of &apos;instance&apos; which is of type &apos;enumType&apos;&quot; 
&#9;&#9;end 
&#9;&#9;if funcNameOrFunc == &quot;CreateDropDownMenu&quot; or funcNameOrFunc == t.CreateDropDownMenu then
&#9;&#9;&#9;return &quot;Function CreateDropDownMenu.  &quot; .. 
&#9;&#9;&#9;       &quot;Arguments: (items, onItemSelected).  &quot; .. 
&#9;&#9;&#9;&#9;   &quot;Side effect: Returns 2 results, a container to the gui object and a &apos;updateSelection&apos; function for external updating.  The container is a drop-down-box created around a list of items&quot; 
&#9;&#9;end 
&#9;&#9;if funcNameOrFunc == &quot;CreateMessageDialog&quot; or funcNameOrFunc == t.CreateMessageDialog then
&#9;&#9;&#9;return &quot;Function CreateMessageDialog.  &quot; .. 
&#9;&#9;&#9;       &quot;Arguments: (title, message, buttons). &quot; .. 
&#9;&#9;&#9;       &quot;Side effect: Returns a gui object of a message box with &apos;title&apos; and &apos;message&apos; as passed in.  &apos;buttons&apos; input is an array of Tables contains a &apos;Text&apos; and &apos;Function&apos; field for the text/callback of each button&quot;
&#9;&#9;end&#9;&#9;
&#9;&#9;if funcNameOrFunc == &quot;CreateStyledMessageDialog&quot; or funcNameOrFunc == t.CreateStyledMessageDialog then
&#9;&#9;&#9;return &quot;Function CreateStyledMessageDialog.  &quot; .. 
&#9;&#9;&#9;       &quot;Arguments: (title, message, style, buttons). &quot; .. 
&#9;&#9;&#9;       &quot;Side effect: Returns a gui object of a message box with &apos;title&apos; and &apos;message&apos; as passed in.  &apos;buttons&apos; input is an array of Tables contains a &apos;Text&apos; and &apos;Function&apos; field for the text/callback of each button, &apos;style&apos; is a string, either Error, Notify or Confirm&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;GetFontHeight&quot; or funcNameOrFunc == t.GetFontHeight then
&#9;&#9;&#9;return &quot;Function GetFontHeight.  &quot; .. 
&#9;&#9;&#9;       &quot;Arguments: (font, fontSize). &quot; .. 
&#9;&#9;&#9;       &quot;Side effect: returns the size in pixels of the given font + fontSize&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;LayoutGuiObjects&quot; or funcNameOrFunc == t.LayoutGuiObjects then
&#9;&#9;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;CreateScrollingFrame&quot; or funcNameOrFunc == t.CreateScrollingFrame then
&#9;&#9;&#9;return &quot;Function CreateScrollingFrame.  &quot; .. 
&#9;&#9;&#9;   &quot;Arguments: (orderList, style) &quot; .. 
&#9;&#9;&#9;   &quot;Side effect: returns 4 objects, (scrollFrame, scrollUpButton, scrollDownButton, recalculateFunction).  &apos;scrollFrame&apos; can be filled with GuiObjects.  It will lay them out and allow scrollUpButton/scrollDownButton to interact with them.  Orderlist is optional (and specifies the order to layout the children.  Without orderlist, it uses the children order. style is also optional, and allows for a &apos;grid&apos; styling if style is passed &apos;grid&apos; as a string.  recalculateFunction can be called when a relayout is needed (when orderList changes)&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;CreateTrueScrollingFrame&quot; or funcNameOrFunc == t.CreateTrueScrollingFrame then
&#9;&#9;&#9;return &quot;Function CreateTrueScrollingFrame.  &quot; .. 
&#9;&#9;&#9;   &quot;Arguments: (nil) &quot; .. 
&#9;&#9;&#9;   &quot;Side effect: returns 2 objects, (scrollFrame, controlFrame).  &apos;scrollFrame&apos; can be filled with GuiObjects, and they will be clipped if not inside the frame&apos;s bounds. controlFrame has children scrollup and scrolldown, as well as a slider.  controlFrame can be parented to any guiobject and it will readjust itself to fit.&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;AutoTruncateTextObject&quot; or funcNameOrFunc == t.AutoTruncateTextObject then
&#9;&#9;&#9;return &quot;Function AutoTruncateTextObject.  &quot; .. 
&#9;&#9;&#9;   &quot;Arguments: (textLabel) &quot; .. 
&#9;&#9;&#9;   &quot;Side effect: returns 2 objects, (textLabel, changeText).  The &apos;textLabel&apos; input is modified to automatically truncate text (with ellipsis), if it gets too small to fit.  &apos;changeText&apos; is a function that can be used to change the text, it takes 1 string as an argument&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;CreateSlider&quot; or funcNameOrFunc == t.CreateSlider then
&#9;&#9;&#9;return &quot;Function CreateSlider.  &quot; ..
&#9;&#9;&#9;&#9;&quot;Arguments: (steps, width, position) &quot; ..
&#9;&#9;&#9;&#9;&quot;Side effect: returns 2 objects, (sliderGui, sliderPosition).  The &apos;steps&apos; argument specifies how many different positions the slider can hold along the bar.  &apos;width&apos; specifies in pixels how wide the bar should be (modifiable afterwards if desired). &apos;position&apos; argument should be a UDim2 for slider positioning. &apos;sliderPosition&apos; is an IntValue whose current .Value specifies the specific step the slider is currently on.&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;CreateSliderNew&quot; or funcNameOrFunc == t.CreateSliderNew then
&#9;&#9;&#9;return &quot;Function CreateSliderNew.  &quot; ..
&#9;&#9;&#9;&#9;&quot;Arguments: (steps, width, position) &quot; ..
&#9;&#9;&#9;&#9;&quot;Side effect: returns 2 objects, (sliderGui, sliderPosition).  The &apos;steps&apos; argument specifies how many different positions the slider can hold along the bar.  &apos;width&apos; specifies in pixels how wide the bar should be (modifiable afterwards if desired). &apos;position&apos; argument should be a UDim2 for slider positioning. &apos;sliderPosition&apos; is an IntValue whose current .Value specifies the specific step the slider is currently on.&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;CreateLoadingFrame&quot; or funcNameOrFunc == t.CreateLoadingFrame then
&#9;&#9;&#9;return &quot;Function CreateLoadingFrame.  &quot; ..
&#9;&#9;&#9;&#9;&quot;Arguments: (name, size, position) &quot; ..
&#9;&#9;&#9;&#9;&quot;Side effect: Creates a gui that can be manipulated to show progress for a particular action.  Name appears above the loading bar, and size and position are udim2 values (both size and position are optional arguments).  Returns 3 arguments, the first being the gui created. The second being updateLoadingGuiPercent, which is a bindable function.  This function takes one argument (two optionally), which should be a number between 0 and 1, representing the percentage the loading gui should be at.  The second argument to this function is a boolean value that if set to true will tween the current percentage value to the new percentage value, therefore our third argument is how long this tween should take. Our third returned argument is a BindableEvent, that when fired means that someone clicked the cancel button on the dialog.&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;CreateTerrainMaterialSelector&quot; or funcNameOrFunc == t.CreateTerrainMaterialSelector then
&#9;&#9;&#9;return &quot;Function CreateTerrainMaterialSelector.  &quot; ..
&#9;&#9;&#9;&#9;&quot;Arguments: (size, position) &quot; ..
&#9;&#9;&#9;&#9;&quot;Side effect: Size and position are UDim2 values that specifies the selector&apos;s size and position.  Both size and position are optional arguments. This method returns 3 objects (terrainSelectorGui, terrainSelected, forceTerrainSelection).  terrainSelectorGui is just the gui object that we generate with this function, parent it as you like. TerrainSelected is a BindableEvent that is fired whenever a new terrain type is selected in the gui.  ForceTerrainSelection is a function that takes an argument of Enum.CellMaterial and will force the gui to show that material as currently selected.&quot;
&#9;&#9;end
&#9;end
&#9;


local RbxGui

local ADMINS =
{
iagoMAO = &quot;rbxasset://textures/ui/admins/iagoMAO.png&quot;,
winsupermario1234 = &quot;rbxasset://textures/ui/admins/winsupermario1234.png&quot;,
Carrot = &quot;rbxasset://textures/ui/admins/carrot.png&quot;,
coke = &quot;rbxasset://textures/ui/admins/coke.png&quot;,
khanglegos = &quot;rbxasset://textures/ui/admins/khanglegos.png&quot;,
QuackIAttack = &quot;rbxasset://textures/ui/admins/QuackIAttack.png&quot;,
romulo27 = &quot;rbxasset://textures/ui/admins/romulo27.png&quot;,
TheLivingBee = &quot;rbxasset://textures/ui/admins/TheLivingBee.png&quot;,
OliverA = 1,
kinery = 1,
Peridorky =1,
Bitl = 1,
Raymonf = &quot;rbxasset://textures/ui/admins/Raymonf.png&quot;,
}

local localTesting = true

local screen = script.Parent
local screenResizeCon = nil

local friendWord = &quot;Friend&quot;
local friendWordLowercase = &quot;friend&quot;

local elementNames = {}
local elementNameToElement = {}

local privilegeOwner = 255
local privilegeAdmin = 240
local privilegeMember = 128
local privilegeVisitor = 10
local privilegeBanned = 0

local inContextMenu = false
local contextMenu3d = false

local bigEasingStyle = Enum.EasingStyle.Back
local smallEasingStyle = Enum.EasingStyle.Quart

local personalServerContextAdded = false
local personalServerPlace = false
local success = pcall(function() personalServerPlace = game.IsPersonalServer end)
if not success then
&#9;personalServerPlace = false
end

local friendRequestBlacklist = {}
local otherPlayerBlacklist = {}

local currentSortName = &quot;&quot;

local function waitForChild(instance, name)
&#9;while not instance:FindFirstChild(name) do
&#9;&#9;instance.ChildAdded:wait()
&#9;end
end

local function waitForProperty(instance, prop)
&#9;while not instance[prop] do
&#9;&#9;instance.Changed:wait()
&#9;end
end

local function Color3I(r,g,b)
  return Color3.new(r/255,g/255,b/255)
end

function robloxLock(instance)
end

function ArrayRemove(t, obj)
&#9;for i, obj2 in ipairs(t) do
&#9;&#9;if obj == obj2 then
&#9;&#9;&#9;table.remove(t, i)
&#9;&#9;&#9;return true
&#9;&#9;end
&#9;end
&#9;return false
end

local function getPlayers()
&#9;local result = {}
   local players = game:GetService(&quot;Players&quot;):GetChildren()
&#9;if players then
&#9;&#9;for i, player in ipairs(players) do
&#9;&#9;&#9;if player:IsA(&quot;Player&quot;) then 
&#9;&#9;&#9;&#9;table.insert(result, player)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;return result
end

local brickColorTable = {}
for i = 0, 63 do
   brickColorTable[BrickColor.palette(i).Name] = BrickColor.palette(i).Color
end

local function remapColor(i, j)
  brickColorTable[BrickColor.palette(i).Name] = BrickColor.palette(j).Color
end

remapColor(13, 12)
remapColor(14, 12)
remapColor(15, 12)
remapColor(61, 29)
remapColor(63, 62)
remapColor(56, 50)
remapColor(45, 53)
remapColor(51, 20)
remapColor(4, 20)
remapColor(59, 35)
remapColor(60, 29)

local function getColor(brickColor)
  if brickColorTable[brickColor.Name] then
&#9;return brickColorTable[brickColor.Name] 
  else
    return brickColor.Color;
  end
end



local function getTeams()
&#9;local result = {}
&#9;local teams = game:GetService(&quot;Teams&quot;):GetChildren()
&#9;for i, team in ipairs(teams) do
&#9;&#9;if team:IsA(&quot;Team&quot;) then 
&#9;&#9;&#9;table.insert(result, team)
&#9;&#9;end
&#9;end
&#9;return result&#9;
end

local supportFriends = false
local currentBoardType = &quot;PlayerList&quot;
local currentStatCount = 0

local createBoardsFunction = nil


local playerTable = {}
local teamTable = {}
local teamColorTable&#9;= {}

local removePlayerFunction = nil
local recreatePlayerFunction = nil
local addPlayerFunction = function(player)
&#9;if recreatePlayerFunction then
&#9;&#9;recreatePlayerFunction(player)
&#9;end
end
local sortPlayerListsFunction = nil

local minimizedState = nil
local bigWindowImposter = nil
local smallWindowPosition = UDim2.new(0, -20, 0,5)
local smallWindowSize = UDim2.new(1,0,1,0)
local bigWindowSize = UDim2.new(0.6,0,0.6,0) 
local bigWindowPosition = UDim2.new(.2, 0, .2,0)

local smallWindowHeaderYSize = 32

local debounceTeamsChanged = false

local currentWindowState = &quot;Small&quot;
local previousWindowState = nil
local transitionWindowsFunction = nil

local container = nil
local topRightTrayContainer = nil

local playerContextMenu = nil
local contextMenuElements = {}
local updateContextMenuItems = nil

local function addContextMenuLabel(getText1, getText2, isVisible)
&#9;local t = {}
&#9;t.Type = &quot;Label&quot;
&#9;t.GetText1 = getText1
&#9;t.GetText2 = getText2
&#9;t.IsVisible = isVisible
&#9;table.insert(contextMenuElements, t)
end
local function addContextMenuButton(text, isVisible, isActive, doIt)
&#9;local t = {}
&#9;t.Text = text
&#9;t.Type = &quot;Button&quot;
&#9;t.IsVisible = isVisible
&#9;t.IsActive = isActive
&#9;t.DoIt = doIt
&#9;table.insert(contextMenuElements, t)
end

local function getFriendStatus(player)
&#9;if player == game.Players.LocalPlayer then
&#9;&#9;return Enum.FriendStatus.NotFriend
&#9;else
&#9;&#9;local success, result = pcall(function() return game.Players.LocalPlayer:GetFriendStatus(player) end)
&#9;&#9;if success then
&#9;&#9;&#9;return result
&#9;&#9;else
&#9;&#9;&#9;return Enum.FriendStatus.NotFriend
&#9;&#9;end
&#9;end
end


local function getPrivilegeType(player)
&#9;local rank = player.PersonalServerRank
&#9;if rank &gt;= privilegeOwner then
&#9;&#9;return privilegeOwner
&#9;elseif rank &lt; privilegeOwner and rank &gt;= privilegeAdmin then
&#9;&#9;return privilegeAdmin
&#9;elseif rank &lt; privilegeAdmin and rank &gt;= privilegeMember then
&#9;&#9;return privilegeMember
&#9;elseif rank &lt; privilegeMember and rank &gt;= privilegeVisitor then
&#9;&#9;return privilegeVisitor
&#9;else
&#9;&#9;return privilegeBanned
&#9;end
end

--Populate the ContextMenus
addContextMenuLabel(
&#9;--GetText1
&#9;function(player) 
&#9;&#9;return &quot;Loading...&quot;
&#9;end,
&#9;--GetText2
&#9;nil,
&#9;--IsVisible
&#9;function(player) 
&#9;&#9;return getFriendStatus(player) == Enum.FriendStatus.Unknown
&#9;end)

addContextMenuButton(&quot;Send &quot; .. friendWord .. &quot; Request&quot;, 
&#9;--IsVisible
&#9;function(player) &#9;
&#9;&#9;return (not otherPlayerBlacklist[player]) and (getFriendStatus(player) == Enum.FriendStatus.NotFriend)
&#9;end, 
&#9;--IsActive
&#9;function(player) 
&#9;&#9;return true 
&#9;end, 
&#9;--DoIt?
&#9;function(player) 
&#9;&#9;otherPlayerBlacklist[player] = true
&#9;&#9;return game.Players.LocalPlayer:RequestFriendship(player)
&#9;end
)
addContextMenuButton(&quot;Un&quot; .. friendWordLowercase, 
&#9;--IsVisible
&#9;function(player) 
&#9;&#9;return getFriendStatus(player) == Enum.FriendStatus.Friend
&#9;end, 
&#9;--IsActive
&#9;function(player) 
&#9;&#9;return true 
&#9;end, 
&#9;--DoIt
&#9;function(player)
&#9;&#9;return game.Players.LocalPlayer:RevokeFriendship(player)
&#9;end
)
addContextMenuButton(&quot;Accept &quot; .. friendWord .. &quot; Request&quot;, 
&#9;--IsVisible
&#9;function(player) 
&#9;&#9;return (not friendRequestBlacklist[player]) and (getFriendStatus(player) == Enum.FriendStatus.FriendRequestReceived)
&#9;end, 
&#9;--IsActive
&#9;function(player) 
&#9;&#9;return true 
&#9;end, 
&#9;--DoIt
&#9;function(player)
&#9;&#9;return game.Players.LocalPlayer:RequestFriendship(player)
&#9;end
)

addContextMenuButton(&quot;Deny &quot; .. friendWord .. &quot; Request&quot;, 
&#9;--IsVisible
&#9;function(player) 
&#9;&#9;return getFriendStatus(player) == Enum.FriendStatus.FriendRequestReceived
&#9;end, 
&#9;--IsActive
&#9;function(player) 
&#9;&#9;return true 
&#9;end, 
&#9;--DoIt
&#9;function(player) 
&#9;&#9;friendRequestBlacklist[player] = true
&#9;&#9;return game.Players.LocalPlayer:RevokeFriendship(player)
&#9;end
)

addContextMenuButton(&quot;Cancel &quot; .. friendWord .. &quot; Request&quot;, 
&#9;--IsVisible
&#9;function(player) 
&#9;&#9;return false -- disable cancel request for now (can lead to griefing)
&#9;&#9;--return getFriendStatus(player) == Enum.FriendStatus.FriendRequestSent
&#9;end, 
&#9;--IsActive
&#9;function(player) 
&#9;&#9;return true 
&#9;end, 
&#9;--DoIt
&#9;function(player) 
&#9;&#9;otherPlayerBlacklist[player] = false
&#9;&#9;return game.Players.LocalPlayer:RevokeFriendship(player)
&#9;end
)

function addPersonalServerContext()
&#9;if personalServerContextAdded then return end
&#9;personalServerContextAdded = true
&#9;addContextMenuButton(&quot;Ban&quot;, 
&#9;&#9;--IsVisible
&#9;&#9;function(player)
&#9;&#9;&#9;return ( getPrivilegeType(game.Players.LocalPlayer) &gt;= privilegeAdmin and (getPrivilegeType(player) &lt; privilegeAdmin) )
&#9;&#9;end, 
&#9;&#9;--IsActive
&#9;&#9;function(player) 
&#9;&#9;&#9;return true 
&#9;&#9;end, 
&#9;&#9;--DoIt
&#9;&#9;function(player)
&#9;&#9;&#9;player.PersonalServerRank = privilegeBanned
&#9;&#9;&#9;return true
&#9;&#9;end
&#9;)
&#9;addContextMenuButton(&quot;Promote to Visitor&quot;, 
&#9;&#9;--IsVisible
&#9;&#9;function(player)
&#9;&#9;&#9;return ( getPrivilegeType(game.Players.LocalPlayer) &gt;= privilegeAdmin ) and ( getPrivilegeType(player) == privilegeBanned )
&#9;&#9;end, 
&#9;&#9;--IsActive
&#9;&#9;function(player) 
&#9;&#9;&#9;return true 
&#9;&#9;end, 
&#9;&#9;--DoIt
&#9;&#9;function(player)
&#9;&#9;&#9;game:GetService(&quot;PersonalServerService&quot;):Promote(player) 
&#9;&#9;&#9;return true
&#9;&#9;end
&#9;)
&#9;addContextMenuButton(&quot;Promote to Member&quot;, 
&#9;&#9;--IsVisible
&#9;&#9;function(player)
&#9;&#9;&#9;return ( getPrivilegeType(game.Players.LocalPlayer) &gt;= privilegeAdmin ) and ( getPrivilegeType(player) == privilegeVisitor )
&#9;&#9;end, 
&#9;&#9;--IsActive
&#9;&#9;function(player) 
&#9;&#9;&#9;return true 
&#9;&#9;end, 
&#9;&#9;--DoIt
&#9;&#9;function(player)
&#9;&#9;&#9;game:GetService(&quot;PersonalServerService&quot;):Promote(player) 
&#9;&#9;&#9;return true
&#9;&#9;end
&#9;)
&#9;addContextMenuButton(&quot;Promote to Admin&quot;, 
&#9;&#9;--IsVisible
&#9;&#9;function(player)
&#9;&#9;&#9;return ( getPrivilegeType(game.Players.LocalPlayer) == privilegeOwner ) and ( getPrivilegeType(player) == privilegeMember )
&#9;&#9;end, 
&#9;&#9;--IsActive
&#9;&#9;function(player) 
&#9;&#9;&#9;return true 
&#9;&#9;end, 
&#9;&#9;--DoIt
&#9;&#9;function(player)
&#9;&#9;&#9;game:GetService(&quot;PersonalServerService&quot;):Promote(player) 
&#9;&#9;&#9;return true
&#9;&#9;end
&#9;)
&#9;addContextMenuButton(&quot;Demote to Member&quot;, 
&#9;&#9;--IsVisible
&#9;&#9;function(player)
&#9;&#9;&#9;return ( getPrivilegeType(game.Players.LocalPlayer) == privilegeOwner ) and ( getPrivilegeType(player) == privilegeAdmin )
&#9;&#9;end, 
&#9;&#9;--IsActive
&#9;&#9;function(player) 
&#9;&#9;&#9;return true 
&#9;&#9;end, 
&#9;&#9;--DoIt
&#9;&#9;function(player)
&#9;&#9;&#9;game:GetService(&quot;PersonalServerService&quot;):Demote(player) 
&#9;&#9;&#9;return true
&#9;&#9;end
&#9;)
&#9;addContextMenuButton(&quot;Demote to Visitor&quot;, 
&#9;&#9;--IsVisible
&#9;&#9;function(player)
&#9;&#9;&#9;return ( getPrivilegeType(game.Players.LocalPlayer) &gt;= privilegeAdmin ) and ( getPrivilegeType(player) == privilegeMember )
&#9;&#9;end, 
&#9;&#9;--IsActive
&#9;&#9;function(player) 
&#9;&#9;&#9;return true 
&#9;&#9;end, 
&#9;&#9;--DoIt
&#9;&#9;function(player)
&#9;&#9;&#9;game:GetService(&quot;PersonalServerService&quot;):Demote(player) 
&#9;&#9;&#9;return true
&#9;&#9;end
&#9;)
end

local function setupBuildToolManagement()
&#9;local buildToolManagerAssetId = 64164692
&#9;game:GetService(&quot;ScriptContext&quot;):AddCoreScript(buildToolManagerAssetId,game.Players.LocalPlayer,&quot;BuildToolManager&quot;)
end


local function getStatColumns(players)
&#9;for i, player in ipairs(players) do
&#9;&#9;local leaderstats = player:FindFirstChild(&quot;leaderstats&quot;)
&#9;&#9;if leaderstats then
&#9;&#9;&#9;local stats = {} 
&#9;&#9;&#9;local children = leaderstats:GetChildren()
&#9;&#9;&#9;if children then
&#9;&#9;&#9;&#9;for i, stat in ipairs(children) do
&#9;&#9;&#9;&#9;&#9;if stat:IsA(&quot;IntValue&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;table.insert(stats, stat)
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;--TODO: This should check for IntValue only but current ScoreHud does not
&#9;&#9;&#9;&#9;&#9;&#9;table.insert(stats, stat)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;return stats
&#9;&#9;end&#9;&#9;
&#9;end
&#9;return nil
end

local function determineBoardType()
&#9;local players = getPlayers()
&#9;
&#9;local foundLeaderstats = false
&#9;local numStats = 0
&#9;local foundTeam = false

&#9;local stats = getStatColumns(players)
&#9;if stats then
&#9;&#9;foundLeaderstats = true
&#9;&#9;numStats = #stats
&#9;end

&#9;for i, player in ipairs(players) do
&#9;&#9;if not foundTeam then
&#9;&#9;&#9;if not player.Neutral then
&#9;&#9;&#9;&#9;foundTeam = true
&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;if foundLeaderstats and foundTeam then
&#9;&#9;return &quot;TeamScore&quot;, numStats
&#9;elseif foundLeaderstats then
&#9;&#9;return &quot;PlayerScore&quot;, numStats
&#9;elseif foundTeam then
&#9;&#9;return &quot;TeamList&quot;, numStats
&#9;else
&#9;&#9;return &quot;PlayerList&quot;, numStats
&#9;end
end

local function toggleBigWindow()
&#9;if container == nil then
&#9;&#9;return
&#9;end

&#9;if currentWindowState == &quot;Big&quot; then
&#9;&#9;--Hide it
&#9;&#9;if previousWindowState == nil or previousWindowState == &quot;Big&quot; or previousWindowState == &quot;None&quot; then
&#9;&#9;&#9;transitionWindowsFunction(&quot;None&quot;)
&#9;&#9;else
&#9;&#9;&#9;transitionWindowsFunction(&quot;Small&quot;)
&#9;&#9;end
&#9;else
&#9;&#9;previousWindowState = currentWindowState
&#9;&#9;transitionWindowsFunction(&quot;Big&quot;)
&#9;end
end
local previousBigPlayerList = nil
local function rebuildBoard(owner, boardType, numStats)
&#9;if topRightTrayContainer == nil then
&#9;&#9;topRightTrayContainer = owner:FindFirstChild(&quot;PlayerListTopRightFrame&quot;)
&#9;&#9;if topRightTrayContainer == nil then
&#9;&#9;&#9;topRightTrayContainer = Instance.new(&quot;Frame&quot;)
&#9;&#9;&#9;topRightTrayContainer.Name = &quot;PlayerListTopRightFrame&quot;
&#9;&#9;&#9;topRightTrayContainer.BackgroundTransparency = 1
&#9;&#9;&#9;topRightTrayContainer.Size = UDim2.new(0.2, 16, 0.42, 16)
&#9;&#9;&#9;topRightTrayContainer.Position = UDim2.new(0.8, 0, 0, 0)
&#9;&#9;&#9;topRightTrayContainer.Parent = container
&#9;&#9;end
&#9;end
&#9;if minimizedState == nil then
&#9;&#9;minimizedState = Instance.new(&quot;Frame&quot;)
&#9;&#9;minimizedState.Name = &quot;MinimizedPlayerlist&quot;
&#9;&#9;minimizedState.BackgroundTransparency = 1
&#9;&#9;minimizedState.Position = UDim2.new(1, -166, 0,0)
&#9;&#9;minimizedState.Size = UDim2.new(0, 151, 0, 30)
&#9;&#9;
&#9;&#9;playerListButton = Instance.new(&quot;ImageButton&quot;)
&#9;&#9;playerListButton.Name = &quot;GoSmallButton&quot;
&#9;&#9;playerListButton.Image = &quot;rbxasset://textures/ui/playerlist_hidden_small.png&quot;
&#9;&#9;playerListButton.BackgroundTransparency = 1
&#9;&#9;playerListButton.Size = UDim2.new(0.0, 35, 0, 30)
&#9;&#9;playerListButton.Position = UDim2.new(1, -35, 0, 0)
&#9;&#9;playerListButton.MouseButton1Click:connect(
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;transitionWindowsFunction(&quot;Small&quot;)
&#9;&#9;&#9;end)
&#9;&#9;playerListButton.Parent = minimizedState

&#9;&#9;minimizedState.Visible = false
&#9;&#9;robloxLock(minimizedState)
&#9;&#9;minimizedState.Parent = topRightTrayContainer
&#9;end
&#9;if bigWindowImposter == nil then
&#9;&#9;bigWindowImposter = owner:FindFirstChild(&quot;BigPlayerListWindowImposter&quot;)
&#9;&#9;if bigWindowImposter == nil then
&#9;&#9;&#9;bigWindowImposter = Instance.new(&quot;Frame&quot;)
&#9;&#9;&#9;bigWindowImposter.Name = &quot;BigPlayerListWindowImposter&quot;
&#9;&#9;&#9;bigWindowImposter.Visible = false
&#9;&#9;&#9;bigWindowImposter.BackgroundColor3 = Color3.new(0,0,0)
&#9;&#9;&#9;bigWindowImposter.BackgroundTransparency = 0.7
&#9;&#9;&#9;bigWindowImposter.BorderSizePixel = 0
&#9;&#9;&#9;bigWindowImposter.Size = UDim2.new(0.4, 7, 0.4, 7)
&#9;&#9;&#9;bigWindowImposter.Position = UDim2.new(0.3, 0, 0.3, 0)
&#9;&#9;&#9;robloxLock(bigWindowImposter)
&#9;&#9;&#9;bigWindowImposter.Parent = container
&#9;&#9;end
&#9;end
&#9;if container == nil or container ~= owner then
&#9;&#9;container = owner

&#9;&#9;topRightTrayContainer.Parent = container
&#9;&#9;bigWindowImposter.Parent = container
&#9;end

&#9;local smallVisible = true
&#9;local bigVisible = false
&#9;if container then
&#9;&#9;if topRightTrayContainer then
&#9;&#9;&#9;--Delete the old boards
&#9;&#9;&#9;if topRightTrayContainer:FindFirstChild(&quot;SmallPlayerlist&quot;) then
&#9;&#9;&#9;&#9;smallVisible = topRightTrayContainer.SmallPlayerlist.Visible
&#9;&#9;&#9;&#9;topRightTrayContainer.SmallPlayerlist.Parent = nil
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;if container:FindFirstChild(&quot;BigPlayerlist&quot;) then
&#9;&#9;&#9;bigVisible = container.BigPlayerlist.Visible or (previousBigPlayerList ~= nil)
&#9;&#9;&#9;container.BigPlayerlist.Parent = nil
&#9;&#9;&#9;if previousBigPlayerList ~= nil then
&#9;&#9;&#9;&#9;pcall(function() game.GuiService:RemoveCenterDialog(previousBigPlayerList) end)
&#9;&#9;&#9;&#9;previousBigPlayerList = nil
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;local smallBoard, bigBoard = createBoardsFunction(boardType, numStats)
&#9;if smallBoard then
&#9;&#9;smallBoard.Visible = smallVisible
&#9;&#9;smallBoard.Parent = topRightTrayContainer
&#9;&#9;recalculateSmallPlayerListSize(smallBoard)
&#9;end
&#9;if bigBoard then
&#9;&#9;if bigVisible then
&#9;&#9;&#9;previousBigPlayerList = bigBoard
&#9;&#9;&#9;local centerDialogSupported, msg = pcall(function() game.GuiService:AddCenterDialog(previousBigPlayerList, Enum.CenterDialogType.PlayerInitiatedDialog, 
&#9;&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;&#9;previousBigPlayerList.Visible = true
&#9;&#9;&#9;&#9;end,
&#9;&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;&#9;previousBigPlayerList.Visible = false
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;end)
&#9;&#9;&#9;bigBoard.Visible = bigVisible
&#9;&#9;else
&#9;&#9;&#9;bigBoard.Visible = false
&#9;&#9;end
&#9;&#9;bigBoard.Parent = container
&#9;end
&#9;return container
end

function recalculateSmallPlayerListSize(smallPlayerList)
end


local function showBigPlayerWindow()
&#9;if container:FindFirstChild(&quot;BigPlayerlist&quot;) then
&#9;&#9;if container.BigPlayerlist.Visible then
&#9;&#9;&#9;return
&#9;&#9;end
&#9;end
&#9;
&#9;bigWindowImposter.Visible = true
&#9;bigWindowImposter:TweenSizeAndPosition(bigWindowSize, bigWindowPosition, Enum.EasingDirection.Out, bigEasingStyle, 0.3, true,
&#9;&#9;function(state)
&#9;&#9;&#9;if state == Enum.TweenStatus.Completed then 
&#9;&#9;&#9;&#9;bigWindowImposter.Visible = false 
&#9;&#9;&#9;&#9;if container:FindFirstChild(&quot;BigPlayerlist&quot;) then
&#9;&#9;&#9;&#9;&#9;container.BigPlayerlist.Visible = true
&#9;&#9;&#9;&#9;end&#9;&#9;
&#9;&#9;&#9;end
&#9;&#9;end)
end

local function hideBigPlayerWindow(completed)
&#9;if playerContextMenu then
&#9;&#9;playerContextMenu.Visible = false
&#9;end
&#9;
&#9;if container:FindFirstChild(&quot;BigPlayerlist&quot;) then
&#9;&#9;if container.BigPlayerlist.Visible == false and bigWindowImposter.Visible == false then
&#9;&#9;&#9;if completed then
&#9;&#9;&#9;&#9;completed()
&#9;&#9;&#9;end
&#9;&#9;&#9;--Already completely hidden
&#9;&#9;&#9;return
&#9;&#9;end
&#9;&#9;container.BigPlayerlist.Visible = false
&#9;end

&#9;local completedFunction = completed
&#9;bigWindowImposter.Visible = true
&#9;bigWindowImposter:TweenSizeAndPosition(UDim2.new(0.4, 0, 0.4, 0), UDim2.new(0.3, 0, 0.3, 0), Enum.EasingDirection.In, Enum.EasingStyle.Quart, 0.15, true,
&#9;&#9;function(state) 
&#9;&#9;&#9;if state == Enum.TweenStatus.Completed then 
&#9;&#9;&#9;&#9;bigWindowImposter.Visible = false 
&#9;&#9;&#9;&#9;if completedFunction then
&#9;&#9;&#9;&#9;&#9;completedFunction()
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end)
end
local function hideSmallPlayerWindow(completed)
&#9;if playerContextMenu then
&#9;&#9;playerContextMenu.Visible = false
&#9;end
&#9;if topRightTrayContainer:FindFirstChild(&quot;SmallPlayerlist&quot;) then
&#9;&#9;local completedFunction = completed
&#9;&#9;if topRightTrayContainer.SmallPlayerlist.Visible then
&#9;&#9;&#9;topRightTrayContainer.SmallPlayerlist:TweenPosition(UDim2.new(1,0,smallWindowPosition.Y.Scale, smallWindowPosition.Y.Offset), Enum.EasingDirection.Out, smallEasingStyle, 0.3, true, 
&#9;&#9;&#9;&#9;function(state) 
&#9;&#9;&#9;&#9;&#9;if state == Enum.TweenStatus.Completed then 
&#9;&#9;&#9;&#9;&#9;&#9;if topRightTrayContainer:FindFirstChild(&quot;SmallPlayerlist&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;topRightTrayContainer.SmallPlayerlist.Visible = false
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;if completedFunction then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;completedFunction()
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;return
&#9;&#9;end
&#9;end
&#9;if completed then
&#9;&#9;completed()
&#9;end
end


transitionWindowsFunction = function(desiredState)
&#9;if desiredState == &quot;Big&quot; then
&#9;&#9;minimizedState.Visible = false
&#9;&#9;hideSmallPlayerWindow()
&#9;
&#9;&#9;if previousBigPlayerList ~= nil then
&#9;&#9;&#9;if previousBigPlayerList ~= container:FindFirstChild(&quot;BigPlayerlist&quot;) then
&#9;&#9;&#9;&#9;pcall(function() game.GuiService:RemoveCenterDialog(previousBigPlayerList) end)
&#9;&#9;&#9;&#9;previousBigPlayerList = nil
&#9;&#9;&#9;&#9;previousBigPlayerList = container:FindFirstChild(&quot;BigPlayerlist&quot;)
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;previousBigPlayerList = container:FindFirstChild(&quot;BigPlayerlist&quot;)
&#9;&#9;end

&#9;&#9;if previousBigPlayerList then
&#9;&#9;&#9;local firstShow = false
&#9;&#9;&#9;local centerDialogSupported, msg = pcall(function() game.GuiService:AddCenterDialog(previousBigPlayerList, Enum.CenterDialogType.PlayerInitiatedDialog, 
&#9;&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;&#9;if not firstShow then
&#9;&#9;&#9;&#9;&#9;&#9;showBigPlayerWindow()
&#9;&#9;&#9;&#9;&#9;&#9;firstShow = true
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;previousBigPlayerList.Visible = true
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end,
&#9;&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;&#9;if previousBigPlayerList then
&#9;&#9;&#9;&#9;&#9;&#9;previousBigPlayerList.Visible = false
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;end)
&#9;&#9;&#9;if centerDialogSupported == false then
&#9;&#9;&#9;&#9;print(&quot;Exception&quot;, msg)
&#9;&#9;&#9;&#9;showBigPlayerWindow()
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;showBigPlayerWindow()
&#9;&#9;end
&#9;&#9;currentWindowState = &quot;Big&quot;
&#9;elseif desiredState == &quot;Small&quot; then
&#9;&#9;minimizedState.Visible = false
&#9;&#9;if previousBigPlayerList ~= nil then
&#9;&#9;&#9;pcall(function() game.GuiService:RemoveCenterDialog(previousBigPlayerList) end)
&#9;&#9;&#9;previousBigPlayerList = nil
&#9;&#9;end
&#9;&#9;
&#9;&#9;hideBigPlayerWindow()
&#9;&#9;if topRightTrayContainer:FindFirstChild(&quot;SmallPlayerlist&quot;) then
&#9;&#9;&#9;if not topRightTrayContainer.SmallPlayerlist.Visible or topRightTrayContainer.SmallPlayerlist.Position ~= smallWindowPosition then
&#9;&#9;&#9;&#9;topRightTrayContainer.SmallPlayerlist.Visible = true
&#9;&#9;&#9;&#9;topRightTrayContainer.SmallPlayerlist:TweenPosition(smallWindowPosition, Enum.EasingDirection.Out, smallEasingStyle, 0.3, true)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;currentWindowState = &quot;Small&quot;
&#9;elseif desiredState == &quot;None&quot; then
&#9;&#9;if previousBigPlayerList ~= nil then
&#9;&#9;&#9;pcall(function() game.GuiService:RemoveCenterDialog(previousBigPlayerList) end)
&#9;&#9;&#9;previousBigPlayerList = nil
&#9;&#9;end
&#9;&#9;
&#9;&#9;local smallDone = false
&#9;&#9;local bigDone = false
&#9;&#9;hideSmallPlayerWindow(
&#9;&#9;&#9;function() 
&#9;&#9;&#9;&#9;smallDone = true 
&#9;&#9;&#9;&#9;if bigDone and smallDone then
&#9;&#9;&#9;&#9;&#9;minimizedState.Visible = true
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;hideBigPlayerWindow(&#9;&#9;&#9;
&#9;&#9;&#9;function() 
&#9;&#9;&#9;&#9;bigDone = true 
&#9;&#9;&#9;&#9;if bigDone and smallDone then
&#9;&#9;&#9;&#9;&#9;minimizedState.Visible = true
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)&#9;&#9;
&#9;&#9;currentWindowState = &quot;None&quot;
&#9;end
end

local function getStatValuesForPlayer(player)
&#9;local leaderstats = player:FindFirstChild(&quot;leaderstats&quot;)
&#9;if leaderstats then
&#9;&#9;local children = leaderstats:GetChildren()
&#9;&#9;if children then
&#9;&#9;&#9;local result = {}
&#9;&#9;&#9;--Just go based on position
&#9;&#9;&#9;for i, stat in ipairs(children) do
&#9;&#9;&#9;&#9;if stat:IsA(&quot;IntValue&quot;) then
&#9;&#9;&#9;&#9;&#9;table.insert(result, stat)
&#9;&#9;&#9;&#9;else 
&#9;&#9;&#9;&#9;&#9;table.insert(result, 0)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end

&#9;&#9;&#9;return result, leaderstats
&#9;&#9;end
&#9;end
&#9;return nil
end

--ChildAdded on Player (if it&apos;s name is &quot;leaderstats&quot;)

if UserSettings and LoadLibrary then

&#9;RbxGui,msg = t

&#9;local function createTeamName(name, color)
&#9;&#9;local fontHeight = 20
&#9;&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;&#9;frame.Name = &quot;Team-&quot; .. name
&#9;&#9;frame.BorderSizePixel = 0
&#9;&#9;frame.BackgroundTransparency = 0.5
&#9;&#9;frame.BackgroundColor3 = Color3.new(1,1,1)
&#9;&#9;frame.Size = UDim2.new(1, 0, 0, fontHeight)
&#9;&#9;frame.Position = UDim2.new(0,0,0,0)

&#9;&#9;local label = Instance.new(&quot;TextLabel&quot;)
&#9;&#9;label.Name = &quot;NameLabel&quot;
&#9;&#9;label.Text = &quot; &quot; .. name
&#9;&#9;label.Font = Enum.Font.ArialBold
&#9;&#9;label.FontSize = Enum.FontSize.Size18
&#9;&#9;label.Position = UDim2.new(0,0,0,0)
&#9;&#9;label.Size = UDim2.new(1,0,1,0)
&#9;&#9;label.TextColor3 = Color3.new(1,1,1)
&#9;&#9;label.BackgroundTransparency = 0.5
&#9;&#9;label.BackgroundColor3 = getColor(color)
&#9;&#9;label.BorderSizePixel = 0
&#9;&#9;label.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;
&#9;&#9;local changeFunc = nil
&#9;&#9;label, changeFunc = RbxGui.AutoTruncateTextObject(label)
&#9;&#9;label.Parent = frame
&#9;&#9;
&#9;&#9;return frame, changeFunc
&#9;end

&#9;local function getFriendStatusIcon(friendStatus)
&#9;&#9;if friendStatus == Enum.FriendStatus.Unknown or friendStatus == Enum.FriendStatus.NotFriend then
&#9;&#9;&#9;return nil
&#9;&#9;elseif friendStatus == Enum.FriendStatus.Friend then
&#9;&#9;&#9;return &quot;rbxasset://textures/ui/PlayerlistFriendIcon.png&quot;
&#9;&#9;elseif friendStatus == Enum.FriendStatus.FriendRequestSent then
&#9;&#9;&#9;return &quot;rbxasset://textures/ui/PlayerlistFriendRequestSentIcon.png&quot;
&#9;&#9;elseif friendStatus == Enum.FriendStatus.FriendRequestReceived then
&#9;&#9;&#9;return &quot;rbxasset://textures/ui/PlayerlistFriendRequestReceivedIcon.png&quot;
&#9;&#9;else
&#9;&#9;&#9;error(&quot;Unknown FriendStatus: &quot; .. friendStatus)
&#9;&#9;end
&#9;end

&#9;local function getMembershipTypeIcon(membershipType,playerName)
&#9;if ADMINS[playerName]~=nil then
&#9;&#9;if ADMINS[playerName] == 1 then
&#9;&#9;&#9;return &quot;rbxasset://textures/ui/admins/default.png&quot;
&#9;&#9;else
&#9;&#9;&#9;return ADMINS[playerName]
&#9;&#9;end
&#9;elseif membershipType == Enum.MembershipType.None then
&#9;&#9;return &quot;&quot;
&#9;elseif membershipType == Enum.MembershipType.BuildersClub then
&#9;&#9;return &quot;rbxasset://textures/ui/TinyBcIcon.png&quot;
&#9;elseif membershipType == Enum.MembershipType.TurboBuildersClub then
&#9;&#9;return &quot;rbxasset://textures/ui/TinyTbcIcon.png&quot;
&#9;elseif membershipType == Enum.MembershipType.OutrageousBuildersClub then
&#9;&#9;return &quot;rbxasset://textures/ui/TinyObcIcon.png&quot;
&#9;else
&#9;&#9;error(&quot;Unknown membershipType&quot; .. membershipType)
&#9;end


&#9;local function updatePlayerFriendStatus(nameObject, friendStatus)
&#9;&#9;local fontHeight = 20

&#9;&#9;local friendIconImage = getFriendStatusIcon(friendStatus)
&#9;&#9;nameObject.MembershipTypeLabel.FriendStatusLabel.Visible = (friendIconImage ~= nil)

&#9;&#9;if friendIconImage ~= nil then 
&#9;&#9;&#9;--Show friend icon
&#9;&#9;&#9;nameObject.MembershipTypeLabel.FriendStatusLabel.Image = friendIconImage
&#9;&#9;&#9;nameObject.NameLabel.Position =UDim2.new(0,2*fontHeight,0,1)
&#9;&#9;&#9;nameObject.NameLabel.Size = UDim2.new(1,-2*fontHeight,1,-2)
&#9;&#9;else
&#9;&#9;&#9;--Hide the friend icon
&#9;&#9;&#9;nameObject.NameLabel.Position = UDim2.new(0,fontHeight+1,0,1)
&#9;&#9;&#9;nameObject.NameLabel.Size = UDim2.new(1,-(fontHeight+1),1,-2)
&#9;&#9;end
&#9;end
&#9;local function updatePlayerName(nameObject, membershipStatus, teamColor)
&#9;&#9;local fontHeight = 20
&#9;&#9;
&#9;&#9;local membershipType = membershipStatus
&#9;&#9;local playerName = nameObject.NameLabel.Text
&#9;&#9;
&#9;&#9;nameObject.Size = UDim2.new(1,0,0,fontHeight)
&#9;&#9;nameObject.MembershipTypeLabel.Image = getMembershipTypeIcon(membershipType, playerName)
&#9;end

&#9;
&#9;local function updatePlayerNameColor(player, teamColor)
&#9;&#9;local function updatePlayerNameColorHelper(nameObject)
&#9;&#9;&#9;if teamColor ~= nil then
&#9;&#9;&#9;&#9;nameObject.NameLabel.TextColor3 = getColor(teamColor)
&#9;&#9;&#9;&#9;nameObject.NameLabel.FullNameLabel.TextColor3 = getColor(teamColor)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;nameObject.NameLabel.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;nameObject.NameLabel.FullNameLabel.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;
&#9;&#9;updatePlayerNameColorHelper(playerTable[player].NameObjectSmall)
&#9;&#9;updatePlayerNameColorHelper(playerTable[player].NameObjectBig)
&#9;end


&#9;local function createPlayerName(name, membershipStatus, teamColor, friendStatus)
&#9;&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;&#9;frame.Name = &quot;Player_&quot; .. name
&#9;&#9;frame.BackgroundColor3 = Color3.new(1,1,1)
&#9;&#9;frame.BackgroundTransparency = 0.5
&#9;&#9;frame.BorderSizePixel = 0
&#9;&#9;
&#9;&#9;local membershipStatusLabel = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;membershipStatusLabel.Name = &quot;MembershipTypeLabel&quot;
&#9;&#9;membershipStatusLabel.BackgroundTransparency = 1
&#9;&#9;membershipStatusLabel.Size = UDim2.new(1,0,1,0)
&#9;&#9;membershipStatusLabel.Position = UDim2.new(0,0,0,0)
&#9;&#9;membershipStatusLabel.SizeConstraint = Enum.SizeConstraint.RelativeYY
&#9;&#9;membershipStatusLabel.Parent = frame

&#9;&#9;local friendStatusLabel = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;friendStatusLabel.Name = &quot;FriendStatusLabel&quot;
&#9;&#9;friendStatusLabel.Visible = false
&#9;&#9;friendStatusLabel.BackgroundTransparency = 1
&#9;&#9;friendStatusLabel.Size = UDim2.new(1,0,1,0)
&#9;&#9;friendStatusLabel.Position = UDim2.new(1,0,0,0)
&#9;&#9;friendStatusLabel.Parent = membershipStatusLabel

&#9;&#9;local changeNameFunction
&#9;&#9;local nameLabel = Instance.new(&quot;TextLabel&quot;)
&#9;&#9;nameLabel.Name = &quot;NameLabel&quot;
&#9;&#9;nameLabel.Text = name
&#9;&#9;nameLabel.Font = Enum.Font.ArialBold
&#9;&#9;nameLabel.FontSize = Enum.FontSize.Size14
&#9;&#9;nameLabel.TextColor3 = Color3.new(1,1,1)
&#9;&#9;nameLabel.BackgroundTransparency = 1
&#9;&#9;nameLabel.BackgroundColor3 = Color3.new(0,0,0)
&#9;&#9;nameLabel.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;nameLabel, changeNameFunction = RbxGui.AutoTruncateTextObject(nameLabel)
&#9;&#9;nameLabel.Parent = frame
&#9;&#9;
&#9;&#9;updatePlayerName(frame, membershipStatus, teamColor)
&#9;&#9;if supportFriends and not friendRequestBlacklist[game.Players:FindFirstChild(name)] then
&#9;&#9;&#9;updatePlayerFriendStatus(frame, friendStatus)
&#9;&#9;else
&#9;&#9;&#9;updatePlayerFriendStatus(frame, Enum.FriendStatus.NotFriend)
&#9;&#9;end
&#9;&#9;return frame, changeNameFunction
&#9;end

&#9;local function createStatColumn(i, numColumns, isTeam, color3, isHeader, stat)
&#9;&#9;local textLabel = Instance.new(&quot;TextButton&quot;)
&#9;&#9;textLabel.Name = &quot;Stat&quot; .. i
&#9;&#9;textLabel.AutoButtonColor = false
&#9;&#9;textLabel.TextColor3 = Color3.new(1,1,1)
&#9;&#9;textLabel.TextXAlignment = Enum.TextXAlignment.Right
&#9;&#9;textLabel.TextYAlignment = Enum.TextYAlignment.Center
&#9;&#9;textLabel.FontSize = Enum.FontSize.Size14
&#9;&#9;
&#9;&#9;if isHeader then
&#9;&#9;&#9;textLabel.FontSize = Enum.FontSize.Size18
&#9;&#9;else
&#9;&#9;&#9;textLabel.FontSize = Enum.FontSize.Size14
&#9;&#9;end
&#9;&#9;if isHeader or isTeam then
&#9;&#9;&#9;textLabel.Font = Enum.Font.ArialBold
&#9;&#9;else 
&#9;&#9;&#9;textLabel.Font = Enum.Font.Arial
&#9;&#9;end

&#9;&#9;if isTeam then
&#9;&#9;&#9;textLabel.BackgroundColor3 = color3
&#9;&#9;&#9;textLabel.Text = 0
&#9;&#9;else
&#9;&#9;&#9;textLabel.BackgroundColor3 = Color3.new(0,0,0)
&#9;&#9;&#9;textLabel.Text = &quot;&quot;
&#9;&#9;end
&#9;&#9;textLabel.BackgroundTransparency = 1
&#9;&#9;if i == numColumns then
&#9;&#9;&#9;textLabel.Size = UDim2.new(1/numColumns, -6, 1, 0)
&#9;&#9;else
&#9;&#9;&#9;textLabel.Size = UDim2.new(1/numColumns, -4, 1, 0)
&#9;&#9;end
&#9;&#9;
&#9;&#9;textLabel.Position = UDim2.new((i-1) * (1/numColumns), 0, 0, 0)
&#9;&#9;
&#9;&#9;local truncLabel, changer = RbxGui.AutoTruncateTextObject(textLabel)
&#9;&#9;
&#9;&#9;if isHeader then
&#9;&#9;&#9;local mouseCon = {}
&#9;
&#9;&#9;&#9;mouseCon[1] = truncLabel.MouseEnter:connect(function()
&#9;&#9;&#9;&#9;truncLabel.BackgroundTransparency = 0.2
&#9;&#9;&#9;end)
&#9;&#9;&#9;mouseCon[2] = truncLabel.MouseLeave:connect(function()
&#9;&#9;&#9;&#9;truncLabel.BackgroundTransparency = 1
&#9;&#9;&#9;end)
&#9;&#9;&#9;
&#9;&#9;&#9;mouseCon[3] = truncLabel.MouseButton1Click:connect(function()
&#9;&#9;&#9;&#9;sortPlayerListsFunction(truncLabel:GetChildren()[1].Name, (currentSortName == truncLabel:GetChildren()[1].Name) )
&#9;&#9;&#9;&#9;truncLabel.BackgroundTransparency = 1
&#9;&#9;&#9;end)
&#9;&#9;&#9;
&#9;&#9;&#9;mouseCon[4] = truncLabel:GetChildren()[1].MouseButton1Click:connect(function()
&#9;&#9;&#9;&#9;sortPlayerListsFunction(textLabel.Name, (currentSortName == truncLabel.Name) )
&#9;&#9;&#9;&#9;truncLabel.BackgroundTransparency = 1
&#9;&#9;&#9;end)
&#9;&#9;&#9;
&#9;&#9;&#9;mouseCon[5] = nil
&#9;&#9;&#9;mouseCon[5] = truncLabel.AncestryChanged:connect(function(child,parent)
&#9;&#9;&#9;&#9;if parent == nil then
&#9;&#9;&#9;&#9;&#9;for i,connection in pairs(mouseCon) do
&#9;&#9;&#9;&#9;&#9;&#9;connection:disconnect()
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;end
&#9;&#9;
&#9;&#9;return truncLabel, changer
&#9;end

&#9;local function createStatHeaders(stats, numColumns, isBig)
&#9;&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;&#9;frame.Name = &quot;Headers&quot;
&#9;&#9;frame.BorderSizePixel = 0
&#9;&#9;frame.BackgroundColor3 = Color3.new(0,0,0)
&#9;&#9;frame.BackgroundTransparency = 1
&#9;&#9;
&#9;&#9;local nameSize
&#9;&#9;if isBig then
&#9;&#9;&#9;nameSize = 0.5
&#9;&#9;elseif numColumns == 1 then
&#9;&#9;&#9;nameSize = 0.7
&#9;&#9;elseif numColumns == 2 then
&#9;&#9;&#9;nameSize = 0.6
&#9;&#9;else
&#9;&#9;&#9;nameSize = 0.45
&#9;&#9;end
&#9;&#9;frame.Size = UDim2.new(1-nameSize, 0, 1,0)
&#9;&#9;if isBig then
&#9;&#9;&#9;frame.Position = UDim2.new(nameSize,-25, 0,0)
&#9;&#9;else
&#9;&#9;&#9;frame.Position = UDim2.new(nameSize,0, 0,0)
&#9;&#9;end

&#9;&#9;local i = 1
&#9;&#9;while i &lt;= numColumns do
&#9;&#9;&#9;local headerColumn, changeText = createStatColumn(i, numColumns, false, nil, true,stats[i])
&#9;&#9;&#9;changeText(stats[i].Name)
&#9;&#9;&#9;headerColumn.Parent = frame
&#9;&#9;&#9;i = i + 1
&#9;&#9;end&#9;&#9;
&#9;&#9;return frame, textChangers
&#9;end

&#9;local function createStatColumns(nameObject, numColumns, isTeam, isBig) 
&#9;&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;&#9;frame.Name = nameObject.Name .. &quot;_WithStats&quot;
&#9;&#9;frame.BorderSizePixel = 0
&#9;&#9;frame.BackgroundColor3 = nameObject.BackgroundColor3
&#9;&#9;frame.BackgroundTransparency = nameObject.BackgroundTransparency
&#9;&#9;frame.Size = nameObject.Size
&#9;&#9;frame.Position = nameObject.Position

&#9;&#9;nameObject.BackgroundTransparency = 1

&#9;&#9;if numColumns == 0 then
&#9;&#9;&#9;nameObject.Size = UDim2.new(1,0,1,0)
&#9;&#9;&#9;nameObject.Position = UDim2.new(0,0,0,0)
&#9;&#9;&#9;nameObject.Parent = frame
&#9;&#9;&#9;return frame
&#9;&#9;end

&#9;&#9;local statFrame = Instance.new(&quot;Frame&quot;)
&#9;&#9;statFrame.Name = &quot;Stats&quot;
&#9;&#9;if isTeam then
&#9;&#9;&#9;statFrame.BorderSizePixel = 0
&#9;&#9;&#9;statFrame.BackgroundColor3 = nameObject.NameLabel.BackgroundColor3
&#9;&#9;&#9;statFrame.BackgroundTransparency = nameObject.NameLabel.BackgroundTransparency
&#9;&#9;else
&#9;&#9;&#9;statFrame.BackgroundTransparency = 1
&#9;&#9;end
&#9;&#9;
&#9;&#9;local nameSize
&#9;&#9;if isBig then
&#9;&#9;&#9;nameSize = 0.5
&#9;&#9;elseif numColumns == 1 then
&#9;&#9;&#9;nameSize = 0.7
&#9;&#9;elseif numColumns == 2 then
&#9;&#9;&#9;nameSize = 0.6
&#9;&#9;else
&#9;&#9;&#9;nameSize = 0.45
&#9;&#9;end
&#9;&#9;nameObject.Size = UDim2.new(nameSize, 0, 1, 0)
&#9;&#9;nameObject.Position = UDim2.new(0, 0, 0, 0)
&#9;&#9;statFrame.Size = UDim2.new(1-nameSize,0, 1,0)
&#9;&#9;statFrame.Position = UDim2.new(nameSize,0, 0,0)

&#9;&#9;nameObject.Parent = frame
&#9;&#9;statFrame.Parent = frame
&#9;&#9;
&#9;&#9;local textChangers = {}
&#9;&#9;local i = 1
&#9;&#9;while i &lt;= numColumns do
&#9;&#9;&#9;local statColumn, changeText = createStatColumn(i, numColumns, isTeam, statFrame.BackgroundColor3)
&#9;&#9;&#9;statColumn.Parent = statFrame
&#9;&#9;&#9;table.insert(textChangers, changeText)

&#9;&#9;&#9;i = i + 1
&#9;&#9;end&#9;&#9;
&#9;&#9;
&#9;&#9;return frame, statFrame, textChangers
&#9;end

&#9;local function createAlternatingRows(objects)
&#9;&#9;for i, line in ipairs(objects) do
&#9;&#9;&#9;if i % 2 == 0 then
&#9;&#9;&#9;&#9;line.BackgroundTransparency = 1
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;line.BackgroundTransparency = 0.95
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;local removeFromTeam = nil

&#9;local function clearTableEntry(obj, tableInfo)
&#9;&#9;if tableInfo.MainObjectSmall then
&#9;&#9;&#9;tableInfo.MainObjectSmall.Parent = nil
&#9;&#9;&#9;tableInfo.MainObjectSmall = nil
&#9;&#9;end
&#9;&#9;if tableInfo.MainObjectBig then
&#9;&#9;&#9;tableInfo.MainObjectBig.Parent = nil
&#9;&#9;&#9;tableInfo.MainObjectBig = nil
&#9;&#9;end
&#9;&#9;if tableInfo.Connections then
&#9;&#9;&#9;for i, connection in ipairs(tableInfo.Connections) do
&#9;&#9;&#9;&#9;connection:disconnect()
&#9;&#9;&#9;end
&#9;&#9;&#9;tableInfo.Connections = nil
&#9;&#9;end
&#9;&#9;if tableInfo.LeaderStatConnections then
&#9;&#9;&#9;for i, connection in ipairs(tableInfo.LeaderStatConnections) do
&#9;&#9;&#9;&#9;connection:disconnect()
&#9;&#9;&#9;end
&#9;&#9;&#9;tableInfo.LeaderStatConnections = nil
&#9;&#9;end
&#9;&#9;if tableInfo.CurrentTeam then
&#9;&#9;&#9;removeFromTeam(obj)
&#9;&#9;&#9;tableInfo.CurrentTeam = nil
&#9;&#9;end
&#9;&#9;if tableInfo.Players then
&#9;&#9;&#9;for i, player in ipairs(tableInfo.Players) do
&#9;&#9;&#9;&#9;playerTable[player].CurrentTeam = nil
&#9;&#9;&#9;end
&#9;&#9;&#9;tableInfo.Players = {}
&#9;&#9;end
&#9;&#9;if tableInfo.StatValues then
&#9;&#9;&#9;tableInfo.StatValues = nil
&#9;&#9;end
&#9;end
&#9;
&#9;local function resetPlayerTable()
&#9;&#9;for player, info in pairs(playerTable) do
&#9;&#9;&#9;clearTableEntry(player, info)
&#9;&#9;&#9;playerTable[player] = nil
&#9;&#9;end
&#9;&#9;playerTable = {}
&#9;end

&#9;local function resetTeamTable()
&#9;&#9;for team, info in pairs(teamTable) do
&#9;&#9;&#9;clearTableEntry(team, info)
&#9;&#9;&#9;teamTable[team] = nil
&#9;&#9;end
&#9;&#9;teamTable = {}
&#9;&#9;teamColorTable = {}
&#9;end

&#9;local function getBoardTypeInfo()
&#9;&#9;local isTeam  = (currentBoardType == &quot;TeamScore&quot; or currentBoardType == &quot;TeamList&quot;)
&#9;&#9;local isScore = (currentBoardType == &quot;TeamScore&quot; or currentBoardType == &quot;PlayerScore&quot;)
&#9;&#9;return isTeam, isScore
&#9;end


&#9;local function recomputeTeamScore(team, column)
&#9;&#9;if not team or team == &quot;Neutral&quot; then
&#9;&#9;&#9;return
&#9;&#9;end
&#9;&#9;
&#9;&#9;local function recomputeScoreHelper(statChangers)
&#9;&#9;&#9;if statChangers and column &lt;= #statChangers then
&#9;&#9;&#9;&#9;local sum = 0
&#9;&#9;&#9;&#9;for i, p in ipairs(teamTable[team].Players) do
&#9;&#9;&#9;&#9;&#9;if playerTable[p].StatValues and column &lt;= #playerTable[p].StatValues then
&#9;&#9;&#9;&#9;&#9;&#9;sum = sum + playerTable[p].StatValues[column].Value
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;statChangers[column](sum)
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;recomputeScoreHelper(teamTable[team].StatChangersSmall)
&#9;&#9;recomputeScoreHelper(teamTable[team].StatChangersBig)
&#9;end
&#9;local function recomputeCompleteTeamScore(team)
&#9;&#9;local col = 1
&#9;&#9;while col &lt;= currentStatCount do
&#9;&#9;&#9;recomputeTeamScore(team, col)
&#9;&#9;&#9;col = col + 1
&#9;&#9;end
&#9;end
&#9;removeFromTeam = function(player)
&#9;&#9;if playerTable[player].CurrentTeam ~= nil and teamTable[playerTable[player].CurrentTeam] ~= nil then
&#9;&#9;&#9;ArrayRemove(teamTable[playerTable[player].CurrentTeam].Players, player)
&#9;&#9;&#9;recomputeCompleteTeamScore(playerTable[player].CurrentTeam)
&#9;&#9;&#9;playerTable[player].CurrentTeam = nil
&#9;&#9;end
&#9;end

&#9;local function assignToTeam(player)
&#9;&#9;local isTeam, isScore = getBoardTypeInfo()

&#9;&#9;if isTeam then
&#9;&#9;&#9;local newTeam = nil

&#9;&#9;&#9;if player.Neutral or teamColorTable[player.TeamColor.Name] == nil then
&#9;&#9;&#9;&#9;newTeam = &quot;Neutral&quot;
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;newTeam = teamColorTable[player.TeamColor.Name] 
&#9;&#9;&#9;end&#9;&#9;&#9;

&#9;&#9;&#9;if playerTable[player].CurrentTeam == newTeam then
&#9;&#9;&#9;&#9;return
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;local oldTeam = playerTable[player].LastTeam
&#9;&#9;&#9;removeFromTeam(player)

&#9;&#9;&#9;playerTable[player].CurrentTeam = newTeam
&#9;&#9;&#9;
&#9;&#9;&#9;if teamTable[oldTeam] and teamTable[oldTeam][&quot;NameChangeFuncBig&quot;] then
&#9;&#9;&#9;&#9;if #teamTable[oldTeam].Players &lt; 1 then 
&#9;&#9;&#9;&#9;&#9;teamTable[oldTeam][&quot;NameChangeFuncBig&quot;](&quot; &quot; .. oldTeam.Name)
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;teamTable[oldTeam][&quot;NameChangeFuncBig&quot;](&quot; &quot; .. oldTeam.Name .. &quot;  (&quot; .. tostring(#teamTable[oldTeam].Players) ..&quot;)&quot;)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;if teamTable[newTeam] then
&#9;&#9;&#9;&#9;table.insert(teamTable[newTeam].Players, player)
&#9;&#9;&#9;&#9;if newTeam[&quot;Name&quot;] then
&#9;&#9;&#9;&#9;&#9;if teamTable[newTeam][&quot;NameChangeFuncBig&quot;] then
&#9;&#9;&#9;&#9;&#9;&#9;if #teamTable[newTeam].Players &lt; 1 then 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;teamTable[newTeam][&quot;NameChangeFuncBig&quot;](&quot; &quot; .. newTeam.Name)
&#9;&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;&#9;teamTable[newTeam][&quot;NameChangeFuncBig&quot;](&quot; &quot; .. newTeam.Name .. &quot;  (&quot; .. tostring(#teamTable[newTeam].Players) ..&quot;)&quot;)
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;
&#9;&#9;&#9;if newTeam == &quot;Neutral&quot; then
&#9;&#9;&#9;&#9;updatePlayerNameColor(player, nil)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;updatePlayerNameColor(player, player.TeamColor)
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;playerTable[player].LastTeam = newTeam
&#9;&#9;&#9;
&#9;&#9;&#9;recomputeCompleteTeamScore(newTeam)
&#9;&#9;&#9;
&#9;&#9;&#9;--Relayout
&#9;&#9;&#9;if sortPlayerListsFunction then
&#9;&#9;&#9;&#9;sortPlayerListsFunction()
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;local function buildTeamObject(team, numStatColumns, suffix)
&#9;&#9;local isTeam, isScore = getBoardTypeInfo()
&#9;&#9;local teamObject, changeFunc = createTeamName(team.Name, team.TeamColor)
&#9;&#9;teamObject.NameLabel.Text = &quot; &quot; .. team.Name .. &quot; (0)&quot;
&#9;&#9;if not teamTable[team] then
&#9;&#9;&#9;teamTable[team] = {} 
&#9;&#9;end
&#9;&#9;teamTable[team][&quot;NameObject&quot; .. suffix] = teamObject
&#9;&#9;teamTable[team][&quot;NameChangeFunc&quot; .. suffix] = changeFunc
&#9;&#9;if isScore then
&#9;&#9;&#9;local statObject
&#9;&#9;&#9;local textChangers
&#9;&#9;&#9;teamObject, statObject, textChangers = createStatColumns(teamObject, numStatColumns, true, suffix == &quot;Big&quot;)
&#9;&#9;&#9;teamTable[team][&quot;StatObject&quot; .. suffix] = statObject
&#9;&#9;&#9;teamTable[team][&quot;StatChangers&quot; .. suffix] = textChangers
&#9;&#9;end
&#9;&#9;teamTable[team][&quot;MainObject&quot; .. suffix] = teamObject
&#9;&#9;changeFunc(&quot; &quot; .. team.Name)
&#9;&#9;if not teamTable[team].Players then
&#9;&#9;&#9;teamTable[team].Players = {}
&#9;&#9;else
&#9;&#9;&#9;if suffix ~= &quot;Small&quot; and #teamTable[team].Players &gt; 0 then 
&#9;&#9;&#9;&#9;changeFunc(&quot; &quot; .. team.Name .. &quot;  (&quot; .. tostring(#teamTable[team].Players) ..&quot;)&quot;)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;
&#9;&#9;return teamObject
&#9;end
&#9;
&#9;local currentContextMenuPlayer = nil
&#9;local function updatePlayerContextMenu(player,x,y)
&#9;&#9;currentContextMenuPlayer = player
&#9;&#9;local elementHeight = 18
&#9;&#9;local function highlight(button)
&#9;&#9;&#9;button.TextColor3 = Color3.new(0,0,0)
&#9;&#9;&#9;button.BackgroundColor3 = Color3.new(0.8,0.8,0.8)
&#9;&#9;end
&#9;&#9;local function clearHighlight(button)
&#9;&#9;&#9;button.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;button.BackgroundColor3 = Color3.new(0,0,0)
&#9;&#9;end
&#9;&#9;if playerContextMenu == nil then
&#9;&#9;&#9;elementNames = {}
&#9;&#9;&#9;elementNameToElement = {}
&#9;&#9;&#9;
&#9;&#9;&#9;for i, contextElement in ipairs(contextMenuElements) do
&#9;&#9;&#9;&#9;table.insert(elementNames, contextElement.Text)
&#9;&#9;&#9;&#9;elementNameToElement[tostring(contextElement.Text)] = contextElement
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;playerContextMenu = Instance.new(&quot;TextButton&quot;)
&#9;&#9;&#9;playerContextMenu.Name = &quot;PlayerListContextMenu&quot;
&#9;&#9;&#9;playerContextMenu.Style = Enum.ButtonStyle.RobloxButton
&#9;&#9;&#9;playerContextMenu.Text = &quot;&quot;
&#9;&#9;&#9;playerContextMenu.Visible = false
&#9;&#9;&#9;playerContextMenu.ZIndex = 4
&#9;&#9;&#9;
&#9;&#9;&#9;playerContextMenu.MouseLeave:connect(function()
&#9;&#9;&#9;&#9;local menuChildren = playerContextMenu:GetChildren()
&#9;&#9;&#9;&#9;for i = 1, #menuChildren do
&#9;&#9;&#9;&#9;&#9;if menuChildren[i].Name == &quot;ChoiceButton&quot; then
&#9;&#9;&#9;&#9;&#9;&#9;menuChildren[i].TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;&#9;&#9;menuChildren[i].BackgroundTransparency = 1
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;playerContextMenu.Visible = false
&#9;&#9;&#9;&#9;inContextMenu = false
&#9;&#9;&#9;end)
&#9;&#9;&#9;
&#9;&#9;&#9;playerContextMenu.MouseEnter:connect(function()
&#9;&#9;&#9;&#9;inContextMenu = true
&#9;&#9;&#9;end)
&#9;&#9;&#9;
&#9;&#9;&#9;for i = 1, #elementNames do
&#9;&#9;&#9;&#9;local newElementButton = Instance.new(&quot;TextButton&quot;)
&#9;&#9;&#9;&#9;newElementButton.Name = &quot;ChoiceButton&quot;
&#9;&#9;&#9;&#9;newElementButton.Text = elementNames[i]
&#9;&#9;&#9;&#9;newElementButton.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;newElementButton.Font = Enum.Font.Arial
&#9;&#9;&#9;&#9;newElementButton.FontSize = Enum.FontSize.Size14
&#9;&#9;&#9;&#9;newElementButton.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;newElementButton.TextWrap = true
&#9;&#9;&#9;&#9;newElementButton.Size = UDim2.new(1,0,0,elementHeight)
&#9;&#9;&#9;&#9;newElementButton.Position = UDim2.new(0,0,0,elementHeight * (i - 1))
&#9;&#9;&#9;&#9;newElementButton.ZIndex = playerContextMenu.ZIndex + 1
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;newElementButton.MouseEnter:connect(function()
&#9;&#9;&#9;&#9;&#9;newElementButton.TextColor3 = Color3.new(0,0,0)
&#9;&#9;&#9;&#9;&#9;newElementButton.BackgroundTransparency = 0
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;newElementButton.MouseLeave:connect(function()
&#9;&#9;&#9;&#9;&#9;newElementButton.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;&#9;newElementButton.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;newElementButton.MouseButton1Click:connect(function()
&#9;&#9;&#9;&#9;&#9;local element = elementNameToElement[newElementButton.Text]
&#9;&#9;&#9;&#9;&#9;pcall(function() element.DoIt(currentContextMenuPlayer) end)
&#9;&#9;&#9;&#9;&#9;playerContextMenu.Visible = false
&#9;&#9;&#9;&#9;&#9;newElementButton.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;&#9;newElementButton.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;newElementButton.Parent = playerContextMenu
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;robloxLock(playerContextMenu)
&#9;&#9;&#9;playerContextMenu.Parent = script.Parent
&#9;&#9;&#9;
&#9;&#9;end
&#9;&#9;
&#9;&#9;local visibleElements = 0
&#9;&#9;for i, contextElement in ipairs(contextMenuElements) do
&#9;&#9;&#9;local isVisible = false

&#9;&#9;&#9;if contextElement.IsVisible then
&#9;&#9;&#9;&#9;local success, visible = pcall(function() return contextElement.IsVisible(currentContextMenuPlayer) end)
&#9;&#9;&#9;&#9;if success then 
&#9;&#9;&#9;&#9;&#9;isVisible = visible
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;print(&quot;Error in IsVisible call: &quot; .. visible)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;
&#9;&#9;&#9;if isVisible then
&#9;&#9;&#9;&#9;local foundElement = false
&#9;&#9;&#9;&#9;for i = 1, #elementNames do
&#9;&#9;&#9;&#9;&#9;if elementNames[i] == contextElement.Text then 
&#9;&#9;&#9;&#9;&#9;&#9;foundElement = true
&#9;&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if not foundElement then
&#9;&#9;&#9;&#9;&#9;table.insert(elementNames,contextElement.Text)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;visibleElements = visibleElements + 1
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;for i = 1, #elementNames do
&#9;&#9;&#9;&#9;&#9;if elementNames[i] == contextElement.Text then 
&#9;&#9;&#9;&#9;&#9;&#9;table.remove(elementNames,i)
&#9;&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;playerContextMenu.Size = UDim2.new(0, 150, 0, elementHeight + (elementHeight * visibleElements) )
&#9;&#9;
&#9;&#9;if x and y then
&#9;&#9;&#9;x = x - (playerContextMenu.AbsoluteSize.X/2)
&#9;&#9;&#9;if x + playerContextMenu.AbsoluteSize.X &gt;= script.Parent.AbsoluteSize.X then
&#9;&#9;&#9;&#9;x = script.Parent.AbsoluteSize.X - playerContextMenu.AbsoluteSize.X
&#9;&#9;&#9;end
&#9;&#9;&#9;playerContextMenu.Position = UDim2.new(0, x, 0, y - 3)
&#9;&#9;end
&#9;&#9;
&#9;&#9;local elementPos = 0
&#9;&#9;local contextChildren = playerContextMenu:GetChildren()
&#9;&#9;for i = 1, #contextChildren do
&#9;&#9;&#9;if contextChildren[i]:IsA(&quot;GuiObject&quot;) and contextChildren[i].Name == &quot;ChoiceButton&quot; then
&#9;&#9;&#9;&#9;contextChildren[i].Visible = false
&#9;&#9;&#9;&#9;for j = 1, #elementNames do
&#9;&#9;&#9;&#9;&#9;if elementNames[j] == contextChildren[i].Text then
&#9;&#9;&#9;&#9;&#9;&#9;contextChildren[i].Visible = true
&#9;&#9;&#9;&#9;&#9;&#9;contextChildren[i].Position = UDim2.new(0,0,0,elementPos * elementHeight)
&#9;&#9;&#9;&#9;&#9;&#9;elementPos = elementPos + 1
&#9;&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;local function playerContextMenuHasItems()
&#9;&#9;if playerContextMenu then
&#9;&#9;&#9;local children = playerContextMenu:GetChildren()
&#9;&#9;&#9;for i = 1, #children do
&#9;&#9;&#9;&#9;if children[i]:IsA(&quot;GuiObject&quot;) and children[i].Name == &quot;ChoiceButton&quot; and children[i].Visible then
&#9;&#9;&#9;&#9;&#9;return true
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;return false
&#9;end
&#9;
&#9;local function showPlayerMenu(player, x, y)
&#9;&#9;updatePlayerContextMenu(player,x,y)
&#9;&#9;if not playerContextMenuHasItems() then return end -- don&apos;t show if we have nothing to show
&#9;&#9;playerContextMenu.Visible = true
&#9;end

&#9;local function buildPlayerObject(player, numStatColumns, suffix)
&#9;&#9;if not player then return nil end
&#9;&#9;
&#9;&#9;local isTeam, isScore = getBoardTypeInfo()

&#9;&#9;local playerObject = nil
&#9;&#9;local changePlayerNameFunction = nil
&#9;&#9;local currentColor = nil
&#9;&#9;if isTeam and not player.Neutral then
&#9;&#9;&#9;currentColor = player.TeamColor.Color
&#9;&#9;else
&#9;&#9;&#9;currentColor = Color3.new(1,1,1)
&#9;&#9;end
&#9;&#9;&#9;playerObject, changePlayerNameFunction = createPlayerName(player.Name, player.MembershipType, currentColor, getFriendStatus(player))
&#9;&#9;
&#9;&#9;if not playerTable[player] then
&#9;&#9;&#9;playerTable[player] = {}
&#9;&#9;end
&#9;&#9;if not playerTable[player].Connections then
&#9;&#9;&#9;playerTable[player].Connections = {}
&#9;&#9;end
&#9;&#9;if not playerTable[player].CurrentTeam then
&#9;&#9;&#9;playerTable[player].CurrentTeam = nil
&#9;&#9;end
&#9;&#9;if not playerTable[player].LastTeam then
&#9;&#9;&#9;playerTable[player].LastTeam = nil
&#9;&#9;end
&#9;&#9;playerTable[player][&quot;NameObject&quot; .. suffix] = playerObject
&#9;&#9;playerTable[player][&quot;ChangeName&quot; .. suffix] = changePlayerNameFunction

&#9;&#9;if isScore then
&#9;&#9;&#9;local statObject = nil
&#9;&#9;&#9;local textChangers = nil
&#9;&#9;&#9;playerObject, statObject, textChangers = createStatColumns(playerObject, numStatColumns, false, suffix == &quot;Big&quot;)
&#9;&#9;&#9;playerTable[player][&quot;StatObject&quot; .. suffix]= statObject
&#9;&#9;&#9;playerTable[player][&quot;StatChangers&quot; .. suffix] = textChangers
&#9;&#9;&#9;
&#9;&#9;&#9;local statValues, leaderstats = getStatValuesForPlayer(player)
&#9;&#9;&#9;if not statValues or #statValues &lt; numStatColumns then
&#9;&#9;&#9;&#9;if not playerTable[player].LeaderStatConnections then
&#9;&#9;&#9;&#9;&#9;playerTable[player].LeaderStatConnections = {}
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;--Setup a listener to see when this data gets filled in
&#9;&#9;&#9;&#9;if not leaderstats then
&#9;&#9;&#9;&#9;&#9;--We don&apos;t even have a leaderstats child, wait for one
&#9;&#9;&#9;&#9;&#9;table.insert(playerTable[player].LeaderStatConnections, 
&#9;&#9;&#9;&#9;&#9;&#9;player.ChildAdded:connect(
&#9;&#9;&#9;&#9;&#9;&#9;&#9;function(child)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;if child.Name == &quot;leaderstats&quot; then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;--Connections will be torn down
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;recreatePlayerFunction(player)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;table.insert(playerTable[player].LeaderStatConnections, 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;child.Changed:connect(
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;function(prop)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;if prop == &quot;Name&quot; and child.Name == &quot;leaderstats&quot; then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;--Connections will be torn down
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;recreatePlayerFunction(player)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end))
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end))
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;--We have a leaderstats, but not enough children, recreate if we get them
&#9;&#9;&#9;&#9;&#9;table.insert(playerTable[player].LeaderStatConnections, 
&#9;&#9;&#9;&#9;&#9;&#9;leaderstats.ChildAdded:connect(
&#9;&#9;&#9;&#9;&#9;&#9;&#9;function(child)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;--TODO only look for IntValue
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;recreatePlayerFunction(player)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;&#9;&#9;)
&#9;&#9;&#9;&#9;&#9;table.insert(playerTable[player].LeaderStatConnections, 
&#9;&#9;&#9;&#9;&#9;&#9;leaderstats.AncestryChanged:connect(
&#9;&#9;&#9;&#9;&#9;&#9;&#9;function(child)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;--We got deleted, try again
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;recreatePlayerFunction(player)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;&#9;&#9;)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;if statValues then
&#9;&#9;&#9;&#9;if not playerTable[player].StatValues then
&#9;&#9;&#9;&#9;&#9;playerTable[player].StatValues = {}
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;local pos = 1
&#9;&#9;&#9;&#9;while pos &lt;= numStatColumns and pos &lt;= #statValues do
&#9;&#9;&#9;&#9;&#9;local currentColumn = pos
&#9;&#9;&#9;&#9;&#9;local statValue = statValues[pos]
&#9;&#9;&#9;&#9;&#9;local statChanger = textChangers[pos]

&#9;&#9;&#9;&#9;&#9;local updateStat = function(val)
&#9;&#9;&#9;&#9;&#9;&#9;statChanger(val)
&#9;&#9;&#9;&#9;&#9;&#9;if playerTable[player] ~= nil then recomputeTeamScore(playerTable[player].CurrentTeam, currentColumn) end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;if pos &gt; #playerTable[player].StatValues then
&#9;&#9;&#9;&#9;&#9;&#9;table.insert(playerTable[player].StatValues, statValue)
&#9;&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;&#9;if type(statValue) ~= &quot;number&quot; and statValue[&quot;Changed&quot;] then
&#9;&#9;&#9;&#9;&#9;&#9;table.insert(playerTable[player].Connections,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;statValue.Changed:connect(updateStat)
&#9;&#9;&#9;&#9;&#9;&#9;)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;table.insert(playerTable[player].Connections,
&#9;&#9;&#9;&#9;&#9;&#9;statValue.AncestryChanged:connect(
&#9;&#9;&#9;&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;&#9;&#9;&#9;recreatePlayerFunction(player)
&#9;&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;&#9;)
&#9;&#9;&#9;&#9;&#9;updateStat(statValue.Value)
&#9;&#9;&#9;&#9;&#9;pos = pos + 1
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;
&#9;&#9;if supportFriends and player ~= game.Players.LocalPlayer and player.userId &gt; 0 and  game.Players.LocalPlayer.userId &gt; 0 then
&#9;&#9;&#9;local button = Instance.new(&quot;TextButton&quot;)
&#9;&#9;&#9;button.Name = playerObject.Name .. &quot;Button&quot;
&#9;&#9;&#9;button.Text = &quot;&quot;
&#9;&#9;&#9;button.Active = false
&#9;&#9;&#9;button.Size = playerObject.Size
&#9;&#9;&#9;button.Position = playerObject.Position
&#9;&#9;&#9;button.BackgroundColor3 = playerObject.BackgroundColor3
&#9;&#9;&#9;
&#9;&#9;&#9;local secondButton = Instance.new(&quot;TextButton&quot;)
&#9;&#9;&#9;secondButton.Name = playerObject.Name .. &quot;RealButton&quot;
&#9;&#9;&#9;secondButton.Text = &quot;&quot;
&#9;&#9;&#9;secondButton.BackgroundTransparency = 1
&#9;&#9;&#9;secondButton.BackgroundColor3 = playerObject.BackgroundColor3
&#9;&#9;&#9;local theNameLabel = playerObject:findFirstChild(&quot;NameLabel&quot;,true)
&#9;&#9;&#9;secondButton.Parent.BackgroundTransparency = 1
&#9;&#9;&#9;secondButton.Parent.Visible = true
&#9;&#9;&#9;secondButton.ZIndex = 2
&#9;&#9;&#9;secondButton.Size = UDim2.new(1,0,1,0)

&#9;&#9;&#9;local previousTransparency = nil
&#9;&#9;&#9;table.insert(playerTable[player].Connections,
&#9;&#9;&#9;&#9;secondButton.MouseEnter:connect(
&#9;&#9;&#9;&#9;&#9;function(x,y)
&#9;&#9;&#9;&#9;&#9;&#9;if playerContextMenu and playerContextMenu.Visible then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;return
&#9;&#9;&#9;&#9;&#9;&#9;end -- don&apos;t update if we currently see it
&#9;&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;&#9;updatePlayerContextMenu(player,x,y)
&#9;&#9;&#9;&#9;&#9;&#9;if not playerContextMenuHasItems() then return end -- don&apos;t show if we have nothing to show
&#9;&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;&#9;if previousTransparency == nil then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;previousTransparency = secondButton.BackgroundTransparency
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;secondButton.Parent.BackgroundTransparency = 0
&#9;&#9;&#9;&#9;&#9;end))
&#9;&#9;&#9;table.insert(playerTable[player].Connections,
&#9;&#9;&#9;&#9;secondButton.MouseLeave:connect(
&#9;&#9;&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;&#9;&#9;if previousTransparency ~= nil then&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;previousTransparency = nil
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;delay(0.01,function()
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if playerContextMenu and not inContextMenu then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;playerContextMenu.Visible = false
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;&#9;&#9;secondButton.Parent.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;&#9;end))
&#9;&#9;&#9;
&#9;&#9;&#9;local mouseDownX, mouseDownY
&#9;&#9;&#9;table.insert(playerTable[player].Connections,
&#9;&#9;&#9;&#9;secondButton.MouseButton1Down:connect(function(x,y) 
&#9;&#9;&#9;&#9;&#9;mouseDownX = x
&#9;&#9;&#9;&#9;&#9;mouseDownY = y
&#9;&#9;&#9;&#9;end))
&#9;&#9;&#9;table.insert(playerTable[player].Connections,
&#9;&#9;&#9;&#9;secondButton.MouseButton1Click:connect(function()
&#9;&#9;&#9;&#9;&#9;showPlayerMenu(player, mouseDownX, secondButton.AbsolutePosition.Y + secondButton.AbsoluteSize.Y )
&#9;&#9;&#9;&#9;end))
&#9;&#9;&#9;playerObject.BackgroundTransparency = 1
&#9;&#9;&#9;playerObject.Size = UDim2.new(1,0,1,0)
&#9;&#9;&#9;playerObject.Position = UDim2.new(0,0,0,0)
&#9;&#9;&#9;playerObject.Parent = button
&#9;&#9;&#9;
&#9;&#9;&#9;playerTable[player][&quot;MainObject&quot; .. suffix] = button
&#9;&#9;&#9;
&#9;&#9;&#9;playerObject = button
&#9;&#9;else
&#9;&#9;&#9;playerTable[player][&quot;MainObject&quot; .. suffix] = playerObject
&#9;&#9;&#9;
&#9;&#9;&#9;if player == game.Players.LocalPlayer and supportFriends then
&#9;&#9;&#9;&#9;table.insert(playerTable[player].Connections,
&#9;&#9;&#9;&#9;&#9;player.FriendStatusChanged:connect(
&#9;&#9;&#9;&#9;&#9;function(otherPlayer, friendStatus)
&#9;&#9;&#9;&#9;&#9;&#9;if friendRequestBlacklist[otherPlayer] then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;updatePlayerFriendStatus(playerTable[otherPlayer][&quot;NameObject&quot; .. suffix], Enum.FriendStatus.NotFriend)
&#9;&#9;&#9;&#9;&#9;&#9;elseif playerTable[otherPlayer] then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;updatePlayerFriendStatus(playerTable[otherPlayer][&quot;NameObject&quot; .. suffix], friendStatus)
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;table.insert(playerTable[player].Connections,
&#9;&#9;&#9;player.Changed:connect(
&#9;&#9;&#9;&#9;function(prop)
&#9;&#9;&#9;&#9;&#9;if prop == &quot;MembershipType&quot; then
&#9;&#9;&#9;&#9;&#9;&#9;updatePlayerName(playerTable[player][&quot;NameObject&quot; .. suffix], player.MembershipType, currentColor)
&#9;&#9;&#9;&#9;&#9;elseif prop == &quot;Name&quot; then
&#9;&#9;&#9;&#9;&#9;&#9;playerTable[player][&quot;ChangeName&quot; .. suffix](player.Name)
&#9;&#9;&#9;&#9;&#9;elseif prop == &quot;Neutral&quot; or prop == &quot;TeamColor&quot; then
&#9;&#9;&#9;&#9;&#9;&#9;assignToTeam(player)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;)
&#9;&#9;return playerObject
&#9;end

&#9;local function doSort(tableToSort, objectName, order, startPos, sortType, ascending)
&#9;&#9;local orderedPlayerTable = {}
&#9;&#9;getLocalPlayer = false
&#9;&#9;for i, player in ipairs(tableToSort) do
&#9;&#9;&#9;if playerTable[player] then
&#9;&#9;&#9;&#9;if playerTable[player][objectName] ~= nil then
&#9;&#9;&#9;&#9;&#9;if player ~= game.Players.LocalPlayer then
&#9;&#9;&#9;&#9;&#9;&#9;table.insert(orderedPlayerTable,playerTable[player][objectName])
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;getLocalPlayer = true
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;
&#9;&#9;if sortType == nil then -- default back to alphabetical sort
&#9;&#9;&#9;table.sort(orderedPlayerTable,function(a,b)
&#9;&#9;&#9;&#9;return string.lower(a:FindFirstChild(&quot;FullNameLabel&quot;,true).Text) &lt; string.lower(b:FindFirstChild(&quot;FullNameLabel&quot;,true).Text)
&#9;&#9;&#9;end)
&#9;&#9;else -- we are sorting by a value
&#9;&#9;&#9;table.sort(orderedPlayerTable,function(a,b)
&#9;&#9;&#9;&#9;if ascending then
&#9;&#9;&#9;&#9;&#9;currentSortName = &quot;&quot;
&#9;&#9;&#9;&#9;&#9;return tonumber(a:FindFirstChild(sortType,true).Text) &gt; tonumber(b:FindFirstChild(sortType,true).Text)
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;currentSortName = sortType
&#9;&#9;&#9;&#9;&#9;return tonumber(a:FindFirstChild(sortType,true).Text) &lt; tonumber(b:FindFirstChild(sortType,true).Text)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;end
&#9;&#9;if getLocalPlayer and playerTable[game.Players.LocalPlayer] and playerTable[game.Players.LocalPlayer][objectName] then
&#9;&#9;&#9;table.insert(orderedPlayerTable,1,playerTable[game.Players.LocalPlayer][objectName])
&#9;&#9;end
&#9;&#9;for i = 1, #orderedPlayerTable do
&#9;&#9;&#9;order[orderedPlayerTable[i]] = startPos
&#9;&#9;&#9;startPos = startPos + 1
&#9;&#9;end
&#9;&#9;
&#9;&#9;return startPos
&#9;end

&#9;local function orderScrollList(scrollOrder, objectName, scrollFrame, sortType, ascending)
&#9;&#9;local pos = 0
&#9;&#9;local order = {}
&#9;&#9;local isTeam, isScore = getBoardTypeInfo()
&#9;&#9;for i, obj in ipairs(scrollOrder) do
&#9;&#9;&#9;order[obj] = 0
&#9;&#9;end

&#9;&#9;if isTeam then
&#9;&#9;&#9;local teams = getTeams()
&#9;&#9;&#9;for i, team in ipairs(teams) do
&#9;&#9;&#9;&#9;if teamTable[team][objectName] then
&#9;&#9;&#9;&#9;&#9;order[teamTable[team][objectName]] = pos
&#9;&#9;&#9;&#9;&#9;pos = pos + 1
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;pos = doSort(teamTable[team].Players, objectName, order, pos, sortType, ascending)
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;if #teamTable[&quot;Neutral&quot;].Players &gt; 0 then
&#9;&#9;&#9;&#9;teamTable[&quot;Neutral&quot;][objectName].Parent = scrollFrame
&#9;&#9;&#9;&#9;order[teamTable[&quot;Neutral&quot;][objectName]] = pos
&#9;&#9;&#9;&#9;pos = pos + 1
&#9;&#9;&#9;&#9;doSort(teamTable[&quot;Neutral&quot;].Players, objectName, order, pos, sortType, ascending)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;teamTable[&quot;Neutral&quot;][objectName].Parent = nil
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;local players = getPlayers()
&#9;&#9;&#9;doSort(players, objectName, order, pos, sortType, ascending)
&#9;&#9;end

&#9;&#9;table.sort(scrollOrder, 
&#9;&#9;&#9;function(a,b) 
&#9;&#9;&#9;&#9;return order[a] &lt; order[b] 
&#9;&#9;&#9;end)
&#9;end
&#9;
&#9;local function createPlayerListBasics(frame, isBig)
&#9;&#9;local headerFrame = Instance.new(&quot;Frame&quot;)
&#9;&#9;headerFrame.Name = &quot;Header&quot;
&#9;&#9;headerFrame.BackgroundTransparency = 1
&#9;&#9;headerFrame.Size = UDim2.new(1,-13,0,26)
&#9;&#9;headerFrame.Position = UDim2.new(0,0,0,0)
&#9;&#9;headerFrame.Parent = frame

&#9;&#9;local lowerPaneFrame = Instance.new(&quot;Frame&quot;)
&#9;&#9;lowerPaneFrame.Name = &quot;ScrollingArea&quot;
&#9;&#9;lowerPaneFrame.BackgroundTransparency = 1
&#9;&#9;lowerPaneFrame.Size = UDim2.new(1,-3,1,-26)
&#9;&#9;if not isBig then lowerPaneFrame.Size = UDim2.new(1,-3,1,-30) end
&#9;&#9;lowerPaneFrame.Position = UDim2.new(0,0,0,26)
&#9;&#9;lowerPaneFrame.Parent = frame

&#9;&#9;local scrollOrder = {}
&#9;&#9;local scrollFrame, scrollUp, scrollDown, recalculateScroll, scrollBar = RbxGui.CreateScrollingFrame(scrollOrder)

&#9;&#9;scrollBar.Size = UDim2.new(0, 17, 1, -36)
&#9;&#9;if isBig then scrollBar.Size = UDim2.new(0, 17, 1, -61) end
&#9;&#9;scrollBar.Parent = lowerPaneFrame

&#9;&#9;scrollFrame.Parent = lowerPaneFrame
&#9;&#9;scrollUp.Parent = lowerPaneFrame
&#9;&#9;scrollDown.Parent = lowerPaneFrame

&#9;&#9;if isBig then
&#9;&#9;&#9;scrollFrame.Position = UDim2.new(0,0,0,0)
&#9;&#9;&#9;scrollUp.Position = UDim2.new(1,-41,0,5)
&#9;&#9;&#9;scrollDown.Position = UDim2.new(1,-41,1,-35)
&#9;&#9;&#9;scrollBar.Position = UDim2.new(1, -41, 0, 24)

&#9;&#9;&#9;scrollFrame.Size = UDim2.new(1,-48,1,-16)
&#9;&#9;&#9;headerFrame.Size = UDim2.new(1,-20,0,26)
&#9;&#9;&#9;
&#9;&#9;else
&#9;&#9;&#9;scrollBar.Position = UDim2.new(1, -15, 0, 14)
&#9;&#9;&#9;scrollBar.Size = UDim2.new(0,17,1,-36)
&#9;&#9;&#9;scrollFrame.Position = UDim2.new(0,1,0,0)
&#9;&#9;&#9;scrollUp.Position = UDim2.new(1,-15,0,-5)
&#9;&#9;&#9;scrollDown.Position = UDim2.new(1,-15,1,-20)
&#9;&#9;&#9;
&#9;&#9;&#9;lowerPaneFrame.Position = UDim2.new(0,0,0,30)

&#9;&#9;&#9;local toggleScrollBar = function(visible)
&#9;&#9;&#9;&#9;if visible then
&#9;&#9;&#9;&#9;&#9;scrollFrame.Size = UDim2.new(1,-16,1,0)
&#9;&#9;&#9;&#9;&#9;headerFrame.Size = UDim2.new(1,-16,0,smallWindowHeaderYSize)
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;scrollFrame.Size = UDim2.new(1,0,1,0)
&#9;&#9;&#9;&#9;&#9;headerFrame.Size = UDim2.new(1,0,0,smallWindowHeaderYSize)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;scrollUp.Visible = visible
&#9;&#9;&#9;&#9;scrollDown.Visible = visible
&#9;&#9;&#9;&#9;scrollBar.Visible = visible
&#9;&#9;&#9;end
&#9;&#9;&#9;scrollUp.Changed:connect(function(prop) 
&#9;&#9;&#9;&#9;if prop == &quot;Active&quot; then
&#9;&#9;&#9;&#9;&#9;toggleScrollBar(scrollUp.Active or scrollDown.Active)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)

&#9;&#9;&#9;scrollDown.Changed:connect(function(prop) 
&#9;&#9;&#9;&#9;if prop == &quot;Active&quot; then
&#9;&#9;&#9;&#9;&#9;toggleScrollBar(scrollUp.Active or scrollDown.Active)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)

&#9;&#9;&#9;toggleScrollBar(scrollUp.Active or scrollDown.Active)
&#9;&#9;end
&#9;&#9;return headerFrame, scrollFrame, recalculateScroll, scrollOrder
&#9;end
&#9;&#9;&#9;
&#9;createBoardsFunction = function (boardType, numStatColumns)
&#9;&#9;local updatePlayerCount = function()
&#9;&#9;&#9;return #getPlayers()
&#9;&#9;end
&#9;&#9;
&#9;&#9;local smallFrame = Instance.new(&quot;Frame&quot;)
&#9;&#9;smallFrame.Name = &quot;SmallPlayerlist&quot;
&#9;&#9;smallFrame.Position = smallWindowPosition
&#9;&#9;smallFrame.Active = false
&#9;&#9;smallFrame.Size = smallWindowSize
&#9;&#9;smallFrame.BackgroundColor3 = Color3.new(0,0,0)
&#9;&#9;smallFrame.BackgroundTransparency = 0.7
&#9;&#9;smallFrame.BorderSizePixel = 0

&#9;&#9;local bigFrame = Instance.new(&quot;Frame&quot;)
&#9;&#9;bigFrame.Name = &quot;BigPlayerlist&quot;
&#9;&#9;bigFrame.Size = bigWindowSize
&#9;&#9;bigFrame.Position = bigWindowPosition
&#9;&#9;bigFrame.BackgroundColor3 = Color3.new(0,0,0)
&#9;&#9;bigFrame.BackgroundTransparency = 0.7
&#9;&#9;bigFrame.BorderSizePixel = 0
&#9;&#9;bigFrame.Visible = false&#9;&#9;
&#9;&#9;
&#9;&#9;local bigFrameWrapper = Instance.new(&quot;Frame&quot;)
&#9;&#9;bigFrameWrapper.Name = &quot;Expander&quot;
&#9;&#9;bigFrameWrapper.Size = UDim2.new(1,21,1,16)
&#9;&#9;bigFrameWrapper.Position = UDim2.new(0, 0, 0,0)
&#9;&#9;bigFrameWrapper.BackgroundTransparency = 1
&#9;&#9;bigFrameWrapper.Parent = bigFrame

&#9;&#9;local smallHeaderFrame, scrollFrameSmall, recalculateScrollSmall, scrollOrderSmall = createPlayerListBasics(smallFrame, false)
&#9;&#9;local bigHeaderFrame, scrollFrameBig, recalculateScrollBig, scrollOrderBig = createPlayerListBasics(bigFrameWrapper, true)
&#9;&#9;
&#9;&#9;local playerListButton = Instance.new(&quot;ImageButton&quot;)
&#9;&#9;playerListButton.Name = &quot;GoBigButton&quot;
&#9;&#9;playerListButton.BackgroundTransparency = 1
&#9;&#9;playerListButton.Image = &quot;rbxasset://textures/ui/playerlist_small_maximize.png&quot;
&#9;&#9;playerListButton.Size = UDim2.new(0.0, 35, 0, 29)
&#9;&#9;playerListButton.Position = UDim2.new(0, 0, 0, 0)
&#9;&#9;playerListButton.MouseButton1Click:connect(
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;toggleBigWindow()
&#9;&#9;&#9;end)
&#9;&#9;playerListButton.Parent = smallHeaderFrame

&#9;&#9;playerListButton = Instance.new(&quot;ImageButton&quot;)
&#9;&#9;playerListButton.Name = &quot;CloseButton&quot;
&#9;&#9;playerListButton.BackgroundTransparency = 1
&#9;&#9;playerListButton.Image = &quot;rbxasset://textures/ui/playerlist_small_hide.png&quot;
&#9;&#9;playerListButton.Size = UDim2.new(0.0, 38, 0, 29)
&#9;&#9;playerListButton.Position = UDim2.new(0, 35, 0, 0)
&#9;&#9;playerListButton.MouseButton1Click:connect(
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;transitionWindowsFunction(&quot;None&quot;)
&#9;&#9;&#9;end)
&#9;&#9;playerListButton.Parent = smallHeaderFrame

&#9;&#9;playerListButton = Instance.new(&quot;ImageButton&quot;)
&#9;&#9;playerListButton.Name = &quot;CloseButton&quot;
&#9;&#9;playerListButton.Image = &quot;rbxasset://textures/ui/playerlist_big_hide.png&quot;
&#9;&#9;playerListButton.BackgroundTransparency = 1
&#9;&#9;playerListButton.Size = UDim2.new(0.0, 29, 0, 29)
&#9;&#9;playerListButton.Position = UDim2.new(1, -30, 0.5, -13)
&#9;&#9;playerListButton.MouseButton1Click:connect(
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;toggleBigWindow()
&#9;&#9;&#9;end)
&#9;&#9;playerListButton.Parent = bigHeaderFrame

&#9;&#9;local placeName = Instance.new(&quot;TextButton&quot;)
&#9;&#9;placeName.Name = &quot;PlaceName&quot;
&#9;&#9;placeName.Text = &quot; Players (&quot; .. tostring(updatePlayerCount()) .. &quot;)&quot;
&#9;&#9;placeName.AutoButtonColor = false
&#9;&#9;placeName.FontSize = Enum.FontSize.Size24
&#9;&#9;placeName.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;placeName.Font = Enum.Font.ArialBold
&#9;&#9;placeName.BorderSizePixel = 0
&#9;&#9;placeName.BackgroundColor3 = Color3.new(0,0,0)
&#9;&#9;placeName.BackgroundTransparency = 1
&#9;&#9;placeName.TextColor3 = Color3.new(1,1,1)
&#9;&#9;placeName.Size = UDim2.new(0.4, 0, 1, 0)
&#9;&#9;placeName.Position = UDim2.new(0, 0, 0.0, 0)
&#9;&#9;placeName = RbxGui.AutoTruncateTextObject(placeName)
&#9;&#9;placeName.Parent = bigHeaderFrame
&#9;&#9;&#9;&#9;
&#9;&#9;placeName.MouseEnter:connect(function()
&#9;&#9;&#9;placeName.BackgroundTransparency = 0.2
&#9;&#9;end)
&#9;&#9;
&#9;&#9;placeName.MouseLeave:connect(function()
&#9;&#9;&#9;placeName.BackgroundTransparency = 1
&#9;&#9;end)
&#9;&#9;&#9;&#9;
&#9;&#9;placeName.MouseButton1Click:connect(function() 
&#9;&#9;&#9;sortPlayerListsFunction()
&#9;&#9;end)
&#9;&#9;
&#9;&#9;currentBoardType = boardType
&#9;&#9;currentStatCount = numStatColumns
&#9;&#9;local isTeam, isScore = getBoardTypeInfo()
&#9;&#9;local players = getPlayers()
&#9;&#9;
&#9;&#9;if isScore then
&#9;&#9;&#9;local statColumns = getStatColumns(players)
&#9;&#9;&#9;numStatColumns = #statColumns
&#9;&#9;&#9;if numStatColumns &gt; 3 then
&#9;&#9;&#9;&#9;numStatColumns = 3
&#9;&#9;&#9;end
&#9;&#9;&#9;createStatHeaders(statColumns, numStatColumns, false).Parent = smallHeaderFrame
&#9;&#9;&#9;createStatHeaders(statColumns, currentStatCount, true).Parent = bigHeaderFrame
&#9;&#9;end

&#9;&#9;--Clean up all old stuff
&#9;&#9;resetPlayerTable()
&#9;&#9;updatePlayerCount()

&#9;&#9;for i, player in ipairs(players) do
&#9;&#9;&#9;local playerObject = buildPlayerObject(player, numStatColumns, &quot;Small&quot;)
&#9;&#9;&#9;table.insert(scrollOrderSmall, playerObject)
&#9;&#9;&#9;playerObject.Parent = scrollFrameSmall

&#9;&#9;&#9;playerObject = buildPlayerObject(player, currentStatCount, &quot;Big&quot;)
&#9;&#9;&#9;table.insert(scrollOrderBig, playerObject)
&#9;&#9;&#9;playerObject.Parent = scrollFrameBig
&#9;&#9;end

&#9;&#9;--Clean up old stuff
&#9;&#9;resetTeamTable()

&#9;&#9;local teamStatObjects = {}
&#9;&#9;if isTeam then
&#9;&#9;&#9;local teams = getTeams()
&#9;&#9;&#9;local i = #teams
&#9;&#9;&#9;while i &gt;= 1 do
&#9;&#9;&#9;&#9;--We go backwards so the &quot;first&quot; team color gets the team
&#9;&#9;&#9;&#9;local team = teams[i]
&#9;&#9;&#9;&#9;teamColorTable[team.TeamColor.Name] = team
&#9;&#9;&#9;&#9;i = i - 1
&#9;&#9;&#9;end 

&#9;&#9;&#9;--Adding/Removing a Team causes a full invalidation of the board
&#9;&#9;&#9;for i, team in ipairs(teams) do
&#9;&#9;&#9;&#9;local teamObject = buildTeamObject(team, numStatColumns, &quot;Small&quot;)
&#9;&#9;&#9;&#9;table.insert(scrollOrderSmall, teamObject)
&#9;&#9;&#9;&#9;teamObject.Parent = scrollFrameSmall

&#9;&#9;&#9;&#9;teamObject = buildTeamObject(team, currentStatCount, &quot;Big&quot;)
&#9;&#9;&#9;&#9;table.insert(scrollOrderBig, teamObject)
&#9;&#9;&#9;&#9;teamObject.Parent = scrollFrameBig
&#9;&#9;&#9;end

&#9;&#9;&#9;teamTable[&quot;Neutral&quot;] = {}
&#9;&#9;&#9;teamTable[&quot;Neutral&quot;].Players = {}

&#9;&#9;&#9;local neutralTeamObject = createTeamName(&quot;Neutral&quot;, BrickColor.palette(8))
&#9;&#9;&#9;teamTable[&quot;Neutral&quot;].NameObjectSmall = neutralTeamObject
&#9;&#9;&#9;teamTable[&quot;Neutral&quot;].StatObjectSmall = nil
&#9;&#9;&#9;teamTable[&quot;Neutral&quot;].MainObjectSmall = neutralTeamObject
&#9;&#9;&#9;table.insert(scrollOrderSmall, neutralTeamObject)

&#9;&#9;&#9;neutralTeamObject = createTeamName(&quot;Neutral&quot;, BrickColor.palette(8))
&#9;&#9;&#9;teamTable[&quot;Neutral&quot;].NameObjectBig = neutralTeamObject
&#9;&#9;&#9;teamTable[&quot;Neutral&quot;].StatObjectBig = nil
&#9;&#9;&#9;teamTable[&quot;Neutral&quot;].MainObjectBig = neutralTeamObject
&#9;&#9;&#9;table.insert(scrollOrderBig, neutralTeamObject)

&#9;&#9;&#9;local neutralPlayers = {}
&#9;&#9;&#9;for i, player in ipairs(players) do
&#9;&#9;&#9;&#9;assignToTeam(player)
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;removePlayerFunction = function(player)
&#9;&#9;&#9;if playerTable[player] then
&#9;&#9;&#9;&#9;clearTableEntry(player, playerTable[player])
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;placeName.Text = &quot; Players (&quot; .. tostring(updatePlayerCount()) .. &quot;)&quot;
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;ArrayRemove(scrollOrderSmall, playerTable[player].MainObjectSmall)
&#9;&#9;&#9;&#9;ArrayRemove(scrollOrderBig, playerTable[player].MainObjectBig)
&#9;
&#9;&#9;&#9;&#9;playerTable[player] = nil
&#9;&#9;&#9;&#9;recalculateSmallPlayerListSize(smallFrame)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;recreatePlayerFunction = function(player)
&#9;&#9;&#9;placeName.Text = &quot; Players (&quot; .. tostring(updatePlayerCount()) .. &quot;)&quot;
&#9;&#9;&#9;
&#9;&#9;&#9;removePlayerFunction(player)

&#9;&#9;&#9;local playerObject = buildPlayerObject(player, numStatColumns, &quot;Small&quot;)
&#9;&#9;&#9;table.insert(scrollOrderSmall, playerObject)
&#9;&#9;&#9;robloxLock(playerObject)
&#9;&#9;&#9;playerObject.Parent = scrollFrameSmall

&#9;&#9;&#9;playerObject = buildPlayerObject(player, currentStatCount, &quot;Big&quot;)
&#9;&#9;&#9;table.insert(scrollOrderBig, playerObject)
&#9;&#9;&#9;robloxLock(playerObject)
&#9;&#9;&#9;playerObject.Parent = scrollFrameBig
&#9;&#9;&#9;
&#9;&#9;&#9;local isTeam, isScore = getBoardTypeInfo()
&#9;&#9;&#9;if isTeam then
&#9;&#9;&#9;&#9;assignToTeam(player)
&#9;&#9;&#9;end

&#9;&#9;&#9;sortPlayerListsFunction()
&#9;&#9;&#9;recalculateSmallPlayerListSize(smallFrame)
&#9;&#9;end
&#9;&#9;
&#9;&#9;if screenResizeCon then screenResizeCon:disconnect() end
&#9;&#9;screenResizeCon = screen.Changed:connect(
&#9;&#9;&#9;function(prop)
&#9;&#9;&#9;&#9;if prop == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;&#9;&#9;wait()
&#9;&#9;&#9;&#9;&#9;recalculateSmallPlayerListSize(smallFrame)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)

&#9;&#9;sortPlayerListsFunction = function(sortType, ascending)
&#9;&#9;&#9;orderScrollList(scrollOrderSmall, &quot;MainObjectSmall&quot;, scrollFrameSmall, sortType, ascending)
&#9;&#9;&#9;recalculateScrollSmall()
&#9;&#9;&#9;createAlternatingRows(scrollOrderSmall)

&#9;&#9;&#9;orderScrollList(scrollOrderBig, &quot;MainObjectBig&quot;, scrollFrameBig, sortType, ascending)
&#9;&#9;&#9;recalculateScrollBig()
&#9;&#9;&#9;createAlternatingRows(scrollOrderBig)
&#9;&#9;end

&#9;&#9;sortPlayerListsFunction()

&#9;&#9;robloxLock(smallFrame)
&#9;&#9;robloxLock(bigFrame)
&#9;&#9;return smallFrame, bigFrame
&#9;end

&#9;--Teams changing invalidates the whole board&#9;
&#9;local function teamsChanged()
&#9;&#9;if debounceTeamsChanged then 
&#9;&#9;&#9;return 
&#9;&#9;end

&#9;&#9;debounceTeamsChanged = true
&#9;&#9;wait()
&#9;&#9;rebuildBoard(script.Parent, determineBoardType())
&#9;&#9;debounceTeamsChanged = false
&#9;end

&#9;
&#9;local checkIfBoardChanged = function()
&#9;&#9;local newBoardType, numStats = determineBoardType()
&#9;&#9;if newBoardType ~= currentBoardType or numStats ~= currentStatCount then
&#9;&#9;&#9;rebuildBoard(script.Parent, newBoardType, numStats)
&#9;&#9;end
&#9;end

&#9;local function buildPlayerList()
&#9;&#9;waitForChild(game, &quot;Players&quot;)
&#9;&#9;waitForProperty(game.Players, &quot;LocalPlayer&quot;)
&#9;&#9;
&#9;&#9;local teams = game:GetService(&quot;Teams&quot;)
&#9;&#9;if teams then
&#9;&#9;&#9;local teamConnections = {}

&#9;&#9;&#9;teams.ChildAdded:connect(
&#9;&#9;&#9;&#9;function(child)
&#9;&#9;&#9;&#9;&#9;if child:IsA(&quot;Team&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;teamsChanged()
&#9;&#9;&#9;&#9;&#9;&#9;teamConnections[child] = child.Changed:connect(
&#9;&#9;&#9;&#9;&#9;&#9;&#9;function(prop)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;if prop == &quot;TeamColor&quot; or prop == &quot;Name&quot; then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;--Rebuild when things change
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;teamsChanged()
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;teams.ChildRemoved:connect(
&#9;&#9;&#9;&#9;function(child)
&#9;&#9;&#9;&#9;&#9;if child:IsA(&quot;Team&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;if teamConnections[child] then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;teamConnections[child]:disconnect()
&#9;&#9;&#9;&#9;&#9;&#9;&#9;teamConnections[child] = nil
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;teamsChanged()
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end)
&#9;&#9;end

&#9;&#9;game.Players.ChildAdded:connect(
&#9;&#9;&#9;function(player)
&#9;&#9;&#9;&#9;if player:IsA(&quot;Player&quot;) then
&#9;&#9;&#9;&#9;&#9;addPlayerFunction(player)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)

&#9;&#9;game.Players.ChildRemoved:connect(
&#9;&#9;&#9;function(player)
&#9;&#9;&#9;&#9;if player:IsA(&quot;Player&quot;) then
&#9;&#9;&#9;&#9;&#9;if removePlayerFunction then
&#9;&#9;&#9;&#9;&#9;&#9;removePlayerFunction(player)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)

&#9;&#9;rebuildBoard(script.Parent, determineBoardType())

&#9;&#9;delay(0,
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;while true  do
&#9;&#9;&#9;&#9;&#9;wait(5)
&#9;&#9;&#9;&#9;&#9;checkIfBoardChanged()
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;end
&#9;
&#9;&#9;buildPlayerList()
end 

if not personalServerPlace then -- one more backup check
&#9;local theBool = game.Workspace:FindFirstChild(&quot;PSVariable&quot;)
&#9;if theBool and theBool:IsA(&quot;BoolValue&quot;) then
&#9;&#9;personalServerPlace = true
&#9;end
end

if personalServerPlace then
&#9;addPersonalServerContext()
&#9;setupBuildToolManagement()
else
&#9;local psVarCon = nil
&#9;psVarCon = game.Workspace.ChildAdded:connect(function(child)
&#9;&#9;if child:IsA(&quot;BoolValue&quot;) and child.Name == &quot;PSVariable&quot; then
&#9;&#9;&#9;psVarCon:disconnect()
&#9;&#9;&#9;personalServerPlace = true
&#9;&#9;&#9;addPersonalServerContext()
&#9;&#9;&#9;setupBuildToolManagement()
&#9;&#9;end
&#9;end)
end</ProtectedString>
				</Properties>
			</Item>
		</Item>
	</Item>
</roblox>